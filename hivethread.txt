[h1][size=6][color=#fff]WurstScript[/color][/size][/h1]
[size=2][color=#888]by peq & Frotty[/color][/size]
[size=2][color=#888]with contributions from Crigges & muzzel[/color][/size]
    
[center]
	[IMG]https://dl.dropboxusercontent.com/u/19704285/Wurst.jpg[/IMG]
	[img]https://dl.dropboxusercontent.com/u/19704285/wurstmall.jpg[/img]
[/center]
	
WurstScript is a Scripting language, which can, similar to vJass, cJass and zinc, be translated to Jass.


[h2]Why a new Scripting language? [/h2]
[indent]

The only alternative to Wurst is vJass (or cJass, zinc, ..., which are basically all the same). 

If you are interested in what we did not like about vJass click the button:
[hidden="vJass critique"]

[h3]1. Editor Support[/h3]

vJass is mostly based on text-replacements and generation (vJass modules, textmacros). This makes it hard to create a good editor for vJass, including features like autocomplete.

Wurst instead goes for simple, structured code, that can be analyzed in a single compiler-phase. vJass however needs [url=http://www.wc3c.net/vexorian/zincmanual.html#compileerror]more phases[/url].

// TODO move this

The editor support for wurst is done as an eclipse plugin. This results in a [I]awesome[/I] full-fledged IDE including:
[LIST]
[*]Syntax highlighting
[*]Autocomplete for Natives and Custom Code
[*]Hot-Doc Documentation
[*]Outline View
[*]REPL console
[*]Automatic Reconciling
[*]All basic features of eclipse like Project-Tree-View, Tabbed-File-View, find&replace with regular expressions, hotkeys & shortcuts, etc. 
[/LIST]

[URL=http://i.imgur.com/6uOtqxr.png][IMG]http://i.imgur.com/6uOtqxrl.png[/IMG][/URL]
[SIZE="1"][I](Click to enlarge)[/I][/SIZE]

[h3]2. Type-safety[/h3]

vJass isn't typesafe. Look at this example:

*vJass Code*

	[JASS]struct A
	endstruct

	struct B
	endstruct

	private function init takes nothing returns nothing
		local A a = A.create()
		local B b = A.create() // no error ...
		set a = 42 // no error ...
		set a = "bla" // pjass error
	endfunction[/JASS]

vJass doesn't check if a variable of type B only stores values of type B. This leads to frequent errors, which can be discovered late or you receive a pJass Error, which isn't easy to understand.

The Wurst counterpart (Screenshot from the Eclipse Plugin):

[IMG]http://peq.github.io/WurstScript/assets/images/error_sample1.png[/IMG]

[h3]3. Verbose syntax[/h3]

vJass features several redundant Syntax-Elements. For example "set", "call" or "takes nothing returns nothing". Additionally vJass doesn't have many features that allow for writing readable, clear code. Particularly there only exists one type of loop.

WurstScript features less verbosity, but without losing similarity to (v)Jass so switching is easier, and rapid code production for faster map creation.
[/hidden]

[/indent]
[h2]Syntax[/h2]
[indent]


So how does it look like? Here is a simple spell to give you a first idea:

// TODO add code

As you can see, Wurst has an indentation based syntax, and therefore you do not have to write  words like [i]endif[/i] or [i]endfunction[/i]. The example also shows some of the syntactic sugar in Wurst, for example the for-in loop in line 13. // TODO line number

[/indent]
[h2]Features[/h2]
[indent]
The full list of features is documented in the [url=http://peq.github.io/WurstScript/manual.html]Wurst Manual[/url]. Here we present only some selected features.



[h3]Local Type Inference + Local Variable Freedom[/h3]

The type of local variables can automatically be derived from the initial value. Furthermore variables can be declared at any position in a function, not just the beginning.

[JASS]	
	// "let" defines a local constant
	let harald = CreateUnit(Player(0), 'hfoo', x, y, 0)
	// "var" defines a local variable
	var otto = CreateUnit(Player(0), 'hfoo', x, y, 0)
	// traditional way works too
	unit heinz = CreateUnit(Player(0), 'hfoo', x, y, 0)
[/JASS]

We encourage you to use [b]let[/b] whenever possible, because code is easier read when you know which variables are changed later and which variables keep their initial value.

[h3]Extension functions[/h3]

Extension functions allow to add specific functions to an already existing type, which can be used via dot-syntax.

Declaration: 
[JASS]
	public function unit.getOwner() returns player
		return GetOwningPlayer(this)
		
	function player.getName() returns string
		return GetPlayerName(this)
[/JASS]

Usage:
	
[JASS]	
	print(GetKillingUnit().getOwner().getName() + " killed " +
		GetTriggerUnit().getOwner().getName() + "!")
[/JASS]


Extension functions have two pros in comparison to normal functions:
[list]
[*]Functions are easier to find using auto-complete in Eclipse
[*]In many cases the readability is improved as this way 
[JASS]
	// nested function calls:
	name = GetPlayerName(GetOwningPlayer(u))
	// chained function calls
	name = u.getOwner().getName()
[/JASS]
[/list]

        
[h3]Tuples[/h3]
		
A Tuple is a very simple Datatype. It allows to group several values into one. This allows treating the group of values as a group. Other than classes, tuples don't create any overhead. They don't have to be created or destroyed and can be used for primitive data types (int, string, etc.). A good example are vectors(from the stdlib):

Definition:

[JASS]
	// A 2d vector with the components x and y
	public tuple vec2( real x, real y )
	
	// Operator overloading functions:
	public function vec2.op_plus( vec2 v )	returns vec2
		return vec2(this.x + v.x, this.y + v.y)
	
	public function vec2.op_minus( vec2 v )	returns vec2
		return vec2(this.x - v.x, this.y - v.y)
		
	public function vec2.op_mult(real factor) returns vec2
		return vec2(this.x*factor, this.y*factor) 
	
	// dot product:
	public function vec2.dot( vec2 v ) returns real
		return this.x*v.x+this.y*v.y
	
	// length:
	public function vec2.length() returns real
		return SquareRoot(this.x*this.x+this.y*this.y)
	
	// normalized Vector:
	public function vec2.norm() returns vec2
        real len = this.length()
        real x = 0 
        real y = 0
        if (len != 0.0)
            x = (this.x / len)
            y = (this.y / len)
        return vec2(x,y)
	
	public function vec2.polarOffset(real angle, real dist) returns vec2
		return vec2(this.x + Cos(angle)*dist, this.y + Sin(angle)*dist)
[/JASS]

Usage:

[JASS]
	// A projectile homes the target unit(variable following)
	function followHero()
		// Increase angle
		angle += TURN_SPEED*DT
		// calculate new position
		let newPos = following.getPos().polarOffset(angle, RANGE)
		// current velocity is calculated from the difference between old and new position
		vel = (newPos - pos)*(1/DT)
		pos = newPos
		fx.setPos(pos.x, pos.y)
		SetUnitFacing(fx, (angle + bj_PI/2)*bj_RADTODEG)
		checkCollisions()
		
	// projectile moving forward
	function moveForward()
		// Add velocity to position
		pos = pos + vel*DT
		if not pos.inBounds()
			destroyed = true
		else
			fx.setPos(pos.x, pos.y)
			checkCollisions()
[/JASS]

[h3]Anonymous functions / closures[/h3]

With anonymous you can define a new function where it is needed. This is useful for timers, as shown in the following example, where the timer t is started with an anonymous function:

[JASS]
class Fireball
	timer t
	//...
	
	construct(unit caster, vec2 target)
		// ...
		t = getTimer()
		t.setData(this castTo int)
		t.start(0.05, () -> begin
			let fireball = GetExpiredTimer().getData() castTo Fireball
			fireball.move()
		end) 
	
	function move()
		// do stuff
[/JASS]

Closures are more than just anonymous functions. They also capture variables. This allows to write some very concise code. For example it is easily  possible to destroy an Fx after some time:

[jass]
	let fx = new Fx(pos, facing, model)
	fx.setScale(2.0)
	// destroy fx after 2 seconds:
	doAfter(2.0, () -> destroy fx)
[/jass]

Here the closure captured the local variable [i]fx[/i] without the need to get a timer, attach stuff to the timer, and all that boilerplate code. The doAfter function is defined in the standard library and it can not only destroy Fx objects. You can write any code inside the closure and it will run after the given time.

[h3]Compiletime functions[/h3]

You can execute Wurst code at compile-time. Wurst includes some pseudo-natives which can be executed at compile-time to generate object-editor entries. This is similar to what can be done with the ObjectMerger tool, but it also comes with nice readable method names. Here is an example which creates a spell based on Channel and a tower unit for each level:

[jass]
@compiletime function generateSpell()
	// based on shadow hunter serpent wards
	int levelCount = 4
	let def = new ChannelSpellPreset(GUN_TURRET_SPELL_ID, levelCount)
		..setName("Gun Turret")
		..setIcon("ReplaceableTextures\\CommandButtons\\BTNElvenGuardTower.blp")
		..setIconNormal("ReplaceableTextures\\CommandButtons\\BTNElvenGuardTower.blp")
		..setTargetType(Targettype.PTARGET)
		..setOption(Option.VISIBLE, true)
		..setFollowThroughTime(0.4)
		..setDisablesOther(false)
	for lvl = 1 to levelCount
		createTower(lvl)
		def.setCastingTime(lvl,0)
		def.setCastRange(lvl, 300)

function createTower(int lvl)
	// based on high elven guard tower:
	let def = new BuildingDefinition(GUN_TURRET_TOWER_ID + lvl, 'negt')
		..setName("Gun Turret Level " + lvl.toString())
		..setHitPointsMaximumBase(100 + lvl*100)
	// no projectile
	def.setAttack1ProjectileArt("")
	// 0 damage
	def..setAttack1DamageBase(-1)
		..setAttack1DamageNumberofDice(1)
		..setAttack1DamageSidesperDie(1)
		..setAttack1CooldownTime(attackCooldown(lvl))
		..setAttack1Range(attackRange)
		..setScalingValue(0.8)
		..setGroundTexture("")
[/jass]

It is even possible to share code between compile-time functions and normal in-game functions. For example the constant GUN_TURRET_SPELL_ID or the function attackCooldown can be used to configure the generated objects and they can be used in the code for the spell.

[/indent]
[h2]Eclipse Plugin[/h2]
[indent]

[h3]Run your map from eclipse[/h3]

You can compile all scripts and run your map directly from eclipse. This can be much faster than saving the map in WorldEditor first, because only the script is updated and eclipse already has the script in memory.

[h3]Live errors and warnings[/h3]

[img]https://dl.dropboxusercontent.com/u/32231212/wurstpresentation/errors.png[/img]

Errors and warnings are directly shown in your code without the need for pressing compile or saving the whole map.



[h3]Context-sensitive auto-complete[/h3]

[img]https://dl.dropboxusercontent.com/u/32231212/wurstpresentation/autocomplete.png[/img]

If you have an expression with a dot, then auto-complete will show you all members available for the given type. This is especially useful when used with extension methods, because it is very easy to find the function you are looking for.

[h3]Hotdoc[/h3]

As already seen in the auto-complete screenshot, Wurst has support for documenting functions with so called Hotdoc comments. These comments are shown in auto-complete and when you hover your mouse above a function call.

[h3]Jump to declaration[/h3]

Hold down the [b]Ctrl[/b] key and click on a variable or function and you will directly jump to the place where it is declared.

[h3]Console and REPL[/h3]

[img]https://dl.dropboxusercontent.com/u/32231212/wurstpresentation/console.png[/img]

You can use the console to evaluate expressions and test your code in eclipse, without even starting WarCraft. Of course this is limited, as not all natives are implemented in the Interpreter, but it is nice for testing data-structures or mathematical calculations.


[h3]Other benefits of using eclipse[/h3]

Many features are already available in Eclipse and not specific to the Wurst-Plugin:
[list]
[*]Press Ctrl+Shift+R to quickly jump to a file. It even supports using wildcards for searching files.
[*]Powerful search (and replace) in all files.
[*]Integration with version control (Git & co).
[*]...
[/list]

[/indent]
[h2]Manual[/h2]
[indent]
You can read about all features in the [url=http://peq.github.io/WurstScript/manual.html]Wurst Manual[/url].
[/indent]
[h2]Installation / Download[/h2]
[indent]
Please find the [url=http://peq.github.io/WurstScript/installation.html]installation instructions on GitHub[/url].

Other links:
[list]
[*][url=http://peq.github.io/WurstScript/]WurstScript Home Page[/url]
[*][url=https://github.com/peq/WurstScript]WurstScript Github Repository[/url]
[/list]

[h3]Youtube Tutorials:[/h3]

[table]
   Download, Installation & Setup                [c]Eclipse & WorldEditor workflow
[r][YOUTUBE]http://youtu.be/JYhUkRsQe-o[/YOUTUBE][c][YOUTUBE]http://youtu.be/dRhw17Hxhv0[/YOUTUBE]
[/table]

[/indent]
[h2]Projects using Wurst[/h2]

[list]	
[*][url]http://www.hiveworkshop.com/forums/project-recruitment-256/heart-blackest-night-recruits-225237/[/url]
[*][url]http://www.hiveworkshop.com/forums/maps-564/escape-builder-r-0-82z-184964/[/url]
[/list]


[h2]FAQ (Frequently asked questions):[/h2]
[indent]

[h3]Can I use vJass together with Wurst?[/h3]
Yes, you can use both. However it is not possible to call Wurst-functions from vJass and calling vJass from Wurst is not very convenient.


[h3] I have further problems, suggestions or questions. Where can I get help? [/h3]
[list]
[*]In this thread.
[*]Create a [url=https://github.com/peq/WurstScript/issues?state=open]ticket on github[/url].
[*]Private message to [url=http://www.hiveworkshop.com/forums/members/peq/]peq[/url] or [url=http://www.hiveworkshop.com/forums/members/Frotty/]Frotty[/url]
[*][url=http://webchat.quakenet.org/?channels=inwc.de-maps]quakenet IRC #inwc.de-maps[/url] (German chat where you can usually find us)
[/list]

[/indent]

