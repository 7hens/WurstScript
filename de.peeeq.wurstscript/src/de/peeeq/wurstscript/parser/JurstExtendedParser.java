package de.peeeq.wurstscript.parser;

import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import java_cup.runtime.Symbol;

import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;

import de.peeeq.wurstscript.attributes.CompileError;
import de.peeeq.wurstscript.attributes.ErrorHandler;
import de.peeeq.wurstscript.utils.NotNullList;
import de.peeeq.wurstscript.utils.Utils;

/**
 * This parser extends the parser class generated by java-cup and adds some
 * stuff like error handling
 * 
 */
public class JurstExtendedParser extends JurstParser {

	private List<CompileError> errors = new NotNullList<CompileError>();
	private ErrorHandler errorHandler;

	public void setFilename(String filename) {
		this.filename = filename;
	}

	public JurstExtendedParser(JurstScanner scanner, ErrorHandler eh) {
		super(scanner);
		this.scanner = scanner;
		this.errorHandler = eh;
	}

	@Override
	protected void init_actions() {
		super.init_actions();
		action_obj.errorHandler = errorHandler;
	}
	
	public int getErrorCount() {
		return errors.size();
	}

	public static String translateSym(int index) {
		return translateSymbolName(translateSymRaw(index));
	}
	
	private static String translateSymRaw(int index) {
		switch (index) {
		case JurstTokenType.MINUS_MINUS: return "MINUS_MINUS";
		  case JurstTokenType.ENDGLOBALS: return "ENDGLOBALS";
		  case JurstTokenType.IDENTIFIER: return "IDENTIFIER";
		  case JurstTokenType.FROM: return "FROM";
		  case JurstTokenType.GT: return "GT";
		  case JurstTokenType.ARROW: return "ARROW";
		  case JurstTokenType.ENDPACKAGE: return "ENDPACKAGE";
		  case JurstTokenType.TYPE: return "TYPE";
		  case JurstTokenType.IMPLEMENTS: return "IMPLEMENTS";
		  case JurstTokenType.PLUS_EQ: return "PLUS_EQ";
		  case JurstTokenType.NOTEQ: return "NOTEQ";
		  case JurstTokenType.DIV_INT: return "DIV_INT";
		  case JurstTokenType.NOTHING: return "NOTHING";
		  case JurstTokenType.LOWEST: return "LOWEST";
		  case JurstTokenType.ENDFUNCTION: return "ENDFUNCTION";
		  case JurstTokenType.ENUM: return "ENUM";
		  case JurstTokenType.CUSTOM_ERROR: return "CUSTOM_ERROR";
		  case JurstTokenType.INDENT: return "INDENT";
		  case JurstTokenType.RBRACK: return "RBRACK";
		  case JurstTokenType.INIT: return "INIT";
		  case JurstTokenType.COMMA: return "COMMA";
		  case JurstTokenType.TUPLE: return "TUPLE";
		  case JurstTokenType.PUBLICREAD: return "PUBLICREAD";
		  case JurstTokenType.GLOBALS: return "GLOBALS";
		  case JurstTokenType.LBRACK: return "LBRACK";
		  case JurstTokenType.LT: return "LT";
		  case JurstTokenType.THISTYPE: return "THISTYPE";
		  case JurstTokenType.LOOP: return "LOOP";
		  case JurstTokenType.DIV_REAL: return "DIV_REAL";
		  case JurstTokenType.PROTECTED: return "PROTECTED";
		  case JurstTokenType.DESTROY: return "DESTROY";
		  case JurstTokenType.INTEGER_LITERAL: return "INTEGER_LITERAL";
		  case JurstTokenType.FALSE: return "FALSE";
		  case JurstTokenType.NOT: return "NOT";
		  case JurstTokenType.ELSEIF: return "ELSEIF";
		  case JurstTokenType.ARRAY: return "ARRAY";
		  case JurstTokenType.INSTANCE: return "INSTANCE";
		  case JurstTokenType.VAR: return "VAR";
		  case JurstTokenType.OVERRIDE: return "OVERRIDE";
		  case JurstTokenType.THEN: return "THEN";
		  case JurstTokenType.ENDLOOP: return "ENDLOOP";
		  case JurstTokenType.PLUS_PLUS: return "PLUS_PLUS";
		  case JurstTokenType.PACKAGE: return "PACKAGE";
		  case JurstTokenType.EQ: return "EQ";
		  case JurstTokenType.NATIVETYPE: return "NATIVETYPE";
		  case JurstTokenType.CLASS: return "CLASS";
		  case JurstTokenType.SUPER: return "SUPER";
		  case JurstTokenType.ABSTRACT: return "ABSTRACT";
		  case JurstTokenType.EXITWHEN: return "EXITWHEN";
		  case JurstTokenType.TRUE: return "TRUE";
		  case JurstTokenType.NATIVE: return "NATIVE";
		  case JurstTokenType.PLUS: return "PLUS";
		  case JurstTokenType.WHILE: return "WHILE";
		  case JurstTokenType.LPAR: return "LPAR";
		  case JurstTokenType.USE: return "USE";
		  case JurstTokenType.EXTENDS: return "EXTENDS";
		  case JurstTokenType.MODULE: return "MODULE";
		  case JurstTokenType.INTERFACE: return "INTERFACE";
		  case JurstTokenType.REAL_LITERAL: return "REAL_LITERAL";
		  case JurstTokenType.RSQUARE: return "RSQUARE";
		  case JurstTokenType.WURSTDOC: return "WURSTDOC";
		  case JurstTokenType.SWITCH: return "SWITCH";
		  case JurstTokenType.MOD_REAL: return "MOD_REAL";
		  case JurstTokenType.SKIP: return "SKIP";
		  case JurstTokenType.FOR: return "FOR";
		  case JurstTokenType.DIV_EQ: return "DIV_EQ";
		  case JurstTokenType.RETURN: return "RETURN";
		  case JurstTokenType.PUBLIC: return "PUBLIC";
		  case JurstTokenType.DOWNTO: return "DOWNTO";
		  case JurstTokenType.MULT: return "MULT";
		  case JurstTokenType.ELSE: return "ELSE";
		  case JurstTokenType.CONSTRUCT: return "CONSTRUCT";
		  case JurstTokenType.BREAK: return "BREAK";
		  case JurstTokenType.GTEQ: return "GTEQ";
		  case JurstTokenType.DOT: return "DOT";
		  case JurstTokenType.STRING_LITERAL: return "STRING_LITERAL";
		  case JurstTokenType.NULL: return "NULL";
		  case JurstTokenType.EQEQ: return "EQEQ";
		  case JurstTokenType.EOF: return "EOF";
		  case JurstTokenType.SEMICOLON: return "SEMICOLON";
		  case JurstTokenType.LSQUARE: return "LSQUARE";
		  case JurstTokenType.THIS: return "THIS";
		  case JurstTokenType.RPAR: return "RPAR";
		  case JurstTokenType.INFIX_CALL: return "INFIX_CALL";
		  case JurstTokenType.DEFAULT: return "DEFAULT";
		  case JurstTokenType.MINUS_EQ: return "MINUS_EQ";
		  case JurstTokenType.FUNCTION: return "FUNCTION";
		  case JurstTokenType.ENDIF: return "ENDIF";
		  case JurstTokenType.LOCAL: return "LOCAL";
		  case JurstTokenType.IMPORT: return "IMPORT";
		  case JurstTokenType.IDENTIFIER_LT: return "IDENTIFIER_LT";
		  case JurstTokenType.IT: return "IT";
		  case JurstTokenType.MINUS: return "MINUS";
		  case JurstTokenType.CONSTANT: return "CONSTANT";
		  case JurstTokenType.IMMUTABLE: return "IMMUTABLE";
		  case JurstTokenType.LTEQ: return "LTEQ";
		  case JurstTokenType.IN: return "IN";
		  case JurstTokenType.OR: return "OR";
		  case JurstTokenType.SET: return "SET";
		  case JurstTokenType.error: return "error";
		  case JurstTokenType.CASTTO: return "CASTTO";
		  case JurstTokenType.ANNOTATION: return "ANNOTATION";
		  case JurstTokenType.IF: return "IF";
		  case JurstTokenType.INSTANCEOF: return "INSTANCEOF";
		  case JurstTokenType.ONDESTROY: return "ONDESTROY";
		  case JurstTokenType.COLON: return "COLON";
		  case JurstTokenType.MULT_EQ: return "MULT_EQ";
		  case JurstTokenType.TAKES: return "TAKES";
		  case JurstTokenType.CASE: return "CASE";
		  case JurstTokenType.NEW: return "NEW";
		  case JurstTokenType.RETURNS: return "RETURNS";
		  case JurstTokenType.STEP: return "STEP";
		  case JurstTokenType.MOD_INT: return "MOD_INT";
		  case JurstTokenType.UNINDENT: return "UNINDENT";
		  case JurstTokenType.NL: return "NL";
		  case JurstTokenType.AND: return "AND";
		  case JurstTokenType.PRIVATE: return "PRIVATE";
		  case JurstTokenType.TO: return "TO";
		  case JurstTokenType.STATIC: return "STATIC";
		  case JurstTokenType.UMINUS: return "UMINUS";
		  case JurstTokenType.LET: return "LET";
		  case JurstTokenType.CALL: return "CALL";
		  case JurstTokenType.END: return "END";
		  case JurstTokenType.BEGIN: return "BEGIN";
		  case JurstTokenType.DOTDOT: return "DOTDOT";
		}
		return "Symbol#" + index;
	}

	private static String translateSymbolName(String name) {
		Map<String, String> translations = Maps.newLinkedHashMap();
		translations.put("IDENTIFIER", "name");
		translations.put("IDENTIFIER_LT", "name with type args");
		translations.put("ARROW", "'->'");
		translations.put("GT", "'>'");
		translations.put("NOTEQ", "'!='");
		translations.put("DIV_INT", "'div'");
		translations.put("RBRACK", "'}'");
		translations.put("COMMA", "','");
		translations.put("SEMICOLON", "';'");
		translations.put("LBRACK", "'{'");
		translations.put("LT", "'<'");
		translations.put("DIV_REAL", "'/'");
		translations.put("INTEGER_LITERAL", "integer number");
		translations.put("EQ", "'='");
		translations.put("PLUS", "'+'");
		translations.put("LPAR", "'('");
		translations.put("REAL_LITERAL", "real number");
		translations.put("RSQUARE", "']'");
		translations.put("MOD_REAL", "'%'");
		translations.put("MULT", "'*'");
		translations.put("GTEQ", "'>='");
		translations.put("DOT", "'.'");
		translations.put("STRING_LITERAL", "string");
		translations.put("EQEQ", "'=='");
		translations.put("EOF", "end of file");
		translations.put("LSQUARE", "'['");
		translations.put("RPAR", "')'");
		translations.put("MINUS", "'-'");
		translations.put("LTEQ", "'<='");
		translations.put("CASTTO", "'cast_to'");
		translations.put("MOD_INT", "'mod'");
		translations.put("NL", "newline");
		translations.put("UMINUS", "'-'");
		translations.put("INDENT", "increase of indentation");
		translations.put("UNINDENT", "decrease of indentation");
		translations.put("PLUS_EQ", "'+='");
		translations.put("DIV_EQ", "'/='");
		translations.put("MULT_EQ", "'*='");
		translations.put("MINUS_EQ", "'-='");
		if (translations.containsKey(name)) {
			return translations.get(name);
		} else {
			// just assume this is a keyword 
			return "'" + name.toLowerCase() + "'";
		}
	}

	public static String symbolToString(Symbol s) {
		if (s == null) {
			return "!!nullSymbol!!";
		}
		return translateSym(s.sym) + (s.value != null ? " " + s.value : "");
	}

	/**
	 * 
	 */
	@Override
	public void syntax_error(Symbol s) {
		boolean showExpected = true;
		String msg;
		if (s.sym == TokenType.error) {
			String sym = s.value.toString();
			if (sym.equals("\n")) {
				sym = "newline";
			} else if (sym.equals("\r")) {
				sym = "newline";
			} else if (sym.length() == 1){
				sym = "<" + sym + ">";
			}
			if (sym.equals("unterminated String")) {
				msg = "Unterminated String.";
			} else {
				msg = "Lexical error: unexpected symbol " + sym + " ";
			}
			showExpected = false;
		} else if (s.sym == TokenType.CUSTOM_ERROR) {
			msg = s.value.toString();
			showExpected = false;
		} else if (s.sym == TokenType.LBRACK) {
			msg = "Unexpected '{', type parameters are now written with <> as in Java.";
			showExpected = false;
		} else {
			msg = "Grammatical error: unexpected " + symbolToString(s);
		}
		if (showExpected) {
			// get current parse state:
			int parseState = ((Symbol) stack.peek()).parse_state;

			msg += " expected: ";
			// get possible actions from action table and print them
			short[] possibleActions = this.action_table()[parseState];
			List<String> expectedSymbols = Lists.newArrayList();
			for (int j = 0; j < possibleActions.length; j += 2) {
				if (possibleActions[j] >= 0) {
					expectedSymbols.add(translateSym(possibleActions[j]));
				}
			}
			groupEntries(expectedSymbols);		
			msg += Utils.join(expectedSymbols, ", ");  
			//msg += "\nstate = " + parseState;
		}

		WPos source = new WPos(filename, scanner.lineStartOffsets, s.left, s.right);
		CompileError err = new CompileError(source, msg);
		errors.add(err);
		errorHandler.sendError(err);
		// throw err;
	}

	private void groupEntries(List<String> expectedSymbols) {
		Map<String, Set<String>> groups = Maps.newLinkedHashMap();
		groups.put("operator", Sets.newHashSet(
				"'=='", "'>='", "'<='", "'!='", "'>'", "'<'", "'and'", "'or'", "'+'", "'-'", "'*'", 
				"'/'", "'div'", "'%'", "'mod'", "'.'", "'cast_to'"));
		groups.put("expression", Sets.newHashSet(
				translateSym(TokenType.IDENTIFIER), 
				translateSym(TokenType.INTEGER_LITERAL),
				translateSym(TokenType.REAL_LITERAL),
				translateSym(TokenType.STRING_LITERAL),
				translateSym(TokenType.TRUE),
				translateSym(TokenType.FALSE),
				translateSym(TokenType.NOT),
				translateSym(TokenType.MINUS),
				translateSym(TokenType.LPAR),
				translateSym(TokenType.FUNCTION),
				translateSym(TokenType.NEW),
				translateSym(TokenType.NULL),
				translateSym(TokenType.THIS)
				));

		Set<String> matchingGroups = Sets.newLinkedHashSet();
		for (Entry<String, Set<String>> e : groups.entrySet()) {
			String groupName = e.getKey();
			Set<String> group = e.getValue();
			if (expectedSymbols.containsAll(group)) {
				matchingGroups.add(groupName);
			}
		}

		for (String groupName : matchingGroups) {
			expectedSymbols.removeAll(groups.get(groupName));
			expectedSymbols.add(0, groupName);
		}

	}

	@Override
	public void unrecovered_syntax_error(Symbol s) {
		WPos source = new WPos(filename, scanner.lineStartOffsets, s.left, s.right);
		throw new CompileError(source, "Could not continue to parse file ...");
	}

}
