
 //######################################################
 // File C:\Users\Frotty\Documents\GitHub\WurstScript\Wurstpack\.\temp\war3map.j
 //######################################################
//===========================================================================
// 
// InWarcraft Schneeballschlacht 1.03
// 
//   Warcraft III map script
//   Generated by the Warcraft III World Editor
//   Date: Sat Jan 05 15:30:41 2013
//   Map Author: InWarcraft
// 
//===========================================================================

//***************************************************************************
//*
//*  Global Variables
//*
//***************************************************************************

globals
    // Generated
    string                  gg_snd_JingleBellsChristmasIn8Bit_101
    sound                   gg_snd_QuestFailed         = null
    sound                   gg_snd_CreepAggroWhat1     = null
    sound                   gg_snd_FrostArrowHit1      = null
    sound                   gg_snd_bells               = null
    trigger                 gg_trg_Untitled_Trigger_004 = null
    trigger                 gg_trg_Untitled_Trigger_005 = null
    trigger                 gg_trg_Untitled_Trigger_002 = null
    trigger                 gg_trg_Untitled_Trigger_001 = null
    trigger                 gg_trg_Untitled_Trigger_003 = null
endglobals

function InitGlobals takes nothing returns nothing
endfunction

//***************************************************************************
//*
//*  Sounds
//*
//***************************************************************************

function InitSounds takes nothing returns nothing
    set gg_snd_JingleBellsChristmasIn8Bit_101 = "war3mapImported\\JingleBellsChristmasIn8Bit_1.mp3"
    set gg_snd_QuestFailed = CreateSound( "Sound\\Interface\\QuestFailed.wav", false, false, false, 10, 10, "" )
    call SetSoundParamsFromLabel( gg_snd_QuestFailed, "QuestFailed" )
    call SetSoundDuration( gg_snd_QuestFailed, 4690 )
    set gg_snd_CreepAggroWhat1 = CreateSound( "Sound\\Interface\\CreepAggroWhat1.wav", false, false, false, 10, 10, "" )
    call SetSoundParamsFromLabel( gg_snd_CreepAggroWhat1, "CreepAggro" )
    call SetSoundDuration( gg_snd_CreepAggroWhat1, 1236 )
    set gg_snd_FrostArrowHit1 = CreateSound( "Abilities\\Spells\\Other\\FrostArrows\\FrostArrowHit1.wav", false, true, true, 10, 10, "MissilesEAX" )
    call SetSoundParamsFromLabel( gg_snd_FrostArrowHit1, "FrostArrowHit" )
    call SetSoundDuration( gg_snd_FrostArrowHit1, 1115 )
    set gg_snd_bells = CreateSound( "war3mapImported\\bells.mp3", false, false, false, 10, 10, "" )
    call SetSoundDuration( gg_snd_bells, 2072 )
    call SetSoundChannel( gg_snd_bells, 0 )
    call SetSoundVolume( gg_snd_bells, 127 )
    call SetSoundPitch( gg_snd_bells, 1.0 )
endfunction

//***************************************************************************
//*
//*  Unit Creation
//*
//***************************************************************************

//===========================================================================
function CreateBuildingsForPlayer0 takes nothing returns nothing
    local player p = Player(0)
    local unit u
    local integer unitID
    local trigger t
    local real life

    set u = CreateUnit( p, 'n000', -2624.0, 4096.0, 270.000 )
    call SetUnitColor( u, ConvertPlayerColor(0) )
endfunction

//===========================================================================
function CreateUnitsForPlayer0 takes nothing returns nothing
    local player p = Player(0)
    local unit u
    local integer unitID
    local trigger t
    local real life

    set u = CreateUnit( p, 'hgry', 884.0, 4150.2, 158.318 )
    set u = CreateUnit( p, 'umtw', 750.9, 4656.8, 142.091 )
    set u = CreateUnit( p, 'umtw', 704.8, 4569.0, 347.299 )
    set u = CreateUnit( p, 'umtw', 665.9, 4479.3, 69.908 )
    set u = CreateUnit( p, 'umtw', 597.6, 4403.2, 336.565 )
endfunction

//===========================================================================
function CreateBuildingsForPlayer6 takes nothing returns nothing
    local player p = Player(6)
    local unit u
    local integer unitID
    local trigger t
    local real life

    set u = CreateUnit( p, 'n002', 2816.0, 4096.0, 270.000 )
    call SetUnitColor( u, ConvertPlayerColor(6) )
endfunction

//===========================================================================
function CreateNeutralPassive takes nothing returns nothing
    local player p = Player(PLAYER_NEUTRAL_PASSIVE)
    local unit u
    local integer unitID
    local trigger t
    local real life

    set u = CreateUnit( p, 'e002', -1.7, 6696.4, 263.710 )
    call SetUnitColor( u, ConvertPlayerColor(0) )
    set u = CreateUnit( p, 'e002', -245.9, 1221.8, 82.130 )
    call SetUnitColor( u, ConvertPlayerColor(0) )
    set u = CreateUnit( p, 'n003', 4876.1, -69.4, 261.760 )
    set u = CreateUnit( p, 'n004', 3959.9, 6244.1, 32.707 )
    set u = CreateUnit( p, 'n004', 3544.8, 6584.6, 305.506 )
    set u = CreateUnit( p, 'nsno', 2400.0, 1712.8, 6.229 )
    set u = CreateUnit( p, 'nsno', 1454.1, 4638.5, 53.417 )
    set u = CreateUnit( p, 'nsno', -294.3, 2017.6, 301.968 )
    set u = CreateUnit( p, 'nsno', -698.6, 8183.7, 31.620 )
    set u = CreateUnit( p, 'nsno', -1601.0, 6168.1, 184.631 )
endfunction

//===========================================================================
function CreatePlayerBuildings takes nothing returns nothing
    call CreateBuildingsForPlayer0(  )
    call CreateBuildingsForPlayer6(  )
endfunction

//===========================================================================
function CreatePlayerUnits takes nothing returns nothing
    call CreateUnitsForPlayer0(  )
endfunction

//===========================================================================
function CreateAllUnits takes nothing returns nothing
    call CreatePlayerBuildings(  )
    call CreateNeutralPassive(  )
    call CreatePlayerUnits(  )
endfunction

//***************************************************************************
//*
//*  Triggers
//*
//***************************************************************************

//===========================================================================
// Trigger: Untitled Trigger 004
//===========================================================================
function Trig_Untitled_Trigger_004_Func001A takes nothing returns nothing
    call AdjustPlayerStateBJ( 5, GetEnumPlayer(), PLAYER_STATE_RESOURCE_GOLD )
endfunction

function Trig_Untitled_Trigger_004_Actions takes nothing returns nothing
    call ForForce( GetPlayersAll(), function Trig_Untitled_Trigger_004_Func001A )
endfunction

//===========================================================================
function InitTrig_Untitled_Trigger_004 takes nothing returns nothing
    set gg_trg_Untitled_Trigger_004 = CreateTrigger(  )
    call TriggerRegisterTimerEventPeriodic( gg_trg_Untitled_Trigger_004, 15.00 )
    call TriggerAddAction( gg_trg_Untitled_Trigger_004, function Trig_Untitled_Trigger_004_Actions )
endfunction

//===========================================================================
// Trigger: Untitled Trigger 005
//===========================================================================
function Trig_Untitled_Trigger_005_Actions takes nothing returns nothing
    call CreateQuestBJ( bj_QUESTTYPE_REQ_DISCOVERED, "TRIGSTR_189", "TRIGSTR_190", "ReplaceableTextures\\CommandButtons\\BTNSelectHeroOff.blp" )
    call QuestSetDiscoveredBJ( GetLastCreatedQuestBJ(), true )
endfunction

//===========================================================================
function InitTrig_Untitled_Trigger_005 takes nothing returns nothing
    set gg_trg_Untitled_Trigger_005 = CreateTrigger(  )
    call TriggerAddAction( gg_trg_Untitled_Trigger_005, function Trig_Untitled_Trigger_005_Actions )
endfunction

//===========================================================================
// Trigger: Untitled Trigger 002
//===========================================================================
function Trig_Untitled_Trigger_002_Func001A takes nothing returns nothing
    call CreateFogModifierRectBJ( true, GetEnumPlayer(), FOG_OF_WAR_VISIBLE, GetPlayableMapRect() )
endfunction

function Trig_Untitled_Trigger_002_Actions takes nothing returns nothing
    call ForForce( GetPlayersAll(), function Trig_Untitled_Trigger_002_Func001A )
endfunction

//===========================================================================
function InitTrig_Untitled_Trigger_002 takes nothing returns nothing
    set gg_trg_Untitled_Trigger_002 = CreateTrigger(  )
    call TriggerAddAction( gg_trg_Untitled_Trigger_002, function Trig_Untitled_Trigger_002_Actions )
endfunction

//===========================================================================
// Trigger: Untitled Trigger 001
//===========================================================================
function Trig_Untitled_Trigger_001_Actions takes nothing returns nothing
    call StopMusicBJ( true )
    call ClearMapMusicBJ(  )
    call TriggerSleepAction( 0.10 )
    call PlayMusicBJ( gg_snd_JingleBellsChristmasIn8Bit_101 )
endfunction

//===========================================================================
function InitTrig_Untitled_Trigger_001 takes nothing returns nothing
    set gg_trg_Untitled_Trigger_001 = CreateTrigger(  )
    call TriggerRegisterTimerEventSingle( gg_trg_Untitled_Trigger_001, 0.01 )
    call TriggerRegisterTimerEventPeriodic( gg_trg_Untitled_Trigger_001, 68.00 )
    call TriggerAddAction( gg_trg_Untitled_Trigger_001, function Trig_Untitled_Trigger_001_Actions )
endfunction

//===========================================================================
// Trigger: Untitled Trigger 003
//===========================================================================
function Trig_Untitled_Trigger_003_Actions takes nothing returns nothing
    call DisplayTextToForce( bj_FORCE_PLAYER[0], "TRIGSTR_186" )
endfunction

//===========================================================================
function InitTrig_Untitled_Trigger_003 takes nothing returns nothing
    set gg_trg_Untitled_Trigger_003 = CreateTrigger(  )
    call TriggerAddAction( gg_trg_Untitled_Trigger_003, function Trig_Untitled_Trigger_003_Actions )
endfunction

//===========================================================================
function InitCustomTriggers takes nothing returns nothing
    call InitTrig_Untitled_Trigger_004(  )
    call InitTrig_Untitled_Trigger_005(  )
    call InitTrig_Untitled_Trigger_002(  )
    call InitTrig_Untitled_Trigger_001(  )
    call InitTrig_Untitled_Trigger_003(  )
endfunction

//===========================================================================
function RunInitializationTriggers takes nothing returns nothing
    call ConditionalTriggerExecute( gg_trg_Untitled_Trigger_005 )
    call ConditionalTriggerExecute( gg_trg_Untitled_Trigger_002 )
endfunction

//***************************************************************************
//*
//*  Players
//*
//***************************************************************************

function InitCustomPlayerSlots takes nothing returns nothing

    // Player 0
    call SetPlayerStartLocation( Player(0), 0 )
    call ForcePlayerStartLocation( Player(0), 0 )
    call SetPlayerColor( Player(0), ConvertPlayerColor(0) )
    call SetPlayerRacePreference( Player(0), RACE_PREF_HUMAN )
    call SetPlayerRaceSelectable( Player(0), false )
    call SetPlayerController( Player(0), MAP_CONTROL_USER )

    // Player 1
    call SetPlayerStartLocation( Player(1), 1 )
    call ForcePlayerStartLocation( Player(1), 1 )
    call SetPlayerColor( Player(1), ConvertPlayerColor(1) )
    call SetPlayerRacePreference( Player(1), RACE_PREF_HUMAN )
    call SetPlayerRaceSelectable( Player(1), false )
    call SetPlayerController( Player(1), MAP_CONTROL_USER )

    // Player 2
    call SetPlayerStartLocation( Player(2), 2 )
    call ForcePlayerStartLocation( Player(2), 2 )
    call SetPlayerColor( Player(2), ConvertPlayerColor(2) )
    call SetPlayerRacePreference( Player(2), RACE_PREF_HUMAN )
    call SetPlayerRaceSelectable( Player(2), false )
    call SetPlayerController( Player(2), MAP_CONTROL_USER )

    // Player 3
    call SetPlayerStartLocation( Player(3), 3 )
    call ForcePlayerStartLocation( Player(3), 3 )
    call SetPlayerColor( Player(3), ConvertPlayerColor(3) )
    call SetPlayerRacePreference( Player(3), RACE_PREF_HUMAN )
    call SetPlayerRaceSelectable( Player(3), false )
    call SetPlayerController( Player(3), MAP_CONTROL_USER )

    // Player 4
    call SetPlayerStartLocation( Player(4), 4 )
    call ForcePlayerStartLocation( Player(4), 4 )
    call SetPlayerColor( Player(4), ConvertPlayerColor(4) )
    call SetPlayerRacePreference( Player(4), RACE_PREF_HUMAN )
    call SetPlayerRaceSelectable( Player(4), false )
    call SetPlayerController( Player(4), MAP_CONTROL_USER )

    // Player 5
    call SetPlayerStartLocation( Player(5), 5 )
    call ForcePlayerStartLocation( Player(5), 5 )
    call SetPlayerColor( Player(5), ConvertPlayerColor(5) )
    call SetPlayerRacePreference( Player(5), RACE_PREF_HUMAN )
    call SetPlayerRaceSelectable( Player(5), false )
    call SetPlayerController( Player(5), MAP_CONTROL_USER )

    // Player 6
    call SetPlayerStartLocation( Player(6), 6 )
    call ForcePlayerStartLocation( Player(6), 6 )
    call SetPlayerColor( Player(6), ConvertPlayerColor(6) )
    call SetPlayerRacePreference( Player(6), RACE_PREF_ORC )
    call SetPlayerRaceSelectable( Player(6), false )
    call SetPlayerController( Player(6), MAP_CONTROL_USER )

    // Player 7
    call SetPlayerStartLocation( Player(7), 7 )
    call ForcePlayerStartLocation( Player(7), 7 )
    call SetPlayerColor( Player(7), ConvertPlayerColor(7) )
    call SetPlayerRacePreference( Player(7), RACE_PREF_ORC )
    call SetPlayerRaceSelectable( Player(7), false )
    call SetPlayerController( Player(7), MAP_CONTROL_USER )

    // Player 8
    call SetPlayerStartLocation( Player(8), 8 )
    call ForcePlayerStartLocation( Player(8), 8 )
    call SetPlayerColor( Player(8), ConvertPlayerColor(8) )
    call SetPlayerRacePreference( Player(8), RACE_PREF_ORC )
    call SetPlayerRaceSelectable( Player(8), false )
    call SetPlayerController( Player(8), MAP_CONTROL_USER )

    // Player 9
    call SetPlayerStartLocation( Player(9), 9 )
    call ForcePlayerStartLocation( Player(9), 9 )
    call SetPlayerColor( Player(9), ConvertPlayerColor(9) )
    call SetPlayerRacePreference( Player(9), RACE_PREF_ORC )
    call SetPlayerRaceSelectable( Player(9), false )
    call SetPlayerController( Player(9), MAP_CONTROL_USER )

    // Player 10
    call SetPlayerStartLocation( Player(10), 10 )
    call ForcePlayerStartLocation( Player(10), 10 )
    call SetPlayerColor( Player(10), ConvertPlayerColor(10) )
    call SetPlayerRacePreference( Player(10), RACE_PREF_ORC )
    call SetPlayerRaceSelectable( Player(10), false )
    call SetPlayerController( Player(10), MAP_CONTROL_USER )

    // Player 11
    call SetPlayerStartLocation( Player(11), 11 )
    call ForcePlayerStartLocation( Player(11), 11 )
    call SetPlayerColor( Player(11), ConvertPlayerColor(11) )
    call SetPlayerRacePreference( Player(11), RACE_PREF_ORC )
    call SetPlayerRaceSelectable( Player(11), false )
    call SetPlayerController( Player(11), MAP_CONTROL_USER )

endfunction

function InitCustomTeams takes nothing returns nothing
    // Force: TRIGSTR_180
    call SetPlayerTeam( Player(0), 0 )
    call SetPlayerState( Player(0), PLAYER_STATE_ALLIED_VICTORY, 1 )
    call SetPlayerTeam( Player(1), 0 )
    call SetPlayerState( Player(1), PLAYER_STATE_ALLIED_VICTORY, 1 )
    call SetPlayerTeam( Player(2), 0 )
    call SetPlayerState( Player(2), PLAYER_STATE_ALLIED_VICTORY, 1 )
    call SetPlayerTeam( Player(3), 0 )
    call SetPlayerState( Player(3), PLAYER_STATE_ALLIED_VICTORY, 1 )
    call SetPlayerTeam( Player(4), 0 )
    call SetPlayerState( Player(4), PLAYER_STATE_ALLIED_VICTORY, 1 )
    call SetPlayerTeam( Player(5), 0 )
    call SetPlayerState( Player(5), PLAYER_STATE_ALLIED_VICTORY, 1 )

    //   Allied
    call SetPlayerAllianceStateAllyBJ( Player(0), Player(1), true )
    call SetPlayerAllianceStateAllyBJ( Player(0), Player(2), true )
    call SetPlayerAllianceStateAllyBJ( Player(0), Player(3), true )
    call SetPlayerAllianceStateAllyBJ( Player(0), Player(4), true )
    call SetPlayerAllianceStateAllyBJ( Player(0), Player(5), true )
    call SetPlayerAllianceStateAllyBJ( Player(1), Player(0), true )
    call SetPlayerAllianceStateAllyBJ( Player(1), Player(2), true )
    call SetPlayerAllianceStateAllyBJ( Player(1), Player(3), true )
    call SetPlayerAllianceStateAllyBJ( Player(1), Player(4), true )
    call SetPlayerAllianceStateAllyBJ( Player(1), Player(5), true )
    call SetPlayerAllianceStateAllyBJ( Player(2), Player(0), true )
    call SetPlayerAllianceStateAllyBJ( Player(2), Player(1), true )
    call SetPlayerAllianceStateAllyBJ( Player(2), Player(3), true )
    call SetPlayerAllianceStateAllyBJ( Player(2), Player(4), true )
    call SetPlayerAllianceStateAllyBJ( Player(2), Player(5), true )
    call SetPlayerAllianceStateAllyBJ( Player(3), Player(0), true )
    call SetPlayerAllianceStateAllyBJ( Player(3), Player(1), true )
    call SetPlayerAllianceStateAllyBJ( Player(3), Player(2), true )
    call SetPlayerAllianceStateAllyBJ( Player(3), Player(4), true )
    call SetPlayerAllianceStateAllyBJ( Player(3), Player(5), true )
    call SetPlayerAllianceStateAllyBJ( Player(4), Player(0), true )
    call SetPlayerAllianceStateAllyBJ( Player(4), Player(1), true )
    call SetPlayerAllianceStateAllyBJ( Player(4), Player(2), true )
    call SetPlayerAllianceStateAllyBJ( Player(4), Player(3), true )
    call SetPlayerAllianceStateAllyBJ( Player(4), Player(5), true )
    call SetPlayerAllianceStateAllyBJ( Player(5), Player(0), true )
    call SetPlayerAllianceStateAllyBJ( Player(5), Player(1), true )
    call SetPlayerAllianceStateAllyBJ( Player(5), Player(2), true )
    call SetPlayerAllianceStateAllyBJ( Player(5), Player(3), true )
    call SetPlayerAllianceStateAllyBJ( Player(5), Player(4), true )

    //   Shared Vision
    call SetPlayerAllianceStateVisionBJ( Player(0), Player(1), true )
    call SetPlayerAllianceStateVisionBJ( Player(0), Player(2), true )
    call SetPlayerAllianceStateVisionBJ( Player(0), Player(3), true )
    call SetPlayerAllianceStateVisionBJ( Player(0), Player(4), true )
    call SetPlayerAllianceStateVisionBJ( Player(0), Player(5), true )
    call SetPlayerAllianceStateVisionBJ( Player(1), Player(0), true )
    call SetPlayerAllianceStateVisionBJ( Player(1), Player(2), true )
    call SetPlayerAllianceStateVisionBJ( Player(1), Player(3), true )
    call SetPlayerAllianceStateVisionBJ( Player(1), Player(4), true )
    call SetPlayerAllianceStateVisionBJ( Player(1), Player(5), true )
    call SetPlayerAllianceStateVisionBJ( Player(2), Player(0), true )
    call SetPlayerAllianceStateVisionBJ( Player(2), Player(1), true )
    call SetPlayerAllianceStateVisionBJ( Player(2), Player(3), true )
    call SetPlayerAllianceStateVisionBJ( Player(2), Player(4), true )
    call SetPlayerAllianceStateVisionBJ( Player(2), Player(5), true )
    call SetPlayerAllianceStateVisionBJ( Player(3), Player(0), true )
    call SetPlayerAllianceStateVisionBJ( Player(3), Player(1), true )
    call SetPlayerAllianceStateVisionBJ( Player(3), Player(2), true )
    call SetPlayerAllianceStateVisionBJ( Player(3), Player(4), true )
    call SetPlayerAllianceStateVisionBJ( Player(3), Player(5), true )
    call SetPlayerAllianceStateVisionBJ( Player(4), Player(0), true )
    call SetPlayerAllianceStateVisionBJ( Player(4), Player(1), true )
    call SetPlayerAllianceStateVisionBJ( Player(4), Player(2), true )
    call SetPlayerAllianceStateVisionBJ( Player(4), Player(3), true )
    call SetPlayerAllianceStateVisionBJ( Player(4), Player(5), true )
    call SetPlayerAllianceStateVisionBJ( Player(5), Player(0), true )
    call SetPlayerAllianceStateVisionBJ( Player(5), Player(1), true )
    call SetPlayerAllianceStateVisionBJ( Player(5), Player(2), true )
    call SetPlayerAllianceStateVisionBJ( Player(5), Player(3), true )
    call SetPlayerAllianceStateVisionBJ( Player(5), Player(4), true )

    // Force: TRIGSTR_181
    call SetPlayerTeam( Player(6), 1 )
    call SetPlayerState( Player(6), PLAYER_STATE_ALLIED_VICTORY, 1 )
    call SetPlayerTeam( Player(7), 1 )
    call SetPlayerState( Player(7), PLAYER_STATE_ALLIED_VICTORY, 1 )
    call SetPlayerTeam( Player(8), 1 )
    call SetPlayerState( Player(8), PLAYER_STATE_ALLIED_VICTORY, 1 )
    call SetPlayerTeam( Player(9), 1 )
    call SetPlayerState( Player(9), PLAYER_STATE_ALLIED_VICTORY, 1 )
    call SetPlayerTeam( Player(10), 1 )
    call SetPlayerState( Player(10), PLAYER_STATE_ALLIED_VICTORY, 1 )
    call SetPlayerTeam( Player(11), 1 )
    call SetPlayerState( Player(11), PLAYER_STATE_ALLIED_VICTORY, 1 )

    //   Allied
    call SetPlayerAllianceStateAllyBJ( Player(6), Player(7), true )
    call SetPlayerAllianceStateAllyBJ( Player(6), Player(8), true )
    call SetPlayerAllianceStateAllyBJ( Player(6), Player(9), true )
    call SetPlayerAllianceStateAllyBJ( Player(6), Player(10), true )
    call SetPlayerAllianceStateAllyBJ( Player(6), Player(11), true )
    call SetPlayerAllianceStateAllyBJ( Player(7), Player(6), true )
    call SetPlayerAllianceStateAllyBJ( Player(7), Player(8), true )
    call SetPlayerAllianceStateAllyBJ( Player(7), Player(9), true )
    call SetPlayerAllianceStateAllyBJ( Player(7), Player(10), true )
    call SetPlayerAllianceStateAllyBJ( Player(7), Player(11), true )
    call SetPlayerAllianceStateAllyBJ( Player(8), Player(6), true )
    call SetPlayerAllianceStateAllyBJ( Player(8), Player(7), true )
    call SetPlayerAllianceStateAllyBJ( Player(8), Player(9), true )
    call SetPlayerAllianceStateAllyBJ( Player(8), Player(10), true )
    call SetPlayerAllianceStateAllyBJ( Player(8), Player(11), true )
    call SetPlayerAllianceStateAllyBJ( Player(9), Player(6), true )
    call SetPlayerAllianceStateAllyBJ( Player(9), Player(7), true )
    call SetPlayerAllianceStateAllyBJ( Player(9), Player(8), true )
    call SetPlayerAllianceStateAllyBJ( Player(9), Player(10), true )
    call SetPlayerAllianceStateAllyBJ( Player(9), Player(11), true )
    call SetPlayerAllianceStateAllyBJ( Player(10), Player(6), true )
    call SetPlayerAllianceStateAllyBJ( Player(10), Player(7), true )
    call SetPlayerAllianceStateAllyBJ( Player(10), Player(8), true )
    call SetPlayerAllianceStateAllyBJ( Player(10), Player(9), true )
    call SetPlayerAllianceStateAllyBJ( Player(10), Player(11), true )
    call SetPlayerAllianceStateAllyBJ( Player(11), Player(6), true )
    call SetPlayerAllianceStateAllyBJ( Player(11), Player(7), true )
    call SetPlayerAllianceStateAllyBJ( Player(11), Player(8), true )
    call SetPlayerAllianceStateAllyBJ( Player(11), Player(9), true )
    call SetPlayerAllianceStateAllyBJ( Player(11), Player(10), true )

    //   Shared Vision
    call SetPlayerAllianceStateVisionBJ( Player(6), Player(7), true )
    call SetPlayerAllianceStateVisionBJ( Player(6), Player(8), true )
    call SetPlayerAllianceStateVisionBJ( Player(6), Player(9), true )
    call SetPlayerAllianceStateVisionBJ( Player(6), Player(10), true )
    call SetPlayerAllianceStateVisionBJ( Player(6), Player(11), true )
    call SetPlayerAllianceStateVisionBJ( Player(7), Player(6), true )
    call SetPlayerAllianceStateVisionBJ( Player(7), Player(8), true )
    call SetPlayerAllianceStateVisionBJ( Player(7), Player(9), true )
    call SetPlayerAllianceStateVisionBJ( Player(7), Player(10), true )
    call SetPlayerAllianceStateVisionBJ( Player(7), Player(11), true )
    call SetPlayerAllianceStateVisionBJ( Player(8), Player(6), true )
    call SetPlayerAllianceStateVisionBJ( Player(8), Player(7), true )
    call SetPlayerAllianceStateVisionBJ( Player(8), Player(9), true )
    call SetPlayerAllianceStateVisionBJ( Player(8), Player(10), true )
    call SetPlayerAllianceStateVisionBJ( Player(8), Player(11), true )
    call SetPlayerAllianceStateVisionBJ( Player(9), Player(6), true )
    call SetPlayerAllianceStateVisionBJ( Player(9), Player(7), true )
    call SetPlayerAllianceStateVisionBJ( Player(9), Player(8), true )
    call SetPlayerAllianceStateVisionBJ( Player(9), Player(10), true )
    call SetPlayerAllianceStateVisionBJ( Player(9), Player(11), true )
    call SetPlayerAllianceStateVisionBJ( Player(10), Player(6), true )
    call SetPlayerAllianceStateVisionBJ( Player(10), Player(7), true )
    call SetPlayerAllianceStateVisionBJ( Player(10), Player(8), true )
    call SetPlayerAllianceStateVisionBJ( Player(10), Player(9), true )
    call SetPlayerAllianceStateVisionBJ( Player(10), Player(11), true )
    call SetPlayerAllianceStateVisionBJ( Player(11), Player(6), true )
    call SetPlayerAllianceStateVisionBJ( Player(11), Player(7), true )
    call SetPlayerAllianceStateVisionBJ( Player(11), Player(8), true )
    call SetPlayerAllianceStateVisionBJ( Player(11), Player(9), true )
    call SetPlayerAllianceStateVisionBJ( Player(11), Player(10), true )

endfunction

function InitAllyPriorities takes nothing returns nothing

    call SetStartLocPrioCount( 0, 5 )
    call SetStartLocPrio( 0, 0, 1, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 0, 1, 2, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 0, 2, 3, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 0, 3, 4, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 0, 4, 5, MAP_LOC_PRIO_HIGH )

    call SetStartLocPrioCount( 1, 5 )
    call SetStartLocPrio( 1, 0, 0, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 1, 1, 2, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 1, 2, 3, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 1, 3, 4, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 1, 4, 5, MAP_LOC_PRIO_HIGH )

    call SetStartLocPrioCount( 2, 5 )
    call SetStartLocPrio( 2, 0, 0, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 2, 1, 1, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 2, 2, 3, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 2, 3, 4, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 2, 4, 5, MAP_LOC_PRIO_HIGH )

    call SetStartLocPrioCount( 3, 5 )
    call SetStartLocPrio( 3, 0, 0, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 3, 1, 1, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 3, 2, 2, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 3, 3, 4, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 3, 4, 5, MAP_LOC_PRIO_HIGH )

    call SetStartLocPrioCount( 4, 5 )
    call SetStartLocPrio( 4, 0, 0, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 4, 1, 1, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 4, 2, 2, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 4, 3, 3, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 4, 4, 5, MAP_LOC_PRIO_HIGH )

    call SetStartLocPrioCount( 5, 5 )
    call SetStartLocPrio( 5, 0, 0, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 5, 1, 1, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 5, 2, 2, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 5, 3, 3, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 5, 4, 4, MAP_LOC_PRIO_HIGH )

    call SetStartLocPrioCount( 6, 5 )
    call SetStartLocPrio( 6, 0, 7, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 6, 1, 8, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 6, 2, 9, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 6, 3, 10, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 6, 4, 11, MAP_LOC_PRIO_HIGH )

    call SetStartLocPrioCount( 7, 5 )
    call SetStartLocPrio( 7, 0, 6, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 7, 1, 8, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 7, 2, 9, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 7, 3, 10, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 7, 4, 11, MAP_LOC_PRIO_HIGH )

    call SetStartLocPrioCount( 8, 5 )
    call SetStartLocPrio( 8, 0, 6, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 8, 1, 7, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 8, 2, 9, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 8, 3, 10, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 8, 4, 11, MAP_LOC_PRIO_HIGH )

    call SetStartLocPrioCount( 9, 5 )
    call SetStartLocPrio( 9, 0, 6, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 9, 1, 7, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 9, 2, 8, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 9, 3, 10, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 9, 4, 11, MAP_LOC_PRIO_HIGH )

    call SetStartLocPrioCount( 10, 5 )
    call SetStartLocPrio( 10, 0, 6, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 10, 1, 7, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 10, 2, 8, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 10, 3, 9, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 10, 4, 11, MAP_LOC_PRIO_HIGH )

    call SetStartLocPrioCount( 11, 5 )
    call SetStartLocPrio( 11, 0, 6, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 11, 1, 7, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 11, 2, 8, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 11, 3, 9, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 11, 4, 10, MAP_LOC_PRIO_HIGH )
endfunction

//***************************************************************************
//*
//*  Main Initialization
//*
//***************************************************************************

//===========================================================================
function main takes nothing returns nothing
    local weathereffect we
    call SetCameraBounds( -5376.0 + GetCameraMargin(CAMERA_MARGIN_LEFT), -1536.0 + GetCameraMargin(CAMERA_MARGIN_BOTTOM), 5376.0 - GetCameraMargin(CAMERA_MARGIN_RIGHT), 9216.0 - GetCameraMargin(CAMERA_MARGIN_TOP), -5376.0 + GetCameraMargin(CAMERA_MARGIN_LEFT), 9216.0 - GetCameraMargin(CAMERA_MARGIN_TOP), 5376.0 - GetCameraMargin(CAMERA_MARGIN_RIGHT), -1536.0 + GetCameraMargin(CAMERA_MARGIN_BOTTOM) )
    call SetDayNightModels( "Environment\\DNC\\DNCLordaeron\\DNCLordaeronTerrain\\DNCLordaeronTerrain.mdl", "Environment\\DNC\\DNCLordaeron\\DNCLordaeronUnit\\DNCLordaeronUnit.mdl" )
    call SetTerrainFogEx( 0, 1500.0, 5000.0, 0.500, 0.502, 0.502, 0.502 )
    set we = AddWeatherEffect( Rect(-6144.0,-2048.0,6144.0,10240.0), 'SNls' )
    call EnableWeatherEffect( we, true )
    call NewSoundEnvironment( "Default" )
    call SetAmbientDaySound( "NorthrendDay" )
    call SetAmbientNightSound( "NorthrendNight" )
    call SetMapMusic( "Music", true, 0 )
    call InitSounds(  )
    call CreateAllUnits(  )
    call InitBlizzard(  )
    call InitGlobals(  )
    call InitCustomTriggers(  )
    call RunInitializationTriggers(  )

endfunction

//***************************************************************************
//*
//*  Map Configuration
//*
//***************************************************************************

function config takes nothing returns nothing
    call SetMapName( "TRIGSTR_007" )
    call SetMapDescription( "TRIGSTR_009" )
    call SetPlayers( 12 )
    call SetTeams( 12 )
    call SetGamePlacement( MAP_PLACEMENT_TEAMS_TOGETHER )

    call DefineStartLocation( 0, -2240.0, 4096.0 )
    call DefineStartLocation( 1, -2240.0, 4096.0 )
    call DefineStartLocation( 2, -2240.0, 4096.0 )
    call DefineStartLocation( 3, -2240.0, 4096.0 )
    call DefineStartLocation( 4, -2240.0, 4096.0 )
    call DefineStartLocation( 5, -2240.0, 4096.0 )
    call DefineStartLocation( 6, 2304.0, 4096.0 )
    call DefineStartLocation( 7, 2304.0, 4096.0 )
    call DefineStartLocation( 8, 2304.0, 4096.0 )
    call DefineStartLocation( 9, 2304.0, 4096.0 )
    call DefineStartLocation( 10, 2304.0, 4096.0 )
    call DefineStartLocation( 11, 2304.0, 4096.0 )

    // Player setup
    call InitCustomPlayerSlots(  )
    call InitCustomTeams(  )
    call InitAllyPriorities(  )
endfunction

 //######################################################
 // File C:\Users\Frotty\Documents\GitHub\InWcSchneeball\wurst\debug\Debug.wurst
 //######################################################
package Debug
	
	public int entityCount 			= 0
	public int unitEntityCount 		= 0
	
	
endpackage
 //######################################################
 // File C:\Users\Frotty\Documents\GitHub\InWcSchneeball\wurst\entity\Entity.wurst
 //######################################################
package Entity
	import LinkedListModule
	import Terrain
	import PhysicsConstants
	import Debug
	
	// Base Entity Class
	public abstract class Entity
		use LinkedListModule
		
		real radius
		// 3d vector position
		vec3 pos
		// 3d vector velocity
		vec3 vel
		
		// owning player
		player owner
		
		// flag for being static
		boolean isStatic 	= false
		// sleeping or active?
		boolean active 		= true
		// for removing
		boolean done 		= false
	
		construct( vec3 pos, player owner, real radius )
			this.pos = pos
			this.vel = vec3(0,0,0)
			this.owner = owner
			this.radius = radius
			entityCount++
			debugPrint("EntityCount: " + entityCount.toString(), 1)
			debugPrint("UnitEntityCount: " + unitEntityCount.toString(), 1)
			
		construct( vec3 pos, vec3 vel, player owner )
			this.pos = pos
			this.vel = vel
			this.owner = owner
			
		function setPos( vec3 pos )
			this.pos = pos
			
		function setVel( vec3 vel )
			this.vel = vel
		
		function addVel( vec3 vel )
			this.vel += vel
			
		function setTarget( vec3 tpos, real speed )
			var t = distanceBetweenCoords(pos.x, pos.y, tpos.x, tpos.y) / speed
			let angl = anglBetweenCoordsR(pos.x, pos.y, tpos.x, tpos.y)
			let e = getTerrainZ(tpos.x,tpos.y)
			
			if t < 1.
				t = 1./speed
			
			let startZVelocity = ((-gravity.z * t) / 2 - pos.z/t + e/t)
			this.setVel( vec3( Cos(angl) * speed, Sin(angl) * speed, startZVelocity) )
			
		function terminate()
			done = true
			
		// This function is called every ANIMATION_PERIOD tick if the Entity is active
		abstract function update()
		
	abstract public class UnitEntity extends Entity
		unit actor
		
		construct( vec3 pos, unit actor, real radius )
			super(pos, actor.getOwner(), radius)
			this.actor = actor
			actor.setUserData(this castTo int).addAbility(HEIGHT_ENABLER).removeAbility(HEIGHT_ENABLER)
			unitEntityCount++
			
		override function update()
			pos = vec3(actor.getX(), actor.getY(), 0.)
			
		function setNewActor(unit u)
			actor.remove()
			actor = u
			actor.setUserData(this castTo int)
			
		function setNewPos(vec3 tpos)
			pos = tpos
			actor.setPos(tpos.x,tpos.y)
			
		function setNewXY(vec3 tpos)
			pos = tpos
			actor.setXY(tpos.x,tpos.y)
	
	
	
	
	//######################################################
	// File C:\Users\Frotty\Documents\GitHub\InWcSchneeball\wurst\entity\EntityManagement.wurst
	//######################################################
endpackage
package EntityManagement
	import public Entity
	
	function updateEntities()
		Entity e = Entity.first
		while e != null
			if e.done
				destroy e
				debugPrint("destroyed Entity", 0)
			else 
				e.update()
			e = e.next
	
	public function startEntityLoop() returns boolean
		getTimer().startPeriodic(0.03, function updateEntities)
		return true
endpackage 
 //######################################################
 // File C:\Users\Frotty\Documents\GitHub\InWcSchneeball\wurst\entity\PhysicsConstants.wurst
 //######################################################
package PhysicsConstants

	public vec3 gravity = vec3(0,0,-0.8)
endpackage
 //######################################################
 // File C:\Users\Frotty\Documents\GitHub\InWcSchneeball\wurst\entity\PhysicsEntity.wurst
 //######################################################
package PhysicsEntity
	import Entity
	import Terrain
	import PhysicsConstants
	import Debug
	
	// Base Entity Class
	public abstract class PhysicsEntity extends Entity
		// Affected by gravity
		boolean affectedByGravity = true
		
		real terrainZ = 0.
		
		// Physical factors
		
		// The higher the more slide. Should be < 1.
		real friction = 0.9
		// Defines the bounciness
		real restitution = 0.6
		// Speedfactor
		real speedFactor = 1.
		
		boolean enableTrimming
		
		boolean flying = false
		
	
		construct( vec3 pos, player owner, real radius )
			super(pos,owner, radius)
			
		construct( vec3 pos, vec3 vel, player owner )
			super(pos,vel,owner)
			
			
		// This function is called every ANIMATION_PERIOD tick if the Entity is active
		override function update()
			terrainZ = getTerrainZ(pos.x, pos.y)
			if pos.z <= terrainZ + .6
				onGround()
			else
				inAir()
			
			if enableTrimming
				vel.trim(.5)
			pos += (vel * speedFactor)
			
		// When the Entity is on or near the ground	
		function onGround()
			// If the Entity is moving towards 
			vec3 normal = getTerrainNormal(pos.x, pos.y, 8.)
			// Is the Entity going away from the ground?
			if vel.dot(normal) > 0 
				return
	
			vec3 pv = vel.project(normal)
			pv *= (-1. - restitution)
			if pv.lengthSquared() > friction
				vel += pv
			else	
				vel *= friction
				
			pos.z = terrainZ
			
		function inAir()
			if affectedByGravity
				vel += gravity
				
	abstract public class PhysicsUnitEntity extends PhysicsEntity
		unit actor
		
		construct( vec3 pos, unit actor, real radius )
			super(pos, actor.getOwner(), radius)
			this.actor = actor
			actor.setUserData(this castTo int).addAbility(HEIGHT_ENABLER).removeAbility(HEIGHT_ENABLER)
			unitEntityCount++
			
		function setNewActor(unit u)
			actor.remove()
			actor = u
			actor.setUserData(this castTo int)
			
		function setNewPos(vec3 tpos)
			pos = tpos
			actor.setPos(tpos.x,tpos.y)
			
		override function onGround()
			super.onGround()
			if flying
				flying = false
				SetUnitPropWindow(actor, 60.)
			
		override function inAir()
			super.inAir()
			if not flying
				flying = true
				if vel.lengthSquared() > 4.
					SetUnitPropWindow(actor, 0.)
endpackage
 //######################################################
 // File C:\Users\Frotty\Documents\GitHub\InWcSchneeball\wurst\gameplay\ChatCommand.wurst
 //######################################################
package ChatCommand
import Gamemode
	
function displayScore()
	DisplayTimedTextToForce(bj_FORCE_PLAYER[GetPlayerId(GetTriggerPlayer())], 12., "|cffff6347Rotes Team: |r" + redscore.toString() + "\n\n|cff3cb371Gruenes Team: |r" + greenscore.toString())


init
	trigger t = CreateTrigger()
	for int i = 0 to 11
		TriggerRegisterPlayerChatEvent(t,Player(i),"-score",true)
	t.addAction(function displayScore)

endpackage 
 //######################################################
 // File C:\Users\Frotty\Documents\GitHub\InWcSchneeball\wurst\gameplay\Flag.wurst
 //######################################################
package Flag
import Entity
import PlayerData
import GameConstants

public Flag redflag
public Flag greenflag

enum State
	CARRIED
	DROPPED
	INBASE

public class Flag extends Entity
	State state
	unit actor
	unit carrier
	boolean redTeam
	vec2 base
	
	trigger inRangeTrig
	
	construct ( vec3 pos, unit actor )
		super(pos, actor.getOwner(), 32.)
		this.actor = actor
		state = State.INBASE
		base = vec2(pos.x, pos.y)
		actor.setUserData(this castTo int).addAbility(HEIGHT_ENABLER).removeAbility(HEIGHT_ENABLER)
		
		inRangeTrig = CreateTrigger()
		inRangeTrig.registerUnitInRangeSource( actor, 100. )
		inRangeTrig.addAction(function Flag.onInRange )
		
	override function update()
		if state == State.CARRIED
			pos.x = carrier.getX()
			pos.y = carrier.getY()
			actor.setXY(pos.x,pos.y)
		else
			pos.x = actor.getX()
			pos.y = actor.getY()
		super.update()
		
	function setCarrier(unit u, boolean display)
		carrier = u
		var p = u.getOwner()
		state = State.CARRIED
		debugPrint("carried", 1)
		string message = colorcode[p.getId()] + p.getName() + "|r stole your team's flag!"
		if display
		//Display to opponent team players
			if carrier.getOwner().getId() > 5
				if GetLocalPlayer().getId() <= 5
					StartSound( gg_snd_CreepAggroWhat1 )
					DisplayTextToPlayer(GetLocalPlayer(), 0, 0, message)
					PingMinimap(pos.x, pos.y, 5)
			else
				if GetLocalPlayer().getId() > 5
					StartSound( gg_snd_CreepAggroWhat1 )
					DisplayTextToPlayer(GetLocalPlayer(), 0, 0, message)
	
	function returnFlag()
		debugPrint("returning", 1)
		actor.setXY(base.x,base.y)
		state = State.INBASE
		if actor.getOwner().getId() > 5
			if GetLocalPlayer().getId() <= 5
				StartSound( gg_snd_CreepAggroWhat1 )
		else
			if GetLocalPlayer().getId() > 5
				StartSound( gg_snd_CreepAggroWhat1 )
	
	function drop()
		debugPrint("dropped", 1)
		carrier = null
		state = State.DROPPED
			
	static function onInRange()
		debugPrint("inrange", 1)
		unit u = GetTriggerUnit()
		player p = u.getOwner()
		var flag = GetTriggeringTrigger().getSource().getUserData() castTo Flag
		if flag.state == State.INBASE
			if (not flag.redTeam and p.getId()  < 5)
				flag.setCarrier(u, true)
			else if (flag.redTeam and p.getId()  > 5)
				flag.setCarrier(u, true)
		if flag.state == State.DROPPED
			if p.getId() <5
				if flag.redTeam
					flag.returnFlag()
				else
					flag.setCarrier(u, false)
			else 
				if not flag.redTeam
					flag.returnFlag()
				else
					flag.setCarrier(u, false)
					
function checkCarrierDeath()
	unit u = GetTriggerUnit()
	if (u == redflag.carrier or u == greenflag.carrier)
		debugPrint("a carrier died", 1)
		redflag.drop()

init
	trigger t = CreateTrigger()
	t.registerAnyUnitEvent(EVENT_PLAYER_UNIT_DEATH)
	t.addAction(function checkCarrierDeath) 
endpackage	
	//######################################################
 // File C:\Users\Frotty\Documents\GitHub\InWcSchneeball\wurst\gameplay\Gamemode.wurst
 //######################################################
package Gamemode
import PlayerData
import GameConstants
public int maxkills = 10
dialog gamemode
button array modebutton
public int redscore = 0
public int greenscore = 0
boolean gameover = false

public function checkEnd()
	if not gameover
		if redscore >= maxkills
			endgame(0)
		if greenscore >= maxkills
			endgame(1)
	

public function createDialog()
	gamemode = DialogCreate()
	DialogSetMessage(gamemode, "Spielmodus")
	modebutton[0] = DialogAddButton(gamemode, "Kurz (30 Punkte)", 111)
	modebutton[1] = DialogAddButton(gamemode, "Normal (50 Punkte)", 113)
	modebutton[2] = DialogAddButton(gamemode, "Lang (80 Punkte)", 112)
	DialogDisplay(players.get(0).p, gamemode,true)
	trigger t = CreateTrigger()
	TriggerRegisterDialogEvent(t, gamemode)
	TriggerAddAction(t,function getGameMode)

function getGameMode()
	button b = GetClickedButton()
	if b == modebutton[0]
		maxkills = 40
		DisplayTimedTextToForce(GetPlayersAll(), 12.,"|cffFFAD29» " + colorcode[GetTriggerPlayer().getId()] + GetTriggerPlayer().getName() + "|r hat ein kurzes Spiel ausgewählt!")
	if b == modebutton[1]
		maxkills = 60
		DisplayTimedTextToForce(GetPlayersAll(), 12.,"|cffFFAD29» " + colorcode[GetTriggerPlayer().getId()] + GetTriggerPlayer().getName() + "|r hat ein normales Spiel ausgewählt!")
	if b == modebutton[2]
		maxkills = 80
		DisplayTimedTextToForce(GetPlayersAll(), 12.,"|cffFFAD29» " + colorcode[GetTriggerPlayer().getId()] + GetTriggerPlayer().getName() + "|r hat ein langes Spiel ausgewählt!")
		
	playerboard.show() 

function endgame(int winningteam)
	announcers[5].play()
	if winningteam == 1
		DisplayTimedTextToForce(GetPlayersAll(), 12., "Das grüne team hat gewonnen!")
	else if winningteam == 0
		DisplayTimedTextToForce(GetPlayersAll(), 12., "Das rote Team hat gewonnen!")
	gameover = true
	PauseGame(true)
endpackage	
	//######################################################	
 //######################################################
 // File C:\Users\Frotty\Documents\GitHub\InWcSchneeball\wurst\gameplay\KillStreaks.wurst
 //######################################################
package KillStreaks
import PlayerData
import GameConstants
import Gamemode

public function adjustKills(player killer, player dead)
	var p1 = pData[killer.getId()]
	var p2 = pData[dead.getId()]
	p1.kills ++
	p2.deaths ++
	playerboard.updateValue(p1.gameId+1,1,p1.kills.toString())
	playerboard.updateValue(p2.gameId+1,2,p2.deaths.toString())
	SetPlayerState(killer, PLAYER_STATE_RESOURCE_GOLD, GetPlayerState(killer, PLAYER_STATE_RESOURCE_GOLD)+10)
	p1.killstreak ++
	p2.killstreak = 0				
	if p1.id <= 5
		redscore += 1
	else
		greenscore += 1
	string announce = " -"
	debugPrint("kills: "+p1.killstreak.toString(), 1)
	if p1.killstreak == 3
		announcers[2].play()
		announce += " |cff860B00KillingSpree|r"
	if p1.killstreak == 4
		announcers[3].play()
		announce += " |cff0058A6Unstoppable!|r"
	if p1.killstreak == 6
		announcers[4].play()
		announce += " |cffFFDA84Godlike!!!|r"
	timer t = getTimer()
	if p1.intriple
		announcers[1].play()
		announce += " |cff2DCB2DTriplekill|r"
		p1.indouble = false
		t.setData(killer.getId()).start(0.,function clearKillMultiplier)
	else if p1.indouble
		announcers[0].play()
		announce += " |cff2DCB2DDoublekill|r"
		p1.intriple = true
		t.setData(killer.getId()).start(15,function clearKillMultiplier)
	else
		t.setData(killer.getId()).start(20,function clearKillMultiplier)
		p1.indouble = true
	if announce != " -"
		DisplayTimedTextToForce(GetPlayersAll(), 12., colorcode[killer.getId()] + killer.getName() + "|r hat " + colorcode[dead.getId()] + dead.getName() + "|r mit seinem Schneeball ins Gesicht getroffen!" + announce + "\n(1 Punkt)")
	else
		DisplayTimedTextToForce(GetPlayersAll(), 12., colorcode[killer.getId()] + killer.getName() + "|r hat " + colorcode[dead.getId()] + dead.getName() + "|r mit seinem Schneeball ins Gesicht getroffen!" + "\n(1 Punkt)")
	checkEnd()
	
	
function clearKillMultiplier()
	var p = pData[GetExpiredTimer().getData()]
	if p.indouble
		p.indouble = false
	else
		p.intriple = false 
		
endpackage	
	//######################################################//######################################################
 // File C:\Users\Frotty\Documents\GitHub\InWcSchneeball\wurst\gameplay\Presents.wurst
 //######################################################
package Presents
import Fx
import Entity
import TimerUtils
import ItemObject
import SoundHelper

constant int ITEM_ID = 'I002'

Sound presentSpawn = new Sound("war3mapImported\\bells.mp3", 2072, false )
		
constant real CT_X = 0.
constant real CT_Y = 4096.
public function spawnPresent()
	var dist = GetRandomReal(400,800)
	var angl = GetRandomReal(-PI,PI)
	new ItemObject( CreateItem(ITEM_ID,polarProjectionXR(CT_X,dist,angl),polarProjectionYR(CT_Y,dist,angl)))
	//var p = new Present(vec3(,0))
	DisplayTimedTextToForce(GetPlayersAll(), 12., "|cffFFAD29» |cffFF7329In der Mitte ist ein Geschenk erschienen!")
	
function isPresent() returns boolean
	if GetItemTypeId(GetFilterItem()) == ITEM_ID
		return true
	return false
int presents

function addOne()
	presents++
	
public function onPresentTime()
	debugPrint("PresentTime",1)
	presents = 0
	rect r = Rect(-6000,-19000,6000,10000)
	EnumItemsInRect(r,Condition(function isPresent),function addOne)
	timer t = getTimer()
	t.start(0.01,function checkPresents)
	
function checkPresents()
	debugPrint("presents: "+presents.toString(),1)
	if presents <= 2
		spawnPresent()
		presentSpawn.play()
		
init
	timer t = getTimer()
	t.startPeriodic(25.,function onPresentTime)
		
endpackage	

	 //######################################################
 // File C:\Users\Frotty\Documents\GitHub\InWcSchneeball\wurst\init\GameInit.wurst
 //######################################################
package GameInit
import Child
import Flag
import EntityManagement
import Presents
import Gamemode
import PlayerData
import SoundHelper
import PresentUnwrap

Sound s

function startGame()
	for p in players
		if p.id > 5 
			SelectUnitForPlayerSingle((new Child(vec3(SX2 + 64 * p.id, SY2, 200.), p.p, 'H007')).actor, p.p)
		else
			SelectUnitForPlayerSingle((new Child(vec3(SX1 + 64 * p.id, SY1, 200.), p.p, 'H001')).actor, p.p)

	SetTimeOfDay(12.)
	/*redflag = new Flag(vec3(-3500,1200,0.), CreateUnit(Player(0),'hpea', -3500, 1200, 0.))
	redflag.redTeam = true*/
	getTimer().start(.5,function createDialog)
	startEntityLoop()
	initPresentCircles()

init
	getTimer().start(0.1, function startGame)

		
endpackage	

	 //######################################################
 // File C:\Users\Frotty\Documents\GitHub\InWcSchneeball\wurst\item\ItemHandling.wurst
 //######################################################
package ItemHandling
import GameConstants
import ItemObject
import Texttag

int array items
int array spells
int array maxstack

constant int PRESENT_ID = 'I002'

public function onPickup()
	debugPrint("PICKUP", 1)
	let u = GetManipulatingUnit()
	let itm = GetManipulatedItem()
	let itid = GetItemTypeId(itm)
	if itid == PRESENT_ID
		if GetItemOfTypeFromUnitBJ(u, PRESENT_ID) != itm
			let data = itm.getUserData() castTo ItemObject
			data.actorItem.remove()
			data.actorItem = CreateItem(PRESENT_ID, data.pos.x, data.pos.y)
			data.actorItem.setUserData(data castTo int)
			createTTEx(vec3(u.getX(),u.getY(),20.), vec2(0,0.05), "|cffcccc00You can only carry one!|r", 10,  2., colorA(255,255,255,0), u.getOwner() )
		else
			DisplayTimedTextToForce(GetPlayersAll(), 12., colorcode[u.getOwner().getId()] + u.getOwner().getName() + "|r hat ein Geschenk aufgehoben!")	
		return
	item foundItem = null
	int itemid
	for i = 0 to 4
		if GetItemTypeId(itm) == items[i]
			itemid = i
			break
	debugPrint("PICKUP1", 1)
	int charges = 1
	for i = 0 to 5
		var uit = UnitItemInSlot(u, i)
		if GetItemTypeId(uit) == GetItemTypeId(itm) and uit != itm
			debugPrint("PICKUP FOUND", 1)
			charges = (GetItemCharges(uit) + GetItemCharges(itm))
			debugPrint(charges.toString() + " " + maxstack[itemid].toString(), 1)
			if GetItemCharges(uit) + GetItemCharges(itm) <= maxstack[itemid]
				debugPrint("PICKUP FOUND YES", 1)
				foundItem = uit
				RemoveItem(itm)
				break
	if foundItem != null
		debugPrint("PICKUP FOUND SET " + (charges).toString(), 1)
		SetItemCharges(foundItem, charges)
	else
		u.addAbility(spells[itemid])


public function removeallspell(unit u)
	for i = 0 to 4
		u.removeAbility(spells[i])



init
	trigger t = CreateTrigger()
	trigger t2 = CreateTrigger()
	t2.registerAnyUnitEvent(EVENT_PLAYER_UNIT_PICKUP_ITEM)
	t2.addAction(function onPickup)
	// Icewall
	items[0] = 'I003'
	spells[0] = 'A004'
	maxstack[0] = 3
	// SNowbomb
	items[1] = 'I006'
	spells[1] = 'A001'
	maxstack[1] = 2
	// Rolling Ball
	items[2] = 'I004'
	spells[2] = 'A002'
	maxstack[2] = 1
	// Snowman
	items[3] = 'I005'
	spells[3] = 'A003'
	maxstack[3] = 2
	// Iceshard
	items[4] = 'I00E'
	spells[4] = 'A008'
	maxstack[4] = 3

		
endpackage	

	
 //######################################################
 // File C:\Users\Frotty\Documents\GitHub\InWcSchneeball\wurst\item\ItemObject.wurst
 //######################################################
package ItemObject
import Entity

public class ItemObject extends Entity
	item actorItem

	construct( item i )
		super( vec3(i.getX(),i.getY(),0.), DUMMY_PLAYER, 0. )
		actorItem = i
		SetItemUserData(actorItem, this castTo int)
		active = false

	override function update()
		
	ondestroy
		actorItem.remove()
		

		
endpackage	

 //######################################################
 // File C:\Users\Frotty\Documents\GitHub\InWcSchneeball\wurst\item\PresentUnwrap.wurst
 //######################################################
package PresentUnwrap
import Colors
import Texttag
import Gamemode
import GameConstants
import CustomBar
import Entity
import TimedBar
import Child
import ItemObject

constant int PRESENT_ID = 'I002'
constant int UNWRAP_ID = 'A007'
constant int CIRCLE_ID = 'ncop'
int array PRESENTS

public function checkUnwrap(unit u)
	for int i = 0 to 5
		var uit = UnitItemInSlot(u, i)
		if GetItemTypeId(uit) == PRESENT_ID
			RemoveItem(uit)
			u.addItem(PRESENTS[GetRandomInt(0,4)])
			break

function isChild() returns boolean
	if GetUnitTypeId(GetFilterUnit()) == 'H001' or GetUnitTypeId(GetFilterUnit()) == 'H007'
		return true
	return false

function sellPresent()
	let u = GetTriggerUnit()
	let p = GetOwningPlayer(u)
	for int i = 0 to 5
			var uit = UnitItemInSlot(u, i)
			if GetItemTypeId(uit) == PRESENT_ID
				(uit.getUserData() castTo ItemObject).terminate()
				SetPlayerState(p, PLAYER_STATE_RESOURCE_GOLD, GetPlayerState(p, PLAYER_STATE_RESOURCE_GOLD)+100)
				createTTEx(vec3(u.getX(),u.getY(),20.), vec2(0,0.05), "|cffffcc00+100|r", 10,  2., colorA(255,255,255,0), p )
				DisplayTimedTextToForce(GetPlayersAll(), 12., colorcode[p.getId()] + p.getName() + "|r hat ein Geschenk abgegeben und 2 Punkte für sein team geholt!")	
				if p.getId() <= 5
					redscore += 2
				else
					greenscore += 2
				checkEnd()


function startBar()
	var u = GetSpellAbilityUnit()
	var id = GetSpellAbilityId()
	if id == UNWRAP_ID
		(u.getUserData() castTo Child).wrapBar = new TimedBar(vec3(u.getX()-120.,u.getY(),-16), "|", 120, 0, 7.5, colorA(255,255,255,255), colorA(230,181,16,255), u )

	

	


trigger t
unit scircle
unit ncircle
public function initPresentCircles()
	scircle = CreateUnit(Player(15),CIRCLE_ID, -256, 1350,0.)
	ncircle = CreateUnit(Player(15),CIRCLE_ID, 0, 6540,0.)
	t = CreateTrigger()
	t.registerUnitInRange(scircle, 100,Condition(function isChild))
	t.addAction(function sellPresent)
	t = CreateTrigger()
	t.registerUnitInRange(ncircle, 100,Condition(function isChild))
	t.addAction(function sellPresent)
	
init
	t = CreateTrigger()
	t.registerAnyUnitEvent(EVENT_PLAYER_UNIT_SPELL_CHANNEL)
	t.addAction(function startBar)
	PRESENTS[0] = 'I000'
	PRESENTS[1] = 'I001'
	PRESENTS[2] = 'I00B'
	PRESENTS[3] = 'I00C'
	PRESENTS[4] = 'I00D' 

		
endpackage	

	
//######################################################
 // File C:\Users\Frotty\Documents\GitHub\InWcSchneeball\wurst\item\TimedBar.wurst
 //######################################################
package TimedBar
	import Entity
	import CustomBar
	import public Colors
	import PresentUnwrap
	import Child
	
	public class TimedBar extends Entity
		CustomBar bar
		real cvalue = 0
		real time
		unit u
		boolean correct = false
		construct( vec3 pos, string char, int chars, real value, real time, colorA bg, colorA fg, unit u )
			super(pos, DUMMY_PLAYER, 0.)
			this.u = u
			PauseUnit(u, true)
			this.time = time
			bar = new CustomBar(pos,char, chars, 5)
			bar.setValue(value)
			bar.setBackground(bg)
			bar.setForeground(fg)
			
		override function update()
			cvalue += ANIMATION_PERIOD
			bar.setValue(cvalue/time*100)
			if cvalue >= time
				correct = true
				done = true
				
		ondestroy
			checkUnwrap(u)
			PauseUnit(u, false)
			(u.getUserData() castTo Child).wrapBar = null
			destroy bar
			
		
			
			
endpackage //######################################################
 // File C:\Users\Frotty\Documents\GitHub\InWcSchneeball\wurst\player\GameConstants.wurst
 //######################################################
package GameConstants
	import Colors
	import SoundHelper
	
	public string array mbPic
	public string array names
	public string array tags
	public string array colorcode
	public integer array expBounds
	public string array ranks
	public Sound array announcers
	
	public constant string MAP_VER = "|cffE66321in|cffADADADWarcraft |cffF7F7F7Schneeballschlacht|r"
	
	
	public enum COLOR
		WHITE
		RED
		BLUE
		TEAL	
		PURPLE
		YELLOW
		ORANGE
		GREEN		
		PINK
		GREY
		LIGHTBLUE
		DARKGREEN
		BROWN

	public color array colors

	init
		colors[0] = color(255,255,255)
		colors[1] = color(255,2,2)
		colors[2] = color(0,65,255)
		colors[3] = color(27,230,184)
		colors[4] = color(83,0,128)
		colors[5] = color(255,204,0)
		colors[6] = color(255,255,1)
		colors[7] = color(31,191,0)
		colors[8] = color(229,90,175)
		colors[9] = color(148,149,150)
		colors[10] = color(125,190,241)
		colors[11] = color(15,97,69)
		colors[12] = color(77,41,3)
		
	
	
		mbPic[ 0 ] = "ReplaceableTextures\\CommandButtons\\BTNPriest.blp"
		mbPic[ 1 ] = "ReplaceableTextures\\CommandButtons\\BTNFootman.blp"
		mbPic[ 2 ] = "ReplaceableTextures\\CommandButtons\\BTNPeasant.blp"
		mbPic[ 3 ] = "ReplaceableTextures\\CommandButtons\\BTNIceTrollBeserker.blp"

		names   [0] = "Frotty"
		tags    [0] = "|cffEF6B21[God]"
		names   [1] = "FrottyZ"
		tags    [1] = "|cffEF6B21[God]"
		names   [2] = "Feuerblume"
		tags    [2] = "|cff9C94E6[Tester]"
		names   [3] = "jkkopp"
		tags    [3] = "|cff9C94E6[Tester]"
		names   [4] = "fortress_na-f"
		tags    [4] = "|cff9C94E6[Tester]"
		names   [5] = "Kornblume"
		tags    [5] = "|cff9C94E6[Tester]"
		names   [6] = "Gamestargamer"
		tags    [6] = "|cff9C94E6[Tester]"
		names   [7] = "gamestargamer"
		tags    [7] = "|cff9C94E6[Tester]"
		names   [8] = "mooniii"
		tags    [8] = "|cff9C94E6[Tester]"
		names   [9] = "Carlor01"
		tags    [9] = "|cff9C94E6[Tester]"
		names   [10] = "Mo0ni[behh]"
		tags    [10] = "|cff9C94E6[Tester]"
		names   [11] = "metactylic"
		tags    [11] = "|cffB5DE42[Art]"
		names   [12] = "nore.abfl"
		tags    [12] = "|cff9C94E6[Tester]"
		names   [13] = "kleinerhauck"
		tags    [13] = "|cff9C94E6[Tester]"
		names	[14] = "kari0003"
		tags	[14] = "|cffFFE87C[Adept]"

		colorcode[ 0 ] = "|cffFF0202" // red
		colorcode[ 1 ] = "|cff0041FF" // blue
		colorcode[ 2 ] = "|cff1BE6B8" // teal
		colorcode[ 3 ] = "|cff530080" // lila
		colorcode[ 4 ] = "|cffFFFC00" // yellow
		colorcode[ 5 ] = "|cffFE890D" // orange
		colorcode[ 6 ] = "|cff1FBF00" // green
		colorcode[ 7 ] = "|cffE55AAF" // pink
		colorcode[ 8 ] = "|cff949596" // gray
		colorcode[ 9 ] = "|cff7DBEF1" // lightblue
		colorcode[ 10 ] = "|cff0F6145" // darkgreen
		colorcode[ 11 ] = "|cff4D2902" // brown

		expBounds[0] = 10
		expBounds[1] = 30
		expBounds[2] = 50
		expBounds[3] = 100
		expBounds[4] = 150
		expBounds[5] = 300
		expBounds[6] = 500
		expBounds[7] = 1000
		expBounds[8] = 10000

		ranks[0] = "Newbie"
		ranks[1] = "Beginner"
		ranks[2] = "Amateur"
		ranks[3] = "Player"
		ranks[4] = "Rooter"
		ranks[5] = "Pro"
		ranks[6] = "Expert"
		ranks[7] = "Addict"
		
		announcers[0] = new Sound("war3mapImported\\double.mp3", 4690, false, false, false, 10, 10, "CombatSoundsEAX")
		announcers[1] = new Sound("war3mapImported\\tripleKill.mp3", 3484, false, false, false, 10, 10, "CombatSoundsEAX")
		announcers[2] = new Sound("war3mapImported\\hohoho.wav", 2016, false, false, false, 10, 10, "CombatSoundsEAX")
		announcers[3] = new Sound("war3mapImported\\readyForChristmas.mp3", 2688, false, false, false, 10, 10, "CombatSoundsEAX")
		announcers[4] = new Sound("war3mapImported\\merryFuckingChristmas.mp3", 7430, false, false, false, 10, 10, "CombatSoundsEAX")
		announcers[5] = new Sound("war3mapImported\\veryMerryChristmas.mp3", 7112, false, false, false, 10, 10, "CombatSoundsEAX")

endpackage  //######################################################
 // File C:\Users\Frotty\Documents\GitHub\InWcSchneeball\wurst\player\MultiboardClass.wurst
 //######################################################
package MultiboardClass
	import Multiboard
	int counter = 0
	MbItem array data

	public class Board
		multiboard board
		hashtable mbdata
		
		
		construct(int row, int column )
			board = CreateMultiboard()
			board.setColumnCount(column)
			board.setRowCount(row)
			mbdata = InitHashtable()
			for int i = 1 to row //we need to register them so the USER wont have to.
				for int j = 1 to column
					setNewItem(i,j,null,null)
					board.getItem(i,j).setStyle(false,false) //Hide everything, updateItem() func will show stuff automatically
					
		function show()
			board.display(true)
			
		function setNewItem(int i,int j,string value, string icon)
			SaveInteger(mbdata,i,j,counter)
			data[counter] = MbItem(value, icon)
			board.getItem(i,j).setValue(value)
			board.getItem(i,j).setIcon(icon)
			counter +=1
			
		function removeRow(int r)
			for int j =0 to board.getColumnCount()   
				for int i =r to board.getRowCount()
					if i == board.getRowCount()-1
						//destroy data[LoadInteger(mbdata,i,j)]
						RemoveSavedInteger(mbdata,i,j) //clear the last row
					else
						var nextitem = data[LoadInteger(mbdata,i+1,j)]
						updateItem(i,j,nextitem.value,nextitem.icon)
			board.setRowCount(board.getRowCount()-1)
			
		function updateItem(int i,int j,string value, string icon)
			data[LoadInteger(mbdata,i,j)] = MbItem(value , icon)
			if value != null
				updateValue(i,j,value)
				if icon != null
					updateIcon(i, j,icon)
					board.getItem(i,j).setStyle(true,true)
				else
					board.getItem(i,j).setStyle(true,false) // need to avoid green missing icon images
			else if icon != null
				updateIcon(i, j,icon)
				board.getItem(i,j).setStyle(false,true)
			
		function updateValue(int i, int j,string value)
			data[LoadInteger(mbdata,i,j)].value = value
			board.getItem(i,j).setValue(value)

		function updateIcon(int i, int j,string icon)
			data[LoadInteger(mbdata,i,j)].icon = icon
			board.getItem(i,j).setIcon(icon)
			
		function getPlayerPos(string name) returns integer //Get string coz players can have different names on the Multiboard
			for int i = 1 to board.getRowCount()
				if name == data[LoadInteger(mbdata,i,0)].value
					return i
			return 0
		
		function getMB() returns multiboard
			return board

		ondestroy
			DestroyMultiboard(board)
			FlushParentHashtable(mbdata)
			
	tuple MbItem(string value, string icon)
	/*
	class MbItem
		string value
		string icon
		
		construct (string s, string i)
			value = s
			icon = i*/
			
endpackage //######################################################
 // File C:\Users\Frotty\Documents\GitHub\InWcSchneeball\wurst\player\PlayerData.wurst
 //######################################################
package PlayerData
	import MultiboardClass
	import LinkedList
	import GameConstants
	import Gamemode
	
	public int playercount = 0
	
	trigger leaveTrig
	
	public LinkedList<PlayerData> players = new LinkedList<PlayerData>()
	public Board playerboard
	public PlayerData array pData

	public class PlayerData //just the player's (constant) stuff
		
		int id
		int gameId
		player p
		string name
		string mbname //Basically the output name
		string icon = "ReplaceableTextures\\CommandButtons\\BTNSelectHeroOn.blp"
		boolean left = false
		
		int deaths = 0
		int kills = 0
		
		int killstreak = 0
		boolean indouble = false
		boolean intriple = false
	
		construct (player p)
			this.p = p
			id = GetPlayerId(p)
			gameId = players.size
			name = GetPlayerName(p)
			mbname = name

			mbname = colorcode[ id ] + mbname
			debugPrint("MBNAME: " + mbname, 1)
			players.add(this)
			
				
		function setMBRow(int r)
			playerboard.setNewItem(r,0,mbname,icon)
			playerboard.setNewItem(r,1,kills.toString(),null)
			playerboard.setNewItem(r,2,deaths.toString(),null)
			if id < 6
				playerboard.setNewItem(r,3,"|cffff6347Rotes Team",null)
			else
				playerboard.setNewItem(r,3,"|cff3cb371Grünes Team",null)

		
		function setMbIcon(int typ)
			playerboard.updateIcon(gameId+1, 0, mbPic[typ])
			
		ondestroy
			DisplayTimedTextToPlayer( GetLocalPlayer(), 0, 0, 20., colorcode[p.getId()] + p.getName() + "|r |cffFFCC33has left the game!") 
			PlaySoundBJ( gg_snd_QuestFailed )
			playerboard.removeRow(gameId+1)
			if gameId < playercount
				for p2 in players
					if p2.gameId > gameId
						p2.gameId--
			playercount--
			
		

	
	function initMB()
		playerboard = new Board(playercount+1,4)
		
		for i = 0 to players.size
			playerboard.board.getItem(i,0).setStyle(true,true).setWidth(0.1)
			playerboard.board.getItem(i,1).setStyle(true,false).setWidth(0.015)
			playerboard.board.getItem(i,2).setStyle(true,false).setWidth(0.015)
			playerboard.board.getItem(i,3).setStyle(true,false).setWidth(0.05)

		for pd in players
			pd.setMBRow(pd.gameId+1)


		playerboard.board.getItem(0,0).setStyle(true,false).setWidth(0.1)
		playerboard.setNewItem(0,0,"Player",null)
		playerboard.board.getItem(0,1).setStyle(false,true).setWidth(0.015)
		playerboard.setNewItem(0,1,null,"ReplaceableTextures\\CommandButtons\\BTNSacrifice.blp")
		playerboard.board.getItem(0,2).setStyle(false,true).setWidth(0.015)
		playerboard.setNewItem(0,2,null,"ReplaceableTextures\\CommandButtons\\BTNAnkh.blp")
		playerboard.board.getItem(0,3).setWidth(0.05)
		playerboard.setNewItem(0,3,"Team",null)
		playerboard.board.display(true)
		
		
	function setTime()
		seconds++
		string secs = "|cffffffff"
		string mins = "|cffffffff"
		if seconds < 10
			secs += "0" + seconds.toString()
		else
			secs += seconds.toString()
			
		if minutes < 10
			mins += "0" + minutes.toString()
		else
			mins += minutes.toString()
			
		secs += "|r"
		mins += "|r"
		
		playerboard.board.setTitle( MAP_VER + " [ " + mins + " : " + secs +" ] |cffff6347" +redscore.toString() +"|r - |cff3cb371" + greenscore.toString())
		
		
		
		if seconds >= 60
			seconds = 0
			minutes++
				 
	function playerLeft()
		var p = GetTriggerPlayer()
		var pd = pData[p.getId()]
		players.remove(pd)
		destroy pd


		
	init
		leaveTrig = CreateTrigger()
		leaveTrig.addAction(function playerLeft)
		int r = 0
		for i = 0 to 11
			debugPrint(i.toString(), 1)
			if GetPlayerSlotState(Player(i)) == PLAYER_SLOT_STATE_PLAYING and GetPlayerController(Player(i)) == MAP_CONTROL_USER
				pData[i] = new PlayerData(Player(i))
				leaveTrig.registerPlayerEvent(Player(i), EVENT_PLAYER_LEAVE)
				r++
		playercount = r
		TimerStart(CreateTimer(), 1., false,function initMB)
		TimerStart(CreateTimer(), 1., true, function setTime)
	   
	int minutes = 0
	int seconds = 0
	

		
		
endpackage  //######################################################
 // File C:\Users\Frotty\Documents\GitHub\InWcSchneeball\wurst\projectiles\HomingMissile.wurst
 //######################################################
package HomingMissile
	import Fx
	
		
	function spellCondition() returns boolean
		if GetSpellAbilityId() == 'A001'
			return true
		else
			return false
	
	
	function spellStart()
		new HomingMissle(GetTriggerUnit(), GetSpellTargetUnit())
		
	public class HomingMissle
		
		timer t
		unit u
		unit ut
		real x
		real y
		real x2
		real y2
		real push
		real pushFaktor
		real i
		real angl
		Fx fx
		
		
		
		construct(unit u, unit ut)
			this.u=u
			this.ut=ut

			angl = anglBetweenCoordsD(u.getX(), u.getY(), ut.getX(), ut.getY())

			push = 1			//Speed für den Vektor
			pushFaktor = 0.05	//Verringert den Vektor
			
			i = 60/0.03
			x = u.getX()
			y = u.getY()
			x2 = 0
			y2 = 0
			
			fx = new Fx(u.getX(),u.getY(),angl,"Abilities\\Weapons\\IllidanMissile\\IllidanMissile.mdl")
			fx.setOwner(GetOwningPlayer(u), false)
			fx.setZ(50)
			
			t = getTimer()
			t.setData(this castTo int)
			t.startPeriodic(0.03, function blackHCall) 
			
		static function blackHCall()
			GetExpiredTimer().getData() castTo HomingMissle.theSpell()
		
		function theSpell()
			i--
			
			angl = anglBetweenCoordsD(fx.getX(), fx.getY(), ut.getX(), ut.getY())
			
			x = polarProjectionXD(fx.getX(), push, angl)
			y = polarProjectionYD(fx.getY(), push, angl)
			
			x = x - fx.getX() // why not polarProjectionXD(0., push, angl) ?
			y = y - fx.getY()
			
			x2 = x2 + x
			y2 = y2 + y
			
			x = fx.getX() + x2
			y = fx.getY() + y2
			
			fx.setPos(x,y)
			
			x2 = x2 - (x2*pushFaktor)
			y2 = y2 - (y2*pushFaktor)
			
			if i <= 0
				t.release()
				fx.hiddenDestroy()
				





endpackage
 //######################################################
 // File C:\Users\Frotty\Documents\GitHub\InWcSchneeball\wurst\projectiles\HomingProjectile.wurst
 //######################################################
package HomingProjectile
import public Projectile
import Fx
import Terrain

public enum HOMING
	attract // Direct homing
	angular // Chaning angl
	forced // pushed homing (warlock-like)

public class HomingProjectile extends Projectile
	Entity target
	real speed = 12.
	real homingSpeed = 0.15
	real zangl
	HOMING homingType = HOMING.attract
	

	
	construct(vec3 pos, player owner, real radius, real angl, string fxpath)
		super(pos, owner, radius)
		fx = new Fx(pos, angl*RADTODEG, fxpath)
		xyangl = angl
		
	function setHomingTarget(Entity e)
		target = e

		
	override function update()
		let dist = distanceBetweenCoords(pos.x, pos.y, target.pos.x, target.pos.y)
		let anglxy = anglBetweenCoordsR(pos.x, pos.y, target.pos.x, target.pos.y)
		let anglz = getSlopeangl(pos.z, target.pos.z, dist )
		switch homingType
			case HOMING.attract
				vel = (target.pos - this.pos).setLength(speed)
			case HOMING.angular
				var df1 = anglxy - xyangl
				var df2 = (PI2 + anglxy) - xyangl
				var ns = homingSpeed
		
				if df1 <= 0
					if df2 <= 0 
						if df2 >= df1 
							df1 = df2
					else
						if -df1 >= df2
							df1 = df2
				else
					if df2 <= 0 
						if -df2 <= df1
							df1 = df2
					else
						if df2 <= df1 
							df1 = df2
				if df1 <= 0 
					if -df1 >= ns 
						ns = -ns
					else
						ns = df1
				else
					if df1 <= ns 
						ns = df1
				var d = xyangl
				d += ns
				if d >= PI2
					d -= PI2
				else if d < 0
					d += PI2
		
				xyangl = d
		
				if anglz > zangl
					if anglz - zangl < homingSpeed
						zangl += anglz - zangl
					else
						zangl += homingSpeed
				else if zangl > anglz
					if zangl - anglz < homingSpeed
						zangl -= zangl - anglz
					else
						zangl -= homingSpeed
				vel = vec3( speed * Cos(xyangl), speed * Sin(xyangl), speed * Sin(zangl)  )
				
			case HOMING.forced
				vec3 tmp = vec3(polarProjectionXR(pos.x, speed, anglxy), polarProjectionYR(pos.y, speed, anglxy), polarProjectionZR(pos.z, speed, anglz))
				
				tmp -= pos
				
				vel += tmp
				
				pos += vel
				
				fx.setPos(pos)
				
				vel -= (vel*homingSpeed)
		super.update()
		
		
endpackage	

 //######################################################
 // File C:\Users\Frotty\Documents\GitHub\InWcSchneeball\wurst\projectiles\Projectile.wurst
 //######################################################
package Projectile
import public Entity
import Fx
import Terrain
import PhysicsConstants

public class Projectile extends Entity
	Fx fx
	boolean timed = false
	real time
	real xyspeed
	real xyangl
	boolean keepHeight = true
	real terrainZ = 0.
	boolean gravityAffected = false
	boolean hiddenDestroy = false
	
	construct(vec3 pos, player owner, real radius)
		super(pos, owner, radius)
		
	function setTimed(real duration)
		timed = true
		time = duration		
		
	function setXYSpeed(real speed)
		xyspeed = speed
		vel = vec3(Cos(xyangl)*speed, Sin(xyangl)*speed, vel.z)
		
	override function update()
		terrainZ = getTerrainZ(pos.x, pos.y)
		if gravityAffected
			vel += gravity
		pos += vel
		if keepHeight
			fx.setPos(pos.x, pos.y, pos.z-terrainZ)
		else
			fx.setPos(pos)
		fx.setXYangl(xyangl*RADTODEG)
		if timed
			time -= ANIMATION_PERIOD
			if time < 0
				terminate()
				
				
	ondestroy
		if hiddenDestroy
			fx.hiddenDestroy()
		else
			destroy fx
			
		
endpackage	

		 //######################################################
 // File C:\Users\Frotty\Documents\GitHub\InWcSchneeball\wurst\spells\Iceshard.wurst
 //######################################################
package Iceshard
import Projectile
import Fx
import Child
import SoundHelper
import SoundQueue
import IceWall
import Snowball

constant real SPEED = 24

public class Iceshard extends Projectile

	construct(vec3 pos, player owner, real angl)
		super(pos, owner, 32.)
		fx = new Fx(pos, angl*RADTODEG, "Abilities\\Weapons\\LichMissile\\LichMissile.mdl")
		fx.setOwner(owner, false)
		setTimed(4.)
		xyangl = angl
		setXYSpeed(SPEED)
		throwSound.playOnPoint(pos)
		
	override function update()
		super.update()
		if pos.z < terrainZ
			terrainHitSound.playOnPoint(pos)
			terminate()
				
		Entity e = Entity.first
		while e != null
			if e != this and owner != e.owner and IsPlayerEnemy( e.owner, owner )
				//debugPrint(pos.distToVecSquared(e.pos).toString(),1)
				if pos.distToVecSquared(e.pos) < (e.radius+radius).squared()
					debugPrint("inRange",1)
					onHit(e)
					debugPrint("hit",1)
					
			e = e.next
			
			
	function onHit(Entity e)
		terminate()
		if e instanceof Child
			var c = e castTo Child
			fx.dummy.damageTarget(c.actor, 65.)
			childHitSound.playOnPoint(pos)
			
	ondestroy
		AddSpecialEffect("Abilities\\Spells\\Undead\\FrostArmor\\FrostArmorDamage.mdl", pos.x, pos.y).destr()
	


	
		
endpackage	
		
 //######################################################
 // File C:\Users\Frotty\Documents\GitHub\InWcSchneeball\wurst\spells\IceWall.wurst
 //######################################################
package IceWall
import Projectile
import Fx
import Child
import LinkedList

constant real SPEED = 18.
constant real FACTOR = 2.
constant int COLLOSION = 'e001'

public class IceMissile extends Projectile
	vec3 target

	construct(vec3 pos, player owner, vec3 target)
		super(pos, owner, 32.)
		this.target = target
		let angl = anglBetweenCoordsR(pos.x, pos.y, target.x, target.y)
		fx = new Fx(pos, angl*RADTODEG, "Abilities\\Weapons\\WingedSerpentMissile\\WingedSerpentMissile.mdl")
		fx.setOwner(owner, false)
		setTimed(4.)
		xyangl = angl
		setXYSpeed(SPEED)
		//throwSound.playOnPoint(pos)
		
	override function update()
		super.update()
		if pos.toVec2().distToVecSquared(target.toVec2()) < 48*48
			terminate()
			
		Entity e = Entity.first
		while e != null
			if e != this and owner != e.owner and IsPlayerEnemy( e.owner, owner )
				if pos.distToVecSquared(e.pos) < (e.radius+radius).squared()
					debugPrint("inRange",1)
					onHit(e)
					debugPrint("hit",1)
			e = e.next
			
			
	function onHit(Entity e)
		terminate()
		if e instanceof Child
			let angl = anglBetweenCoordsR(pos.x, pos.y, e.pos.x, e.pos.y)
			e.addVel(vec3(Cos(angl) * FACTOR, Sin(angl) * FACTOR, 1.))

			
	ondestroy
		if not pos.z < terrainZ
			new Iceblock(vec3(pos.x, pos.y, 0), owner,.5 )
			new Iceblock(vec3(polarProjectionXR(pos.x, 48.,xyangl-1.8), polarProjectionYR(pos.y, 48.,xyangl-1.8), 0), owner,.4 )
			new Iceblock(vec3(polarProjectionXR(pos.x, 48.,xyangl+1.8), polarProjectionYR(pos.y, 48.,xyangl+1.8), 0), owner,.4 )

public class Iceblock extends Entity
	real scale
	Fx block
	unit collision
	real timeout = 25.

	construct(vec3 pos, player owner, real scale)
		super(pos, owner, scale*24)
		debugPrint("Created",1)
		collision =CreateUnit(owner, COLLOSION, pos.x,pos.y,0)
		collision.setXY(pos.x,pos.y)
		block = new Fx(pos, GetRandomReal(0,360), "Doodads\\Icecrown\\Rocks\\Icecrown_Crystal\\Icecrown_Crystal"+ GetRandomInt(0,8).toString() +".mdl")
		block.setOwner(owner, false)
		this.scale = scale
		block.setScale(scale)
		
	override function update()
		super.update()
		Entity e = Entity.first
		timeout -= ANIMATION_PERIOD
		if timeout <= 0.
			terminate()
			return
		while e != null
			if e instanceof Projectile 
				if pos.distToVecSquared(e.pos) < (e.radius+radius).squared()
					e.terminate()
					onHit()
			e = e.next
					
	function onHit()
		scale -= .12
		debugPrint("scale: " + scale.toString(),1)
		block.setScale(scale)
		radius = scale*16
		if scale < .2
			terminate()

	ondestroy
		collision.remove()
		block.hiddenDestroy()
		
endpackage	

		 //######################################################
 // File C:\Users\Frotty\Documents\GitHub\InWcSchneeball\wurst\spells\Rollingball.wurst
 //######################################################
package Rollingball
import Projectile
import Fx
import Child
import Terrain
import SoundHelper

constant real STARTMOMENTUM = 1
constant real MOMENTUMGAIN = .15
constant real MOMENTUMMAX = 20
constant real SIZEGAIN = .075
constant real MAXSIZE = 22.5

public class Rollingball extends Projectile
	real momentum
	real size = 2
	real startz

	construct(vec3 pos, player owner, real angl)
		super(pos, owner, 32.)
		startz = pos.z
		fx = new Fx(pos, angl*RADTODEG, "war3mapImported\\rollingball.mdx")
		fx.setOwner(owner, true)
		xyangl = angl
		setXYSpeed(STARTMOMENTUM)
		momentum = STARTMOMENTUM
		startRoll.playOnPoint(pos)
		hiddenDestroy = true

		
	override function update()
		if momentum < MOMENTUMMAX
			momentum += MOMENTUMGAIN
			setXYSpeed(momentum)
		if size < MAXSIZE
			size += SIZEGAIN
			fx.setScale(size)
			radius = size*8
			pos.z = startz+radius-16.
		super.update()
		var x = polarProjectionXR(pos.x,radius -2., xyangl+90*DEGTORAD )
		var y = polarProjectionYR(pos.y,radius -2., xyangl+90*DEGTORAD )
		//AddSpecialEffect("Abilities\\Weapons\\SpiritOfVengeanceMissile\\SpiritOfVengeanceMissile.mdl", x, y)
		let tz1 = getTerrainZ(x,y)
		x = polarProjectionXR(pos.x,radius -2., xyangl-90*DEGTORAD )
		y = polarProjectionYR(pos.y,radius -2., xyangl-90*DEGTORAD )
		//AddSpecialEffect("Abilities\\Weapons\\SpiritOfVengeanceMissile\\SpiritOfVengeanceMissile.mdl", x, y)
		let tz2 = getTerrainZ(x,y)
		if radius > 32.
			if pos.z < terrainZ or pos.z < tz1 or pos.z < tz2
				terminate()
			else if terrainZ < startz
				startz = terrainZ
			
		Entity e = Entity.first
		while e != null
			if e != this and owner != e.owner and IsPlayerEnemy( e.owner, owner )
				debugPrint(pos.distToVecSquared(e.pos).toString(),1)
				if pos.distToVecSquared(e.pos) < (e.radius+radius).squared()
					debugPrint("inRange",1)
					onHit(e)
					debugPrint("hit",1)
					
			e = e.next
			
			
	function onHit(Entity e)
		if e instanceof Child
			var c = e castTo Child
			terminate()
			fx.dummy.damageTarget(c.actor, momentum*4)
		else if e instanceof Projectile
			e.terminate()
	
	ondestroy
		AddSpecialEffect("war3mapImported\\rollingExplosion.mdx", pos.x, pos.y)
		hitTarget.playOnPoint(pos)
		
Sound startRoll
Sound hitTarget

init
	startRoll = new Sound("Abilities\\Spells\\Orc\\EarthQuake\\EarthquakeRock.wav", 2972, false, true, true, 10, 10, "CombatSoundsEAX")
	hitTarget = new Sound("Abilities\\Spells\\Human\\FlakCannons\\FlakCannon.wav", 1419, false, true, true, 10, 10, "CombatSoundsEAX")
	

		
endpackage	
				
 //######################################################
 // File C:\Users\Frotty\Documents\GitHub\InWcSchneeball\wurst\spells\Snowball.wurst
 //######################################################
package Snowball
import Projectile
import Fx
import Child
import SoundHelper
import SoundQueue
import IceWall

constant real SPEED = 14

public class Snowball extends Projectile

	construct(vec3 pos, player owner, real angl)
		super(pos, owner, 32.)
		fx = new Fx(pos, angl*RADTODEG, "war3mapImported\\CorpseBomb.mdx")
		fx.setOwner(owner, true)
		setTimed(4.)
		
		xyangl = angl
		setXYSpeed(SPEED)
		throwSound.playOnPoint(pos)
		
	override function update()
		super.update()
		if pos.z + radius < terrainZ
			terrainHitSound.playOnPoint(pos)
			terminate()
		else if pos.z - radius > terrainZ
			pos.z -= (pos.z-radius) - terrainZ
			
				
		Entity e = Entity.first
		while e != null
			if e != this and owner != e.owner and IsPlayerEnemy( e.owner, owner )
				//debugPrint(pos.distToVecSquared(e.pos).toString(),1)
				if pos.distToVecSquared(e.pos) < (e.radius+radius).squared()
					debugPrint("inRange",1)
					onHit(e)
					debugPrint("hit",1)
					
			e = e.next
			
			
	function onHit(Entity e)
		terminate()
		if e instanceof Child
			var c = e castTo Child
			fx.dummy.damageTarget(c.actor, 55.)
			childHitSound.playOnPoint(pos)

	ondestroy
		AddSpecialEffect("Abilities\\Spells\\Undead\\FrostArmor\\FrostArmorDamage.mdl", pos.x, pos.y).destr()
	
public Sound throwSound
public Sound terrainHitSound
public Sound childHitSound

	
init
	throwSound = new Sound("Abilities\\Spells\\Other\\FrostBolt\\FrostBoltLaunch1.wav", 1100, false, true, true, 10, 10, "CombatSoundsEAX")
	terrainHitSound = new Sound("Abilities\\Spells\\Other\\FrostBolt\\FrostBoltHit1.wav", 1347, false, true, true, 10, 10, "CombatSoundsEAX")
	childHitSound = new Sound("Abilities\\Spells\\Other\\FrostArrows\\FrostArrowHit1.wav", 1115, false, true, true, 10, 10, "CombatSoundsEAX")
		
endpackage	
		
 //######################################################
 // File C:\Users\Frotty\Documents\GitHub\InWcSchneeball\wurst\spells\Snowbomb.wurst
 //######################################################
package Snowbomb
import Projectile
import Fx
import Child

constant real SPEED = 12
constant real AOE = 300.*300.
constant real FACTOR = 14.

public class Snowbomb extends Projectile

	construct(vec3 pos, player owner, vec3 target)
		super(pos, owner, 16.)
		fx = new Fx(pos, 0, "war3mapImported\\FrostMissile.mdx")
		fx.setOwner(owner, false)
		let dist = target.distToVec(pos)
		if dist < 200.
			var ntarget = target.toVec2().polarOffset(anglBetweenCoordsR(pos.x, pos.y, target.x, target.y), 200.-dist).toVec3()
			setTarget(ntarget, SPEED)
		else
			setTarget(target, SPEED)
		gravityAffected = true
		
	override function update()
		super.update()
		if pos.z < terrainZ
			onGround()
				
			
			
	function onGround()
		terminate()
		AddSpecialEffect("war3mapImported\\IceSparks.mdx", pos.x, pos.y).destr()
		Entity e = Entity.first
		while e != null
			if e != this and owner != e.owner and e instanceof Child and IsPlayerEnemy( e.owner, owner ) 
				debugPrint(pos.distToVecSquared(e.pos).toString(),1)
				if pos.distToVecSquared(e.pos) < AOE
					var c = e castTo Child
					let angl = anglBetweenCoordsR(pos.x, pos.y, c.pos.x, c.pos.y)
					let factor = (300 - distanceBetweenCoords(pos.x, pos.y, c.pos.x, c.pos.y)) / 100.
					c.addVel(vec3(Cos(angl) * factor * FACTOR, Sin(angl) * factor * FACTOR, 4.))
					fx.dummy.damageTarget(c.actor, 25*factor)
					
			e = e.next
		

			
		
		
endpackage	
		
 //######################################################
 // File C:\Users\Frotty\Documents\GitHub\InWcSchneeball\wurst\spells\Snowman.wurst
 //######################################################
package Snowman
import HomingProjectile
import Entity
import Fx
import Child
import SoundHelper
import SoundQueue

constant real SPEED = 8.
constant real MELT = 192

public class SnowmanMissile extends HomingProjectile

	construct(vec3 pos, player owner, vec2 target)
		super(pos, owner, 16., anglBetweenCoordsR(pos.x, pos.y, target.x, target.y), "Abilities\\Weapons\\FrostWyrmMissile\\FrostWyrmMissile.mdl")
		fx.setOwner(owner, false).setScale(.7)
		real dst = 0.
		Child chld = null
		for c in childs
			if not IsPlayerAlly(c.owner, owner)  and c.owner != owner
				if dst == 0.
					chld = c
					dst = distanceBetweenCoords(c.pos.x, c.pos.y, target.x, target.y)
				else
					let dist = distanceBetweenCoords(c.pos.x, c.pos.y, target.x, target.y)
					if dist < dst
						dst = dist
						chld = c
		setHomingTarget(chld)
		homingType = HOMING.angular
		homingSpeed = 0.03
		setTimed(6.)
		setXYSpeed(SPEED)
		throwSound.playOnPoint(pos)

		
	override function update()
		super.update()
		var chld = target castTo Child

		debugPrint(pos.toString(),1)					
		Entity e = Entity.first
		while e != null
			if e instanceof Child and e != this and owner != e.owner and IsPlayerEnemy( e.owner, owner )
				if pos.distToVecSquared(e.pos) < (e.radius+radius).squared()
					onHit(e)
					
			e = e.next
			
			
	function onHit(Entity e)
		Child chl = e castTo Child
		if chl.snowman == null
			new SnowmanDummy(vec3(pos.x, pos.y, 0.), owner, e castTo Child)
		else
			chl.snowman.melttime = MELT
		terminate()

		
public class SnowmanDummy extends Entity
	Fx fx
	real melttime = MELT
	Child target
	
	construct(vec3 pos, player owner, Child target )
		super(pos, owner, 0.)
		fx = new Fx(pos, target.actor.getFacing(), "Doodads\\Icecrown\\Props\\SnowMan\\SnowMan.mdl")
		fx.setScale(1.4)
		AddSpecialEffect("Abilities\\Spells\\Human\\Polymorph\\PolyMorphTarget.mdl", pos.x, pos.y).destr()
		this.target = target
		PauseUnit(target.actor, true)
		target.snowman = this
		target.actor.setVertexColor(155,155,255,255)
		SetUnitTimeScale(target.actor, 0)
		
	override function update()
		melttime--

		if target.actor.getHP() > .405
			pos = target.pos
			if target.vel.z > 0.
				target.vel.z = 0.
			fx.setPos(pos.toVec2())
			fx.dummy.damageTarget(target.actor, .1).setVertexColor(255,255,255,melttime.toInt()+28)
			if melttime < 0
				terminate()
		else
			terminate()

	ondestroy
		fx.hiddenDestroy()
		PauseUnit(target.actor, false)
		target.actor.setVertexColor(255,255,255,255)
		target.snowman = null
		SetUnitTimeScale(target.actor, 1.)
	
Sound throwSound

	
init
	throwSound = new Sound("Abilities\\Spells\\Other\\FrostBolt\\FrostBoltLaunch1.wav", 1100, false, true, true, 10, 10, "CombatSoundsEAX")
		
endpackage	
		
 //######################################################
 // File C:\Users\Frotty\Documents\GitHub\InWcSchneeball\wurst\units\Child.wurst
 //######################################################
package Child
import PhysicsEntity
import EventHandling
import Terrain
import HomingProjectile
import Entity
import Snowball
import GameConstants
import Snowbomb
import PlayerData
import Rollingball
import KillStreaks
import Snowman
import IceWall
import Iceshard
import LinkedList
import ItemHandling
import TimedBar
import MapBounds

public LinkedList<Child> childs = new LinkedList<Child>()


public constant real SX1 = -2400.
public constant real SY1 = 4100
public constant real SX2 = 2220
public constant real SY2 = 4100


public class Child extends PhysicsUnitEntity
	trigger t
	boolean fixPos = false
	TimedBar wrapBar
	SnowmanDummy snowman
	
	construct( vec3 pos, player owner, int id)
		super(pos, CreateUnit(owner, id, pos.x, pos.y, pos.z), 52.)
		childs.add(this)
		restitution = .25
		friction = 0.75
		actor.registerCastEvent(Condition(function Child.onCast))
		t = CreateTrigger()
		t.registerUnitEvent(actor, EVENT_UNIT_DEATH)
		t.addAction(function Child.onDeath)
		
		
	static function onCast() returns boolean
		var id = GetSpellAbilityId()
		var data = GetTriggerUnit().getUserData() castTo Child
		var tx = GetSpellTargetX()
		var ty = GetSpellTargetY()
		var tz = getTerrainZ(tx,ty)
		let angl = anglBetweenCoordsR(data.pos.x, data.pos.y, tx, ty)
		switch id
			case 'A000'
				new Snowball(vec3(data.actor.getX(), data.actor.getY(), data.pos.z+16.), data.owner, angl )
			case 'A001'
				debugPrint("casted", 1)
				new Snowbomb(vec3(data.pos.x, data.pos.y, data.pos.z+16.), data.owner, vec3(tx, ty, tz ))
				for int i = 0 to 5
					var uit = UnitItemInSlot(data.actor, i)
					if GetItemTypeId(uit) == 'I006'
						debugPrint("MISSILE FOUND", 1)
						if GetItemCharges(uit) <= 1
							RemoveItem(uit)
							if not UnitHasItemOfTypeBJ(data.actor, 'I006')
								data.actor.removeAbility('A001')
						else
							SetItemCharges(uit,GetItemCharges(uit) -1)
						break
			case 'A002'
				new Rollingball(vec3(data.pos.x + Cos(angl) * 16., data.pos.y + Sin(angl) * 16., data.pos.z +16.), data.owner, angl )
				for int i = 0 to 5
					var uit = UnitItemInSlot(data.actor, i)
					if GetItemTypeId(uit) == 'I004'
						debugPrint("MISSILE FOUND", 1)
						if GetItemCharges(uit) <= 1
							RemoveItem(uit)
							if not UnitHasItemOfTypeBJ(data.actor, 'I004')
								data.actor.removeAbility('A002')
						else
							SetItemCharges(uit,GetItemCharges(uit) -1)
						break
			case 'A003'
				new SnowmanMissile(vec3(data.pos.x, data.pos.y, data.pos.z+40.), data.owner, vec2(tx, ty) )
				for int i = 0 to 5
					var uit = UnitItemInSlot(data.actor, i)
					if GetItemTypeId(uit) == 'I005'
						debugPrint("MISSILE FOUND", 1)
						if GetItemCharges(uit) <= 1
							RemoveItem(uit)
							if not UnitHasItemOfTypeBJ(data.actor, 'I005')
								data.actor.removeAbility('A003')
						else
							SetItemCharges(uit,GetItemCharges(uit) -1)
						break
			case 'A004'
				new IceMissile(vec3(data.actor.getX(), data.actor.getY(), data.pos.z+16.), data.owner, vec3(tx,ty,tz))
				for int i = 0 to 5
					var uit = UnitItemInSlot(data.actor, i)
					if GetItemTypeId(uit) == 'I003'
						debugPrint("MISSILE FOUND", 1)
						if GetItemCharges(uit) <= 1
							RemoveItem(uit)
							if not UnitHasItemOfTypeBJ(data.actor, 'I003')
								data.actor.removeAbility('A004')
						else
							SetItemCharges(uit,GetItemCharges(uit) -1)
						break
			case 'A008'
				new Iceshard(vec3(data.actor.getX(), data.actor.getY(), data.pos.z+16.), data.owner, angl )
				for int i = 0 to 5
					var uit = UnitItemInSlot(data.actor, i)
					if GetItemTypeId(uit) == 'I00E'
						debugPrint("MISSILE FOUND", 1)
						if GetItemCharges(uit) <= 1
							RemoveItem(uit)
							if not UnitHasItemOfTypeBJ(data.actor, 'I00E')
								data.actor.removeAbility('A008')
						else
							SetItemCharges(uit,GetItemCharges(uit) -1)
						break
				
		return false
		
	static function onDeath()
		var p = GetKillingUnit().getOwner()
		var p2 = GetDyingUnit().getOwner()
		var chld = GetDyingUnit().getUserData()castTo Child
		if chld.wrapBar != null
			chld.wrapBar.terminate()
		adjustKills(p, p2)
		timer t = getTimer()
		t.setData(GetDyingUnit().getUserData()).start(7., function Child.revive)
		removeallspell(chld.actor)
				
	static function revive()
			var t = GetExpiredTimer()
			Child c = t.getData() castTo Child
			
			if c.owner.getId() > 5
				ReviveHero(c.actor, SX2 + 64 * c.owner.getId(), SY2, false)
				c.setNewPos(vec3(SX2 + 64 * c.owner.getId(), SY2, 530.))
			else
				ReviveHero(c.actor, SX1 + 64 * c.owner.getId(), SY1, false)
				c.setNewPos(vec3(SX1 + 64 * c.owner.getId(), SY1, 530.))
			c.setVel(vec3(0,0,0))
			c.actor.setVertexColor(255,255,255,255)
			SetUnitPropWindow(c.actor,60)
			t.release()	
			if GetLocalPlayer() == c.owner
				PanCameraToTimed(c.actor.getX(), c.actor.getY(), 1.)
				ClearSelection()
				SelectUnit(c.actor, true)

	override function update()
		pos.x = actor.getX()
		pos.y = actor.getY()
		if not pos.toVec2().inBounds()
			printError("Child out of Bounds")
			pos = vec3(0,3600,200)
			vel = vec3(0,0,0)
			actor.setPos(pos.toVec2())
		super.update()
		
		if fixPos
			actor.setPos(pos.toVec2())
			fixPos = false
		else
			actor.setXY(pos.toVec2())
		actor.setFlyHeight(pos.z-terrainZ, 0.)
		
	override function onGround()
		super.onGround()
		if vel.lengthSquared() > 4.
			if not isTerrainWalkable(pos.x, pos.y)
				vel += getBounceVec(vel.toVec2(),getPathingNormal(pos.toVec2())).withZ(0)
				fixPos = true
		
public function getPathingNormal(vec2 pos) returns vec2
	int numberOfTests = 12
	real radius = 64
	vec2 addedVecs = vec2(0, 0)
	for int i = 1 to numberOfTests
		vec2 direction = vec2(0,0).polarOffset(i*2*bj_PI/numberOfTests, radius)
		vec2 testPoint = pos + direction
		if isTerrainWalkable(testPoint.x, testPoint.y)
			addedVecs += direction
	return addedVecs.setLength(1.) * (-1.)
	
public function getBounceVec(vec2 vel2, vec2 nor2) returns vec2
		vec3 vel3 = vel2.toVec3()
		vec3 nor3 = nor2.toVec3()
		vec3 pv3 = vel3.project(nor3)
		vec2 pv2 = pv3.toVec2()
		pv2 *= (-1.4)
		return pv2

		
endpackage	
		
		 //######################################################
 // File C:\Users\Frotty\Documents\GitHub\WurstScript\Wurstpack\.\wurstscript\lib\Wurst.wurst
 //######################################################
// This is the package which is imported into any other package ...
package Wurst

	import public Group
	import public Real
	import public Integer
	import public PrintingHelper
	import public Unit
	import public Multiboard
	import public Basics
	import public Hashtable
	import public Unittype
	import public Maths
	import public Table
	import public Trigger
	import public Primitives
	import public String
	import public Effect
	import public Rect
	import public TimerUtils
	import public Camera
	import public Player
	import public Item
	import public Sound
	import public Vectors
	
endpackage
 //######################################################
 // File C:\Users\Frotty\Documents\GitHub\WurstScript\Wurstpack\.\wurstscript\lib\small helpers\MapBounds.wurst
 //######################################################
package MapBounds
	import Vectors
 
	public real minx = GetRectMinX( GetPlayableMapRect())
	public real miny = GetRectMinY( GetPlayableMapRect())
	public real maxx = GetRectMaxX( GetPlayableMapRect())
	public real maxy = GetRectMaxY( GetPlayableMapRect())
 
	public function vec2.inBounds() returns boolean
		return this.x > minx and this.x < maxx and this.y > miny and  this.y < maxy
 
	public function randomPointOnMap() returns vec2
		return vec2(GetRandomReal(minx,maxx), GetRandomReal(miny, maxy))
 
endpackage //######################################################
 // File C:\Users\Frotty\Documents\GitHub\WurstScript\Wurstpack\.\wurstscript\lib\math\Vectors.wurst
 //######################################################
package Vectors
	import NoWurst
	import PrintingHelper
	import Maths
	import Real
	
	/*************************
	 ********3D-Vector********
	 *************************/
	public tuple vec3( real x, real y, real z )
	
	public function vec3.setLength( real length ) returns vec3
		real l = SquareRoot(this.x*this.x + this.y*this.y + this.z*this.z)
		if l == 0.0
			printError("vector.setLength error: The length of the vector is 0.0!")
			return vec3(0.,0.,0.)
		l = length/l
		return vec3(this.x*l, this.y*l, this.z*l)

	// op_ - Operator overloading
	public function vec3.op_plus( vec3 v )	returns vec3
		return vec3(this.x + v.x, this.y + v.y, this.z + v.z)
	
	public function vec3.op_plus( vec2 v )	returns vec3
		return vec3(this.x + v.x, this.y + v.y, this.z)
	
	public function vec3.op_minus( vec3 v )	returns vec3
		return vec3(this.x - v.x, this.y - v.y, this.z - v.z)
		
	public function vec3.op_mult(real factor) returns vec3
		return vec3(this.x*factor, this.y*factor, this.z*factor) 
		
	public function vec3.addReals( real x, real y, real z )	returns vec3
		return vec3(this.x + x, this.y + y, this.z + z)
	
	public function vec3.subVec2( vec2 v )	returns vec3
		return vec3(this.x - v.x, this.y - v.y, this.z)
			
	public function vec3.scaleXY( real factor )	returns vec3
		return vec3(this.x * factor, this.y * factor, this.z)
		
	public function vec3.cross( vec3 v ) returns vec3
		return vec3( this.y*v.z-this.z*v.y, this.z*v.x-this.x*v.z, this.x*v.y-this.y*v.x ) 
		
	public function vec3.dot( vec3 v ) returns real
		return this.x*v.x + this.y*v.y + this.z*v.z
				
	public function vec3.project( vec3 direction ) returns vec3
		real l = direction.x*direction.x+direction.y*direction.y+direction.z*direction.z
		if l == 0.0
			printError("vector.projectVector error: The length of the direction vector is 0.0!")
			return vec3(0.,0.,0.)
			
		l = (this.x*direction.x+this.y*direction.y+this.z*direction.z) / l
		return vec3( direction.x*l, direction.y*l, direction.z*l )
		
	public function vec3.norm() returns vec3
		real len = this.length()
		real x = 0 
		real y = 0
		real z = 0
		if (len != 0.0)
			x = (this.x / len)
			y = (this.y / len)
			z = (this.z / len)
		return vec3(x,y,z)
	

	public function vec3.trim( real value ) returns vec3
		vec3 result = this
		if result.x > -value and result.x < value
			result.x = 0.
		if result.y > -value and result.y < value
			result.y = 0.
		if result.z > -value and result.z < value
			result.z = 0.
		return result
		
	public function vec3.toVec2() returns vec2
		return vec2( this.x, this.y )		
		
	public function vec3.length() returns real
		return SquareRoot(this.x*this.x+this.y*this.y+this.z*this.z)
		
	public function vec3.lengthSquared() returns real
		return this.x*this.x+this.y*this.y+this.z*this.z
		
	public function vec3.lengthXY() returns real
		return SquareRoot(this.x*this.x+this.y*this.y)
			
	public function vec3.inCircle( vec3 v2, real radius ) returns boolean
		if (this.x-v2.x).squared() + (this.y-v2.y).squared() <= radius*radius
			return true
		return false
		
	public function vec3.distToVec( vec3 v ) returns real
		return SquareRoot((v.x - this.x).squared() + (v.y - this.y).squared() + (v.z - this.z).squared())
		
	public function vec3.distToVecSquared( vec3 v ) returns real
		return (v.x - this.x).squared() + (v.y - this.y).squared() + (v.z - this.z).squared()
		
	public function vec3.toString() returns string
		return "Vector3 [ " + this.x.toString() + ", " + this.y.toString() + ", " + this.z.toString() + " ]"
	
	public function vec3.rotate( vec3 axis, real angl ) returns vec3 //angl is taken in radians
		var al = axis.x*axis.x+axis.y*axis.y+axis.z*axis.z //axis length^2
		var c = Cos(angl)
		var s = Sin(angl)
		if al == 0.0
			printError("vector.rotate error: The length of the axis vector is 0.0!")
			return vec3(0,0,0)

		var f = (this.x*axis.x+this.y*axis.y+this.z*axis.z) / al
		var zx = axis.x*f
		var zy = axis.y*f
		var zz = axis.z*f //axis component of rotated vector
		var xx = this.x-zx
		var xy = this.y-zy
		var xz = this.z-zz //component of vector perpendicular to axis
		al = SquareRoot(al)
		var yx = (axis.y*xz - axis.z*xy)/al
		var yy = (axis.z*xx - axis.x*xz)/al //y same length as x by using cross product and dividing with axis length
		var yz = (axis.x*xy - axis.y*xx)/al //x,y - coordinate system in which we rotate
		return vec3(xx*c+yx*s+zx, xy*c+yy*s+zy, xz*c+yz*s+zz )

	
		
	/*************************
	 ********2D-Vector********
	 *************************/
	public tuple vec2( real x, real y )
			
	public function vec2.op_plus( vec2 v )	returns vec2
		return vec2(this.x + v.x, this.y + v.y)
	
	public function vec2.op_minus( vec2 v )	returns vec2
		return vec2(this.x - v.x, this.y - v.y)
		
	public function vec2.op_mult(real factor) returns vec2
		return vec2(this.x*factor, this.y*factor) 
		
	public function vec2.addReals( real x, real y )	returns vec2
		return vec2(this.x + x, this.y + y)
	
	public function vec2.toVec3() returns vec3
		return vec3( this.x, this.y, 0. )
		
	public function vec2.dot( vec2 v ) returns real
		return this.x*v.x+this.y*v.y
	
	public function vec2.norm() returns vec2
		real len = this.length()
		real x = 0 
		real y = 0
		if (len != 0.0)
			x = (this.x / len)
			y = (this.y / len)
		return vec2(x,y)
	
	public function vec2.trim( real value ) returns vec2
		vec2 result = this
		if result.x > -value and result.x < value
			result.x = 0.
		if this.y > -value and this.y < value
			result.y = 0.
		return result
		
	public function vec2.length() returns real
		return SquareRoot(this.x*this.x+this.y*this.y)
		
	public function vec2.lengthSquared() returns real
		return this.x*this.x+this.y*this.y
		
	public function vec2.inCircle( vec2 v2, real radius ) returns boolean
		if (this.x-v2.x).squared() + (this.y-v2.y).squared() <= radius*radius
			return true
		return false
		
	public function vec2.toString() returns string
		return "Vector2 [ " + this.x.toString() + ", " + this.y.toString() + " ]"
	
	public function unit.getPos() returns vec2
		return vec2(GetUnitX(this), GetUnitY(this)) 
	 	
	public function vec2.anglTo(vec2 v) returns real
		return Atan2(v.y - this.y, v.x - this.x) 
		
	public function vec2.polarOffset(real angl, real dist) returns vec2
		return vec2(this.x + Cos(angl)*dist, this.y + Sin(angl)*dist)
		
	public function vec2.setLength( real length ) returns vec2
		real l = SquareRoot(this.x*this.x + this.y*this.y)
		if l == 0.0
			printError("vector.setLength error: The length of the vector is 0.0!")
			return vec2(0.,0.)
		l = length/l
		return vec2(this.x*l, this.y*l)
		
	public function vec2.withZ(real z) returns vec3
		return vec3(this.x, this.y, z)
		
	public function vec2.distToVec( vec2 v ) returns real
		return SquareRoot((v.x - this.x).squared() + (v.y - this.y).squared())
		
	public function vec2.distToVecSquared( vec2 v ) returns real
		return (v.x - this.x).squared() + (v.y - this.y).squared()
		 
	public function vec2.distToSegmentSquared( vec2 v1, vec2 v2) returns real
		var l2 = v1.distToVecSquared(v2)
		if l2 == 0 
			return this.distToVecSquared(v1)
		var t = ((this.x - v1.x) * (v2.x - v1.x) + (this.y - v1.y) * (v2.y - v1.y)) / l2
		if (t < 0) 
			return this.distToVecSquared(v1)
		if (t > 1) 
			return this.distToVecSquared(v2)
		return this.distToVecSquared( vec2( v1.x + t * (v2.x - v1.x), v1.y + t * (v2.y - v1.y) ) )
	
endpackage 
 //######################################################
 // File C:\Users\Frotty\Documents\GitHub\WurstScript\Wurstpack\.\wurstscript\lib\PrintingHelper.wurst
 //######################################################
package PrintingHelper
	import NoWurst
	
	int DEBUG_LEVEL = 4
	real DEBUG_MSG_DURATION = 60.
	
	public function setDebugLvl( int value )
		DEBUG_LEVEL = value
		
	public function setDebugMsgDuration( real value )
		DEBUG_MSG_DURATION = value
	
	public function debugPrint(string msg, int level)
		if level >= DEBUG_LEVEL
			print("|cff9C9C9CDEBUG - |r" + msg)
			
	public function print(string msg)
		DisplayTimedTextToPlayer(GetLocalPlayer(), 0., 0., DEBUG_MSG_DURATION, msg)

	public function printNote(string msg)
		DisplayTimedTextToPlayer(GetLocalPlayer(), 0., 0., DEBUG_MSG_DURATION, "|cffFFFF00[NOTIFICATION]|r - " + msg)

	public function printWarning(string msg)
		DisplayTimedTextToPlayer(GetLocalPlayer(), 0., 0., DEBUG_MSG_DURATION, "|cffFF8000[WARNING]|r - " + msg)

	public function printError(string msg)
		DisplayTimedTextToPlayer(GetLocalPlayer(), 0., 0., DEBUG_MSG_DURATION, "|cffFF0000[ERROR]|r - " + msg)
		
	public function printTimed(string msg, real duration)
		DisplayTimedTextToPlayer(GetLocalPlayer(), 0., 0., duration, msg)

	public function boolean.toString() returns string
		if this
			return "true"
		return "false"
endpackage 
 //######################################################
 // File C:\Users\Frotty\Documents\GitHub\WurstScript\Wurstpack\.\wurstscript\lib\math\Maths.wurst
 //######################################################
package Maths	
	import NoWurst
	import Vectors

	public constant real PI			=  3.141592654
	public constant real PI2 		=  6.28318
	public constant real DEGTORAD  	=  0.017453293
	public constant real RADTODEG  	= 57.295779513
	
	public function polarProjectionXR ( real x,  real dist, real angl ) returns real
		return x + dist * Cos(angl)
	
	public function polarProjectionYR ( real y,  real dist, real angl ) returns real
		return y + dist * Sin(angl)
		
	public function polarProjectionZR ( real z,  real dist, real angl ) returns real
		return z + dist * Sin(angl)
		
	public function polarProjectionXD ( real x,  real dist, real angl ) returns real
		return x + dist * Cos(angl * DEGTORAD)
	
	public function polarProjectionYD ( real y,  real dist, real angl ) returns real
		return y + dist * Sin(angl * DEGTORAD)
		
	public function polarProjectionZD ( real z,  real dist, real angl ) returns real
		return z + dist * Sin(angl * DEGTORAD)
	
	public function anglBetweenCoordsD ( real x1, real y1, real x2, real y2 ) returns real
		return RADTODEG * Atan2(y2 - y1, x2 - x1)
		
	public function anglBetweenCoordsR ( real x1, real y1, real x2, real y2 ) returns real
		return Atan2(y2 - y1, x2 - x1)
		

	public function distanceBetweenCoords ( real x1, real y1, real x2, real y2 ) returns real
		return SquareRoot((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1))
		
	public function getSlopeangl( real z1, real z2, real dist ) returns real
		return Atan2(z2-z1, dist )
		
	public function polarProjection3d( vec3 pos, real distance, real anglGround, real anglAir ) returns vec3
		real x = pos.x + distance * Cos(anglGround) * Sin(anglAir)
		real y = pos.y + distance * Sin(anglGround) * Sin(anglAir)
		real z = pos.z + distance * Cos(anglAir) 
		return vec3(x,y,z)
		
	public function anglToVector( real angl ) returns vec2
		return vec2(Cos(angl), Sin(angl))
		
	public function vectorToangl( vec2 v ) returns real
		return Atan2(v.y, v.x)
		

endpackage

 //######################################################
 // File C:\Users\Frotty\Documents\GitHub\WurstScript\Wurstpack\.\wurstscript\lib\primitives\Real.wurst
 //######################################################
package Real
	import NoWurst
	
	public function real.abs() returns real
		if this >= 0
			return this
		else
			return -this

	public function real.squared() returns real
		return this*this
			
	public function real.sign() returns real
		if this > 0.0
			return 1.0
		else if this < 0.0
			return -1.0
		else
			return 0.0

	public function real.toInt() returns int
		return R2I(this)
	
	public function real.toString() returns string
		return R2S(this)
		
	public function real.acos() returns real
		return Acos(this)
		
	public function real.asin() returns real
		return Asin(this)

	public function real.atan() returns real
		return Atan(this)
		
	public function real.cos() returns real
		return Cos(this)
		
	public function real.sin() returns real
		return Sin(this)
		
endpackage
 //######################################################
 // File C:\Users\Frotty\Documents\GitHub\WurstScript\Wurstpack\.\wurstscript\lib\TimerUtils.wurst
 //######################################################
package TimerUtils
	import NoWurst
	import Table
// 
//	Credits: 
//		* Vexorian (original TimerUtils + TimedLoop)
//		* Nestharus (orignial Constant Timer Loop 32)
	
	// basic TimerUtils functions with Timer-Pool and setData/getData functions
		
	timer array freeTimers
	int freeTimersCount = 0
	Table timerData = new Table()
	
	/** Get a new timer. Use this instead of "CreateTimer".
	You can attach data to the timer with .setData and retrieve it with .getData
	If you're done with the timer, release it with .release */
	public function getTimer() returns timer
		if freeTimersCount > 0
			freeTimersCount -= 1
			return freeTimers[freeTimersCount]
		else
			return CreateTimer()
			
	/** Attach Data to this timer */
	public function timer.setData(integer data) returns timer
		timerData.saveInt( GetHandleId(this), data )
		return this
		
	/** Retrieve the data attached to this timer */
	public function timer.getData() returns integer
		return timerData.loadInt( GetHandleId(this) )

	/** Release the timer. Use this instead of "DestroyTimer" ! */
	public function timer.release()
		this.pause()
		freeTimers[freeTimersCount] = this
		freeTimersCount++
	
	public function timer.pause()
		PauseTimer(this)
		
	public function timer.resume()
		ResumeTimer(this)
	
	public function timer.start(real time, code timerCallBack) returns timer
		TimerStart(this, time, false, timerCallBack)
		return this
		
	public function timer.startPeriodic(real time, code timerCallBack) returns timer
		TimerStart(this, time, true, timerCallBack)
		return this
	
	// module to execute a function after a certain time
	public module Timed
		abstract function onTimer()
		
		private static function timerCallback()
			timer t = GetExpiredTimer()
			thistype c = t.getData() castTo thistype
			c.onTimer()
			t.release()
		
		function startTimer(real time)
			timer t = getTimer()
			t.setData(this castTo integer)
			TimerStart(t, time, false, function timerCallback)
	
	// module to execute a function periodically
	public module Periodic
	
		private timer t
	
		abstract function periodic()
		
		function stopPeriodic()
			t.release()
			t = null
		
		private static function timerCallback()
			timer t = GetExpiredTimer()
			thistype c = t.getData() castTo thistype
			c.periodic()
		
		function startPeriodic(real time)
			t = getTimer()
			t.setData(this castTo integer)
			TimerStart(t, time, true, function timerCallback)
	
	
endpackage


 //######################################################
 // File C:\Users\Frotty\Documents\GitHub\WurstScript\Wurstpack\.\wurstscript\lib\data structures\Table.wurst
 //######################################################
package Table
	import NoWurst
	import Hashtable
	
	hashtable ht = InitHashtable()
	
	public class Table
		
		function loadInt( int parentKey ) returns int
			return ht.loadInt(this castTo int, parentKey)
		
		function saveInt( int parentKey, int value )
			ht.saveInt(this castTo int, parentKey, value)

		function hasInt( int parentKey ) returns boolean
			return ht.hasInt(this castTo int, parentKey)
		
		function removeInt( integer parentKey )
			RemoveSavedInteger(ht, this castTo int, parentKey)
			
		function loadReal( int parentKey ) returns real
			return ht.loadReal(this castTo int, parentKey)
		
		function saveReal( int parentKey, real value )
			ht.saveReal(this castTo int, parentKey, value)
			
		function loadString( int parentKey ) returns string
			return ht.loadString(this castTo int, parentKey)
		
		function saveString( int parentKey, string value )
			ht.saveString(this castTo int, parentKey, value)

		function hasReal( int parentKey ) returns boolean
			return ht.hasReal(this castTo int, parentKey)
		
		function removeReal( integer parentKey )
			RemoveSavedReal(ht, this castTo int, parentKey)
		
		function removeHandle( integer parentKey )
			RemoveSavedHandle(ht, this castTo int, parentKey)
			
		function loadPlayer( int parentKey ) returns player
			return ht.loadPlayerHandle( this castTo int, parentKey )
		
		function savePlayer( int parentKey, player value )
			ht.savePlayerHandle( this castTo int, parentKey, value )
		
		function loadWidget( int parentKey ) returns widget
			return ht.loadWidgetHandle( this castTo int, parentKey )
		
		function saveWidget( int parentKey, widget value )
			ht.saveWidgetHandle( this castTo int, parentKey, value )
		
		function loadUnit( int parentKey ) returns unit
			return ht.loadUnitHandle( this castTo int, parentKey )
		
		function saveUnit( int parentKey, unit value )
			ht.saveUnitHandle( this castTo int, parentKey, value )
		
		function loadDestructable( int parentKey ) returns destructable
			return ht.loadDestructableHandle( this castTo int, parentKey )
		
		function saveDestructable( int parentKey, destructable value )
			ht.saveDestructableHandle( this castTo int, parentKey, value )
		
		function loadItem( int parentKey ) returns item
			return ht.loadItemHandle( this castTo int, parentKey )
		
		function saveItem( int parentKey, item value )
			ht.saveItemHandle( this castTo int, parentKey, value )
		
		function loadAbility( int parentKey ) returns ability
			return ht.loadAbilityHandle( this castTo int, parentKey )
		
		function saveAbility( int parentKey, ability value )
			ht.saveAbilityHandle( this castTo int, parentKey, value )
		
		function loadForce( int parentKey ) returns force
			return ht.loadForceHandle( this castTo int, parentKey )
		
		function saveForce( int parentKey, force value )
			ht.saveForceHandle( this castTo int, parentKey, value )
		
		function loadGroup( int parentKey ) returns group
			return ht.loadGroupHandle( this castTo int, parentKey )
		
		function saveGroup( int parentKey, group value )
			ht.saveGroupHandle( this castTo int, parentKey, value )
		
		function loadTrigger( int parentKey ) returns trigger
			return ht.loadTriggerHandle( this castTo int, parentKey )
		
		function saveTrigger( int parentKey, trigger value )
			ht.saveTriggerHandle( this castTo int, parentKey, value )
				
		function loadTimer( int parentKey ) returns timer
			return ht.loadTimerHandle( this castTo int, parentKey )
		
		function saveTimer( int parentKey, timer value )
			ht.saveTimerHandle( this castTo int, parentKey, value )
		
		function loadLocation( int parentKey ) returns location
			return ht.loadLocationHandle( this castTo int, parentKey )
		
		function saveLocation( int parentKey, location value )
			ht.saveLocationHandle( this castTo int, parentKey, value )
		
		function loadRegion( int parentKey ) returns region
			return ht.loadRegionHandle( this castTo int, parentKey )
		
		function saveRegion( int parentKey, region value )
			ht.saveRegionHandle( this castTo int, parentKey, value )
		
		function loadRect( int parentKey ) returns rect
			return ht.loadRectHandle( this castTo int, parentKey )
		
		function saveRect( int parentKey, rect value )
			ht.saveRectHandle( this castTo int, parentKey, value )
		
		function loadSound( int parentKey ) returns sound
			return ht.loadSoundHandle( this castTo int, parentKey )
		
		function saveSound( int parentKey, sound value )
			ht.saveSoundHandle( this castTo int, parentKey, value )
				
		function loadEffect( int parentKey ) returns effect
			return ht.loadEffectHandle( this castTo int, parentKey )
		
		function saveEffect( int parentKey, effect value )
			ht.saveEffectHandle( this castTo int, parentKey, value )
				
		function loadDialog( int parentKey ) returns dialog
			return ht.loadDialogHandle( this castTo int, parentKey )
		
		function saveDialog( int parentKey, dialog value )
			ht.saveDialogHandle( this castTo int, parentKey, value )
		
		function loadButton( int parentKey ) returns button
			return ht.loadButtonHandle( this castTo int, parentKey )
		
		function saveButton( int parentKey, button value )
			ht.saveButtonHandle( this castTo int, parentKey, value )
		
		function loadQuest( int parentKey ) returns quest
			return ht.loadQuestHandle( this castTo int, parentKey )
		
		function saveQuest( int parentKey, quest value )
			ht.saveQuestHandle( this castTo int, parentKey, value )
				
		function loadLeaderboard( int parentKey ) returns leaderboard
			return ht.loadLeaderboardHandle( this castTo int, parentKey )
		
		function saveLeaderboard( int parentKey, leaderboard value )
			ht.saveLeaderboardHandle( this castTo int, parentKey, value )
		
		function loadMultiboard( int parentKey ) returns multiboard
			return ht.loadMultiboardHandle( this castTo int, parentKey )
		
		function saveMultiboard( int parentKey, multiboard value )
			ht.saveMultiboardHandle( this castTo int, parentKey, value )
		
		function loadTrackable( int parentKey ) returns trackable
			return ht.loadTrackableHandle( this castTo int, parentKey )
		
		function saveTrackable( int parentKey, trackable value )
			ht.saveTrackableHandle( this castTo int, parentKey, value )
		
		function loadLightning( int parentKey ) returns lightning
			return ht.loadLightningHandle( this castTo int, parentKey )
		
		function saveLightning( int parentKey, lightning value )
			ht.saveLightningHandle( this castTo int, parentKey, value )
				
		function loadImage( int parentKey ) returns image
			return ht.loadImageHandle( this castTo int, parentKey )
		
		function saveImage( int parentKey, image value )
			ht.saveImageHandle( this castTo int, parentKey, value )
		
		function loadUbersplat( int parentKey ) returns ubersplat
			return ht.loadUbersplatHandle( this castTo int, parentKey )
		
		function saveUbersplat( int parentKey, ubersplat value )
			ht.saveUbersplatHandle( this castTo int, parentKey, value )
		
					
		//Remove all data from a Table instance
		function flush()
			FlushChildHashtable(ht, this castTo int)

		ondestroy
			this.flush()
	
endpackage  //######################################################
 // File C:\Users\Frotty\Documents\GitHub\WurstScript\Wurstpack\.\wurstscript\lib\handles\Hashtable.wurst
 //######################################################
package Hashtable
	import NoWurst

	public function hashtable.hasBoolean( integer parentKey, integer childKey ) returns boolean
		return HaveSavedBoolean( this, parentKey, childKey )

	public function hashtable.hasHandle( integer parentKey, integer childKey ) returns boolean
		return HaveSavedHandle( this, parentKey, childKey )

	public function hashtable.hasInt( int parentKey, int childKey ) returns boolean
		return HaveSavedInteger( this, parentKey, childKey )

	public function hashtable.hasReal( integer parentKey, integer childKey ) returns boolean
		return HaveSavedReal( this, parentKey, childKey )
	
	public function hashtable.hasString( integer parentKey, integer childKey ) returns boolean
		return HaveSavedString( this, parentKey, childKey )

	public function hashtable.loadAbilityHandle( integer parentKey, integer childKey ) returns ability
		return LoadAbilityHandle( this, parentKey, childKey )

	public function hashtable.loadBoolean( integer parentKey, integer childKey ) returns boolean
		return LoadBoolean( this, parentKey, childKey )

	public function hashtable.loadBooleanExprHandle( integer parentKey, integer childKey ) returns boolexpr
		return LoadBooleanExprHandle( this, parentKey, childKey )

	public function hashtable.loadButtonHandle( integer parentKey, integer childKey ) returns button
		return LoadButtonHandle( this, parentKey, childKey )

	public function hashtable.loadDefeatConditionHandle( integer parentKey, integer childKey ) returns defeatcondition
		return LoadDefeatConditionHandle( this, parentKey, childKey )

	public function hashtable.loadDestructableHandle( integer parentKey, integer childKey ) returns destructable
		return LoadDestructableHandle( this, parentKey, childKey )

	public function hashtable.loadDialogHandle( integer parentKey, integer childKey ) returns dialog
		return LoadDialogHandle( this, parentKey, childKey )
		
	public function hashtable.loadEffectHandle( integer parentKey, integer childKey ) returns effect
		return LoadEffectHandle( this, parentKey, childKey )

	public function hashtable.loadForceHandle( integer parentKey, integer childKey ) returns force
		return LoadForceHandle( this, parentKey, childKey )

	public function hashtable.loadGroupHandle( integer parentKey, integer childKey ) returns group
		return LoadGroupHandle( this, parentKey, childKey )

	public function hashtable.loadInt( int parentKey, int childKey ) returns int
		return LoadInteger( this, parentKey, childKey )

	public function hashtable.loadItemPoolHandle( integer parentKey, integer childKey ) returns itempool
		return LoadItemPoolHandle( this, parentKey, childKey )
		
	public function hashtable.loadItemHandle( integer parentKey, integer childKey ) returns item
		return LoadItemHandle( this, parentKey, childKey )

	public function hashtable.loadLeaderboardHandle( integer parentKey, integer childKey ) returns leaderboard
		return LoadLeaderboardHandle( this, parentKey, childKey )

	public function hashtable.loadFogStateHandle( integer parentKey, integer childKey ) returns fogstate
		return LoadFogStateHandle( this, parentKey, childKey )

	public function hashtable.loadLightningHandle( integer parentKey, integer childKey ) returns lightning
		return LoadLightningHandle( this, parentKey, childKey )

	public function hashtable.loadLocationHandle( integer parentKey, integer childKey ) returns location
		return LoadLocationHandle( this, parentKey, childKey )

	public function hashtable.loadImageHandle( integer parentKey, integer childKey ) returns image
		return LoadImageHandle( this, parentKey, childKey )

	public function hashtable.loadMultiboardHandle( integer parentKey, integer childKey ) returns multiboard
		return LoadMultiboardHandle( this, parentKey, childKey )

	public function hashtable.loadFogModifierHandle( integer parentKey, integer childKey ) returns fogmodifier
		return LoadFogModifierHandle( this, parentKey, childKey )

	public function hashtable.loadPlayerHandle( integer parentKey, integer childKey ) returns player
		return LoadPlayerHandle( this, parentKey, childKey )

	public function hashtable.loadQuestHandle( integer parentKey, integer childKey ) returns quest
		return LoadQuestHandle( this, parentKey, childKey )

	public function hashtable.loadQuestItemHandle( integer parentKey, integer childKey ) returns questitem
		return LoadQuestItemHandle( this, parentKey, childKey )

	public function hashtable.loadReal( integer parentKey, integer childKey ) returns real
		return LoadReal( this, parentKey, childKey )

	public function hashtable.loadRectHandle( integer parentKey, integer childKey ) returns rect
		return LoadRectHandle( this, parentKey, childKey )

	public function hashtable.loadRegionHandle( integer parentKey, integer childKey ) returns region
		return LoadRegionHandle( this, parentKey, childKey )
		
	public function hashtable.loadSoundHandle( integer parentKey, integer childKey ) returns sound
		return LoadSoundHandle( this, parentKey, childKey )
	
	public function hashtable.loadString( integer parentKey, integer childKey ) returns string
		return LoadStr( this, parentKey, childKey )
	
	public function hashtable.loadTextTagHandle( integer parentKey, integer childKey ) returns texttag
		return LoadTextTagHandle( this, parentKey, childKey )
		
	public function hashtable.loadTimerDialogHandle( integer parentKey, integer childKey ) returns timerdialog
		return LoadTimerDialogHandle( this, parentKey, childKey )
	
	public function hashtable.loadTimerHandle( integer parentKey, integer childKey ) returns timer
		return LoadTimerHandle( this, parentKey, childKey )
	
	public function hashtable.loadTrackableHandle( integer parentKey, integer childKey ) returns trackable
		return LoadTrackableHandle( this, parentKey, childKey )
		
	public function hashtable.loadTriggerActionHandle( integer parentKey, integer childKey ) returns triggeraction
		return LoadTriggerActionHandle( this, parentKey, childKey )
	
	public function hashtable.loadTriggerConditionHandle( integer parentKey, integer childKey ) returns triggercondition
		return LoadTriggerConditionHandle( this, parentKey, childKey )
		
	public function hashtable.loadTriggerEventHandle( integer parentKey, integer childKey ) returns event
		return LoadTriggerEventHandle( this, parentKey, childKey )
		
	public function hashtable.loadTriggerHandle( integer parentKey, integer childKey ) returns trigger
		return LoadTriggerHandle( this, parentKey, childKey )
	
	public function hashtable.loadUbersplatHandle( integer parentKey, integer childKey ) returns ubersplat
		return LoadUbersplatHandle( this, parentKey, childKey )
		
	public function hashtable.loadUnitHandle( integer parentKey, integer childKey ) returns unit
		return LoadUnitHandle( this, parentKey, childKey )
	
	public function hashtable.loadUnitPoolHandle( integer parentKey, integer childKey ) returns unitpool
		return LoadUnitPoolHandle( this, parentKey, childKey )
		
	public function hashtable.loadWidgetHandle( integer parentKey, integer childKey ) returns widget
		return LoadWidgetHandle( this, parentKey, childKey )
	
	public function hashtable.saveAbilityHandle( integer parentKey, integer childKey, ability value ) returns hashtable
		SaveAbilityHandle( this, parentKey, childKey, value )
		return this

	public function hashtable.saveBoolean( integer parentKey, integer childKey, boolean value ) returns hashtable
		SaveBoolean( this, parentKey, childKey, value )
		return this

	public function hashtable.saveBooleanExprHandle( integer parentKey, integer childKey, boolexpr value ) returns hashtable
		SaveBooleanExprHandle( this, parentKey, childKey, value )
		return this

	public function hashtable.saveButtonHandle( integer parentKey, integer childKey, button value ) returns hashtable
		SaveButtonHandle( this, parentKey, childKey, value )
		return this

	public function hashtable.saveDefeatConditionHandle( integer parentKey, integer childKey, defeatcondition value ) returns hashtable
		SaveDefeatConditionHandle( this, parentKey, childKey, value )
		return this

	public function hashtable.saveDestructableHandle( integer parentKey, integer childKey, destructable value ) returns hashtable
		SaveDestructableHandle( this, parentKey, childKey, value )
		return this

	public function hashtable.saveDialogHandle( integer parentKey, integer childKey, dialog value ) returns hashtable
		SaveDialogHandle( this, parentKey, childKey, value )
		return this
		
	public function hashtable.saveEffectHandle( integer parentKey, integer childKey, effect value ) returns hashtable
		SaveEffectHandle( this, parentKey, childKey, value )
		return this

	public function hashtable.saveFogModifierHandle( integer parentKey, integer childKey, fogmodifier value ) returns hashtable
		SaveFogModifierHandle( this, parentKey, childKey, value )
		return this

	public function hashtable.saveFogStateHandle( integer parentKey, integer childKey, fogstate value ) returns hashtable
		SaveFogStateHandle( this, parentKey, childKey, value )
		return this

	public function hashtable.saveForceHandle( integer parentKey, integer childKey, force value ) returns hashtable
		SaveForceHandle( this, parentKey, childKey, value )
		return this

	public function hashtable.saveGroupHandle( integer parentKey, integer childKey, group value ) returns hashtable
		SaveGroupHandle( this, parentKey, childKey, value )
		return this

	public function hashtable.saveImageHandle( integer parentKey, integer childKey, image value ) returns hashtable
		SaveImageHandle( this, parentKey, childKey, value )
		return this

	public function hashtable.saveInt( int parentKey, int childKey, int value ) returns hashtable
		SaveInteger( this, parentKey, childKey, value )
		return this

	public function hashtable.saveItemHandle( integer parentKey, integer childKey, item value ) returns hashtable
		SaveItemHandle( this, parentKey, childKey, value )
		return this

	public function hashtable.saveItemPoolHandle( integer parentKey, integer childKey, itempool value ) returns hashtable
		SaveItemPoolHandle( this, parentKey, childKey, value )
		return this

	public function hashtable.saveLeaderboardHandle( integer parentKey, integer childKey, leaderboard value ) returns hashtable
		SaveLeaderboardHandle( this, parentKey, childKey, value )
		return this

	public function hashtable.saveLightningHandle( integer parentKey, integer childKey, lightning value ) returns hashtable
		SaveLightningHandle( this, parentKey, childKey, value )
		return this

	public function hashtable.saveLocationHandle( integer parentKey, integer childKey, location value ) returns hashtable
		SaveLocationHandle( this, parentKey, childKey, value )
		return this

	public function hashtable.saveMultiboardHandle( integer parentKey, integer childKey, multiboard value ) returns hashtable
		SaveMultiboardHandle( this, parentKey, childKey, value )
		return this

	public function hashtable.savePlayerHandle( integer parentKey, integer childKey, player value ) returns hashtable
		SavePlayerHandle( this, parentKey, childKey, value )
		return this

	public function hashtable.saveQuestHandle( integer parentKey, integer childKey, quest value ) returns hashtable
		SaveQuestHandle( this, parentKey, childKey, value )
		return this

	public function hashtable.saveQuestItemHandle( integer parentKey, integer childKey, questitem value ) returns hashtable
		SaveQuestItemHandle( this, parentKey, childKey, value )
		return this

	public function hashtable.saveReal( integer parentKey, integer childKey, real value ) returns hashtable
		SaveReal( this, parentKey, childKey, value )
		return this

	public function hashtable.saveRectHandle( integer parentKey, integer childKey, rect value ) returns hashtable
		SaveRectHandle( this, parentKey, childKey, value )
		return this

	public function hashtable.saveRegionHandle( integer parentKey, integer childKey, region value ) returns hashtable
		SaveRegionHandle( this, parentKey, childKey, value )
		return this
		
	public function hashtable.saveSoundHandle( integer parentKey, integer childKey, sound value ) returns hashtable
		SaveSoundHandle( this, parentKey, childKey, value )
		return this
	
	public function hashtable.saveString( integer parentKey, integer childKey, string value ) returns hashtable
		SaveStr( this, parentKey, childKey, value )
		return this
	
	public function hashtable.saveTextTagHandle( integer parentKey, integer childKey, texttag value ) returns hashtable
		SaveTextTagHandle( this, parentKey, childKey, value )
		return this
		
	public function hashtable.saveTimerDialogHandle( integer parentKey, integer childKey, timerdialog value ) returns hashtable
		SaveTimerDialogHandle( this, parentKey, childKey, value )
		return this
	
	public function hashtable.saveTimerHandle( integer parentKey, integer childKey, timer value ) returns hashtable
		SaveTimerHandle( this, parentKey, childKey, value )
		return this
	
	public function hashtable.saveTrackableHandle( integer parentKey, integer childKey, trackable value ) returns hashtable
		SaveTrackableHandle( this, parentKey, childKey, value )
		return this
		
	public function hashtable.saveTriggerActionHandle( integer parentKey, integer childKey, triggeraction value ) returns hashtable
		SaveTriggerActionHandle( this, parentKey, childKey, value )
		return this
	
	public function hashtable.saveTriggerConditionHandle( integer parentKey, integer childKey, triggercondition value ) returns hashtable
		SaveTriggerConditionHandle( this, parentKey, childKey, value )
		return this
		
	public function hashtable.saveTriggerEventHandle( integer parentKey, integer childKey, event value ) returns hashtable
		SaveTriggerEventHandle( this, parentKey, childKey, value )
		return this
		
	public function hashtable.saveTriggerHandle( integer parentKey, integer childKey, trigger value ) returns hashtable
		SaveTriggerHandle( this, parentKey, childKey, value )
		return this
	
	public function hashtable.saveUbersplatHandle( integer parentKey, integer childKey, ubersplat value ) returns hashtable
		SaveUbersplatHandle( this, parentKey, childKey, value )
		return this
		
	public function hashtable.saveUnitHandle( integer parentKey, integer childKey, unit value ) returns hashtable
		SaveUnitHandle( this, parentKey, childKey, value )
		return this
	
	public function hashtable.saveUnitPoolHandle( integer parentKey, integer childKey, unitpool value ) returns hashtable
		SaveUnitPoolHandle( this, parentKey, childKey, value )
		return this
		
	public function hashtable.saveWidgetHandle( integer parentKey, integer childKey, widget value ) returns hashtable
		SaveWidgetHandle( this, parentKey, childKey, value )
		return this
	
	public function hashtable.flushChild(int parentKey)
		FlushChildHashtable(this, parentKey)
		
	public function hashtable.flush()
		FlushParentHashtable(this)
		
endpackage  //######################################################
 // File C:\Users\Frotty\Documents\GitHub\WurstScript\Wurstpack\.\wurstscript\lib\handles\Group.wurst
 //######################################################
package Group
	import NoWurst
	
	public function group.clear()
		GroupClear(this)
		
	// group iterators
	
	public function group.iterator() returns group
		// return a copy of the group:
		bj_groupAddGroupDest = CreateGroup()
		ForGroup(this, function GroupAddGroupEnum)
		return bj_groupAddGroupDest

	public function group.hasNext() returns boolean
		return FirstOfGroup(this) != null
		
	public function group.next() returns unit
		let u = FirstOfGroup(this)
		GroupRemoveUnit(this, u) 
		return u
		
	public function group.close()
		DestroyGroup(this)

endpackage
 //######################################################
 // File C:\Users\Frotty\Documents\GitHub\WurstScript\Wurstpack\.\wurstscript\lib\handles\Item.wurst
 //######################################################
package Item
	import NoWurst
	import public Vectors
	
	public function item.getName() returns string
		return GetItemName( this )
		
	public function item.getX() returns real
		return GetItemX( this )
			
	public function item.getY() returns real
		return GetItemY( this )
	
	public function item.setPos( real x, real y ) returns item
		SetItemPosition( this, x, y )
		return this
		
	public function item.setPos( vec2 pos ) returns item
		SetItemPosition( this, pos.x, pos.y )
		return this
		
	public function item.getUserData() returns int
		return GetItemUserData(this)
		
	public function item.setUserData(int data)
		SetItemUserData(this, data)
		
	public function item.remove()
		RemoveItem(this)
		
endpackage //######################################################
 // File C:\Users\Frotty\Documents\GitHub\WurstScript\Wurstpack\.\wurstscript\lib\handles\SoundHelper.wurst
 //######################################################
package SoundHelper

import Stack

constant boolean DEFAULT_SOUND_STOPS_ON_LEAVE_RANGE = true
constant int DEFAULT_SOUND_FADE_IN_RATE = 10
constant int DEFAULT_SOUND_FADE_OUT_RATE = 10
constant string  DEFAULT_SOUND_EAX_SETTINGS = "CombatSoundsEAX"
constant int DEFAULT_SOUND_VOLUME = 127
constant real DEFAULT_SOUND_PITCH = 1

constant int SOUND_CHANNEL = 5
constant real SOUND_MIN_DIST = 600
constant real SOUND_MAX_DIST = 10000
constant real SOUND_DIST_CUT = 3000

class SData
	sound snd
	Sound soundData
	unit onUnit

public class Sound
	Stack<SData> soundStack = new Stack<SData>()
	
	string file
	int duration
	boolean looping
	boolean is3D
	boolean stopOnLeaveRange
	int fadeIn
	int fadeOut
	string eaxSetting
	
	construct(string file, int duration, boolean looping, boolean is3D, boolean stopOnLeaveRange, int fadeIn, int fadeOut, string eaxSetting )
		this.file = file
		this.duration = duration
		this.looping = looping
		this.is3D = is3D
		this.stopOnLeaveRange = stopOnLeaveRange
		this.fadeIn = fadeIn
		this.fadeOut = fadeOut
		this.eaxSetting = eaxSetting
		
	construct(string file, int duration, boolean looping )
		this.file = file
		this.duration = duration
		this.looping = looping
		this.is3D = false
		this.stopOnLeaveRange = false
		this.fadeIn = DEFAULT_SOUND_FADE_IN_RATE
		this.fadeOut = DEFAULT_SOUND_FADE_OUT_RATE
		this.eaxSetting = DEFAULT_SOUND_EAX_SETTINGS
		
	construct(string file, int duration, boolean looping, boolean is3D )
		this.file = file
		this.duration = duration
		this.looping = looping
		this.is3D = is3D
		this.stopOnLeaveRange = true
		this.fadeIn = DEFAULT_SOUND_FADE_IN_RATE
		this.fadeOut = DEFAULT_SOUND_FADE_OUT_RATE
		this.eaxSetting = DEFAULT_SOUND_EAX_SETTINGS
	

	function getSound() returns SData
		// If there is a handle on the stack
		if soundStack.size > 0
			return soundStack.pop()
		else
			// No free handle, create a new one
			 /*
			*   Create new sound and point it to
			*   Sound struct instance.
			*/
			var sdata = new SData()
			sdata.snd = CreateSound(this.file, this.looping, this.is3D, this.stopOnLeaveRange, this.fadeIn, this.fadeOut, this.eaxSetting)
			sdata.soundData = this
			/*
			*   Configure sound
			*/
			SetSoundDuration(sdata.snd, this.duration)
			SetSoundChannel(sdata.snd, SOUND_CHANNEL)
			SetSoundVolume(sdata.snd, DEFAULT_SOUND_VOLUME)
			SetSoundPitch(sdata.snd, DEFAULT_SOUND_PITCH)
			
			/*
			*   Proper 3D sound configuration
			*/
			if this.is3D
				SetSoundDistances(sdata.snd, SOUND_MIN_DIST, SOUND_MAX_DIST)
				SetSoundDistanceCutoff(sdata.snd, SOUND_DIST_CUT)
				SetSoundConeAngles(sdata.snd, 0, 0, DEFAULT_SOUND_VOLUME)
				SetSoundConeOrientation(sdata.snd, 0, 0, 0)
				
			
			return sdata
			
	function play()
		getTimer().setData(getSound() castTo int).start(0., function Sound.playSound)
		
	function playOnUnit(unit u)
		var s = getSound()
		s.onUnit = u
		getTimer().setData(s castTo int).start(0., function Sound.playSound)
		
	function playOnPoint(real x, real y, real z)
		var s = getSound()
		SetSoundPosition(s.snd, x, y, z)
		getTimer().setData(s castTo int).start(0., function Sound.playSound)
		
	function playOnPoint(vec3 pos)
		var s = getSound()
		SetSoundPosition(s.snd, pos.x, pos.y, pos.z)
		getTimer().setData(s castTo int).start(0., function Sound.playSound)
			
	private static function playSound()
		var tm = GetExpiredTimer()
		var sdata = tm.getData() castTo SData
		if sdata.onUnit != null
			AttachSoundToUnit(sdata.snd, sdata.onUnit)
		SetSoundVolume(sdata.snd, 100)
		StartSound(sdata.snd)
		tm.release()
		getTimer().setData(sdata castTo int).start(sdata.soundData.duration * 0.001, function Sound.recycle)
	
	private static function recycle()
		var tm = GetExpiredTimer()
		var sdata = tm.getData() castTo SData
		if sdata.soundData.soundStack.size < 4
			sdata.soundData.soundStack.push(sdata)
		else
			StopSound(sdata.snd, true, true)
			destroy sdata
			
		tm.release()
		
endpackage	

 //######################################################
 // File C:\Users\Frotty\Documents\GitHub\WurstScript\Wurstpack\.\wurstscript\lib\data structures\Stack.wurst
 //######################################################
package Stack

	public class Stack<T>
		private SEntry<T> dummy
		private SEntry<T> top
		private int size = 0

		construct()
			dummy = new SEntry<T>(null, null)
			top = dummy

		// add an element to the end of the list
		function push(T elem)
			top = new SEntry(elem, top)
			size++
			
		// get & remove the top element
		function pop() returns T
			let val = top
			top = top.prev
			size--
			return val.elem
			
		
		// look at the top element
		function peek() returns T
			return top.elem

		// add all elements from elems to this stack
		function addAll(Stack<T> elems)
			for T elem in elems
				push(elem)

		
		// gets the size of the stack
		function getSize() returns int
			return size

		// get an iterator for this stack
		function iterator() returns SIterator<T>
			return new SIterator(dummy, top)			

		ondestroy
			SEntry<T> current = top
			while current != dummy
				let temp = current
				current = current.prev
				destroy temp
			destroy dummy

	class SEntry<S>
		S elem
		SEntry<S> prev

		construct(S elem, SEntry<S> prev)
			this.elem = elem
			this.prev = prev

	class SIterator<Q>
		SEntry<Q> dummy
		SEntry<Q> current

		construct(SEntry<Q> dummy, SEntry<Q> top)
			this.dummy = dummy
			this.current = top
			
		// remove the current element from the list
		function remove()
			if current != dummy
				let cp = current.prev
				destroy current
				current = cp
				

		function hasNext() returns boolean
			return current.prev != dummy

		function next() returns Q
			current = current.prev
			return current.elem

		function close()
			destroy this


	

endpackage
 //######################################################
 // File C:\Users\Frotty\Documents\GitHub\WurstScript\Wurstpack\.\wurstscript\lib\handles\Sound.wurst
 //######################################################
package Sound
import NoWurst

// Sound Duration is always in miliseconds
public function sound.setDuration(int dur) returns sound
	SetSoundDuration(this, dur)
	return this
	


			
			
			
			
			
		
endpackage	
			
 //######################################################
 // File C:\Users\Frotty\Documents\GitHub\WurstScript\Wurstpack\.\wurstscript\lib\handles\Multiboard.wurst
 //######################################################
package Multiboard
	import NoWurst
//Since it is long to type multiboard, ill leave it out from the functions.
//multiboards
	public function multiboard.destr()
		DestroyMultiboard(this)

	public function multiboard.isDisplayed() returns boolean
		return IsMultiboardDisplayed(this)

	public function multiboard.isMinimized() returns boolean
		return IsMultiboardMinimized(this)

	public function multiboard.clear() returns multiboard
		MultiboardClear(this)
		return this

	public function multiboard.display(boolean show) returns multiboard
		MultiboardDisplay(this,show)
		return this

	//get smthg
	public function multiboard.getColumnCount() returns integer
		return MultiboardGetColumnCount(this)

	public function multiboard.getItem(integer row, integer column) returns multiboarditem
		return MultiboardGetItem(this,row,column)

	public function multiboard.getRowCount() returns integer
		return MultiboardGetRowCount(this)

	public function multiboard.getTitleText() returns string
		return MultiboardGetTitleText(this)

	public function multiboard.minimalize(boolean minimalize) returns multiboard
		MultiboardMinimize(this,minimalize)
		return this

	//set smthg
	public function multiboard.setColumnCount(integer count) returns multiboard
		MultiboardSetColumnCount(this, count)
		return this

	public function multiboard.setRowCount(integer count) returns multiboard
		MultiboardSetRowCount(this, count)
		return this

	public function multiboard.setItemsIcon(string path) returns multiboard
		MultiboardSetItemsIcon(this, path)
		return this

	public function multiboard.setItemsStyle(boolean showValues, boolean showIcons) returns multiboard
		MultiboardSetItemsStyle(this, showValues, showIcons)
		return this

	public function multiboard.setItemsValue(string value) returns multiboard
		MultiboardSetItemsValue(this,value)
		return this

	public function multiboard.setItemsValueColor(integer r,integer g, integer b, integer a ) returns multiboard
		MultiboardSetItemsValueColor(this,r,g,b,a)
		return this

	public function multiboard.setItemsWidth(real width) returns multiboard
		MultiboardSetItemsWidth(this, width)
		return this

	public function multiboard.setTitle(string label) returns multiboard
		MultiboardSetTitleText(this, label)
		return this

	public function multiboard.setTitleColor(integer r,integer g, integer b, integer a) returns multiboard
		MultiboardSetTitleTextColor(this, r,g,b,a)
		return this

	//multiboarditems
	public function multiboarditem.release() returns multiboarditem
		MultiboardReleaseItem(this)
		return this

	public function multiboarditem.setIcon(string iconFileName) returns multiboarditem
		MultiboardSetItemIcon(this,iconFileName)
		return this

	public function multiboarditem.setStyle(boolean showValue, boolean showIcon) returns multiboarditem
		MultiboardSetItemStyle(this, showValue, showIcon)
		return this

	public function multiboarditem.setValue(string value) returns multiboarditem
		MultiboardSetItemValue(this,value)
		return this

	public function multiboarditem.setValueColor(integer r, integer g, integer b, integer a) returns multiboarditem
		MultiboardSetItemValueColor(this, r,g,b,a)
		return this

	public function multiboarditem.setWidth(real width) returns multiboarditem
		MultiboardSetItemWidth(this, width)
		return this

endpackage //######################################################
 // File C:\Users\Frotty\Documents\GitHub\WurstScript\Wurstpack\.\wurstscript\lib\data structures\LinkedList.wurst
 //######################################################
package LinkedList

	public class LinkedList<T>
		private LLEntry<T> dummy
		private int size = 0

		construct()
			dummy =  new LLEntry<T>(null, null, null)
			dummy.next = dummy
			dummy.prev = dummy

		// add an element to the end of the list
		function add(T elem)
			let entry = new LLEntry(elem, dummy.prev, dummy)
			dummy.prev.next = entry
			dummy.prev = entry
			size ++

		// add all elements from elems to this list
		function addAll(LinkedList<T> elems)
			for T elem in elems
				add(elem)

		// remove element at index
		function removeAt(int index)
			let e = getEntry(index)
			e.prev.next = e.next
			e.next.prev = e.prev
			destroy e	
			size--
			
		// removes the first occurence of t from this list
		function remove(T t)
			LLEntry<T> r = dummy.next
			while r != dummy
				if r.elem == t
					r.prev.next = r.next
					r.next.prev = r.prev
					destroy r
					size--
					return
				r = r.next
		
		// gets the size of the list
		function getSize() returns int
			return size

		private function getEntry(int index) returns LLEntry<T>
			LLEntry<T> r = dummy
			for int i = 0 to index
				r = r.next
			return r

		// get the element at the specified index
		function get(int index) returns T
			return getEntry(index).elem

		// get an iterator for this list
		function iterator() returns LLIterator<T>
			return new LLIterator(dummy)			

		ondestroy
			LLEntry<T> current = dummy.next
			while current != dummy
				let temp = current
				current = current.next
				destroy temp
			destroy dummy

	class LLEntry<S>
		S elem
		LLEntry<S> prev
		LLEntry<S> next

		construct(S elem, LLEntry<S> prev, LLEntry<S> next)
			this.elem = elem
			this.prev = prev
			this.next = next

	class LLIterator<Q>
		LLEntry<Q> dummy
		LLEntry<Q> current

		construct(LLEntry<Q> dummy)
			this.dummy = dummy
			this.current = dummy

		// remove the current element from the list
		function remove()
			if current != dummy
				current.next.prev = current.prev
				current.prev.next = current.next
				current = current.prev
				destroy current

				
		function hasNext() returns boolean
			return current.next != dummy

		function next() returns Q
			current = current.next
			return current.elem

		function close()
			destroy this



	

endpackage
 //######################################################
 // File C:\Users\Frotty\Documents\GitHub\WurstScript\Wurstpack\.\wurstscript\lib\fakeHandles\Unittype.wurst
 //######################################################
package Unittype
	import NoWurst
	
	// Converts a unittype into the correct int (global-wise)
	// If the unittype doesn't exist, -1 is returned.
	public function convertUnitTypeToInt( unittype ut ) returns int
		if ut == UNIT_TYPE_HERO
			return 0
		else if ut == UNIT_TYPE_DEAD
			return 1
		else if ut == UNIT_TYPE_STRUCTURE
			return 2
		else if ut == UNIT_TYPE_FLYING
			return 3
		else if ut == UNIT_TYPE_STRUCTURE
			return 2
		else if ut == UNIT_TYPE_ATTACKS_FLYING
			return 5
		else if ut == UNIT_TYPE_ATTACKS_GROUND
			return 6		
		else if ut == UNIT_TYPE_MELEE_ATTACKER
			return 7
		else if ut == UNIT_TYPE_RANGED_ATTACKER
			return 8
		else if ut == UNIT_TYPE_GIANT
			return 9
		else if ut == UNIT_TYPE_SUMMONED
			return 10
		else if ut == UNIT_TYPE_STUNNED
			return 11
		else if ut == UNIT_TYPE_PLAGUED
			return 12
		else if ut == UNIT_TYPE_SNARED
			return 13
		else if ut == UNIT_TYPE_UNDEAD
			return 14
		else if ut == UNIT_TYPE_MECHANICAL
			return 15
		else if ut == UNIT_TYPE_PEON
			return 16
		else if ut == UNIT_TYPE_SAPPER
			return 17
		else if ut == UNIT_TYPE_TOWNHALL
			return 18
		else if ut == UNIT_TYPE_ANCIENT
			return 19
		else if ut == UNIT_TYPE_TAUREN
			return 20
		else if ut == UNIT_TYPE_POISONED
			return 21
		else if ut == UNIT_TYPE_POLYMORPHED
			return 22
		else if ut == UNIT_TYPE_SLEEPING
			return 23
		else if ut == UNIT_TYPE_RESISTANT
			return 24
		else if ut == UNIT_TYPE_ETHEREAL
			return 25
		else if ut == UNIT_TYPE_MAGIC_IMMUNE
			return 26
		else
			return -1
endpackage
 //######################################################
 // File C:\Users\Frotty\Documents\GitHub\WurstScript\Wurstpack\.\wurstscript\lib\Camera.wurst
 //######################################################
package Camera
	import NoWurst
	import TimerUtils
	
	timer array noiseTimer

	public function setCameraNoiseTimed(player owner, real value, real velocity, real time)
		int id = GetPlayerId(owner)
		if TimerGetRemaining(noiseTimer[id]) == 0
			noiseTimer[id] = getTimer()
			CameraSetSourceNoiseForPlayer( owner, value, velocity)
			noiseTimer[id].setData(id).start(time, function resetCam)
		else
			CameraSetSourceNoiseForPlayer( owner, value, velocity)
			noiseTimer[id].start(time, function resetCam)

	public function releaseCameraNoise(int owner)
		CameraClearNoiseForPlayer(Player(owner))
		noiseTimer[owner].release()


	public function shakeCameraTimed( player p, real value, real time )
		CameraSetEQNoiseForPlayer(p, value)
		getTimer().setData(GetPlayerId(p)).start(time, function resetCam)

	function resetCam()
		var t = GetExpiredTimer()
		CameraClearNoiseForPlayer(Player(t.getData()))
		t.release()
endpackage //######################################################
 // File C:\Users\Frotty\Documents\GitHub\WurstScript\Wurstpack\.\wurstscript\lib\Colors.wurst
 //######################################################
package Colors
//******************************************************************************
//*
//* ARGB 1.2
//*  ==  == 
//*  For your color needs.
//*  
//*  An ARGB object is a by-value struct, this means that assigning copies the
//* contents of the struct and that you don't have to use .destroy(), the
//* downside is that you cannot assign its members (can't do set c.r= 123 )
//*
//*  This library should have plenty of uses, for example, if your spell involves
//* some unit recoloring you can allow users to input the color in the config
//* section as 0xAARRGGBB and you can use this to decode that stuff.
//*
//* You can also easily merge two colors and make fading effects using ARGB.mix
//*
//* There's ARGB.fromPlayer which gets an ARGB object containing the player's
//* color. you can use the previous utilities on it.
//*
//* The .str() instance method can recolor a string, and the recolorUnit method
//* will apply the ARGB on a unit
//*
//* For other uses, you can use the .red, .green, .blue and .alpha members to get
//* an ARGB object's color value (from 0 to 255).
//*
//* structs that have a recolor method that takes red,green,blue and alpha as 0.255
//* integers can implement the ARGBrecolor module to gain an ability to quickly
//* recolor using an ARGB object.
//*
//********************************************************************************

// ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  == =
	
	//this double naming stuff is beginning to make me insane, if only TriggerEvaluate() wasn't so slow...
	public tuple color(int red, int green, int blue)
	public tuple colorA(int red, int green, int blue, int alpha)
	
	public function color.withAlpha( int a ) returns colorA
		return colorA(this.red, this.green, this.blue, a)
		
	public function fromHexString( string number ) returns colorA
		var alpha = number.substring(0,2)
		var red = number.substring(2,4)
		var green = number.substring(4,6)
		var blue = number.substring(6,4)
		
		return colorA( toDec(red), toDec(green), toDec(blue), toDec(alpha) )
	
	public function makeColor(int colo) returns colorA
		int a = 0
		int r = 0
		int g = 0
		int b = 0
		int col = colo
		if col < 0
			col=-(-col+0x80000000)
			a = 0x80 + col div 0x1000000
			col = col-(a-0x80)*0x1000000
		else
			a = col div 0x1000000
			col = col-a*0x1000000
		   
		r=col div 0x10000
		col=col-r*0x10000
		g=col div 0x100
		b=col-g*0x100

		return colorA(r,g,b,a)
		
	public function fromPlayerColor( playercolor pc ) returns color
		if pc  ==  PLAYER_COLOR_RED
			return color(255,3,3)
		else if pc == PLAYER_COLOR_BLUE
			return color(0,66,255)
		else if pc == PLAYER_COLOR_CYAN
			return color(28,230,185)
		else if pc == PLAYER_COLOR_PURPLE
			return color(84,0,129)
		else if pc == PLAYER_COLOR_YELLOW
			return color(255,252,1)
		else if pc == PLAYER_COLOR_ORANGE
			return color(254,138,14)
		else if pc == PLAYER_COLOR_GREEN
			return color(32,192,0)
		else if pc == PLAYER_COLOR_PINK
			return color(229,91,176)
		else if pc == PLAYER_COLOR_LIGHT_GRAY
			return color(149,150,151)
		else if pc == PLAYER_COLOR_LIGHT_BLUE
			return color(126,191,241)
		else if pc == PLAYER_COLOR_AQUA
			return color(16,98,70)
		else if pc == PLAYER_COLOR_BROWN
			return color(78,42,4)
		
		return color(0,0,0)
		
	
	public function fromPlayer( player p ) returns color
		return fromPlayerColor(GetPlayerColor(p))
		

	
	// ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  == 
	// Mixes two colors, s would be a number 0<=s<=1 that determines
	// the weight given to color c2.
	//
	//  mix(c1,c2,0)   = c1
	//  mix(c1,c2,1)   = c2
	//  mix(c1,c2,0.5) = Mixing the colors c1 and c2 in equal proportions.
	//
	public function colorA.mix( colorA c2, real s ) returns colorA
		return colorA( R2I(c2.red*s+this.red*(1-s)+0.5),
						R2I(c2.green*s+this.green*(1-s)+0.5),
						R2I(c2.blue*s+this.blue*(1-s)+0.5), 						
						R2I(c2.alpha*s+this.alpha*(1-s)+0.5))

	
	public function colorA.toString() returns string
		return "colorRBGA [" + this.red.toString() + "|" +this.green.toString() + "|" +this.blue.toString() + "|"+this.alpha.toString() +"]"

	
			
	public function unit.setVertexColor(colorA col) returns unit
		SetUnitVertexColor(this, col.red, col.green, col.blue, col.alpha)
		return this
		
	public function colorA.toColorString() returns string
		return "|C" + toHex(this.alpha) + toHex(this.red) + toHex(this.green) + toHex(this.blue)

	public function toHex( int number ) returns string
		var firstpart = number div 16
		var secondpart = number - firstpart * 16
		return hexs[firstpart] + hexs[secondpart]
		
	public function toDec( string twochar ) returns int
		if twochar.length() > 2
			printError("todec is not made for this")
		
		var first = twochar.substring(0,1)
		var second = twochar.substring(1,2)
		
		return decs.loadInt(StringHash(first)) * 16 + decs.loadInt(StringHash(second))
	
	string array hexs
	Table decs
	
	init
		for i = 0 to 9
			hexs[i] = i.toString()
		hexs[10] = "A"
		hexs[11] = "B"
		hexs[12] = "C"
		hexs[13] = "D"
		hexs[14] = "E"
		hexs[15] = "F"
		
		decs = new Table()
		for i2 = 0 to 9
			decs.saveInt(StringHash(i2.toString()), i2 )
		
		decs.saveInt(StringHash("A"), 10 )
		decs.saveInt(StringHash("B"), 11 )
		decs.saveInt(StringHash("C"), 12 )
		decs.saveInt(StringHash("D"), 13 )
		decs.saveInt(StringHash("E"), 14 )
		decs.saveInt(StringHash("F"), 15 )
	

endpackage //######################################################
 // File C:\Users\Frotty\Documents\GitHub\WurstScript\Wurstpack\.\wurstscript\lib\handles\Effect.wurst
 //######################################################
package Effect
	import NoWurst
	import Vectors
	
	public function effect.destr()
		DestroyEffect( this )
		
	public function addEffect(string path, vec2 pos) returns effect
		return AddSpecialEffect(path, pos.x, pos.y)
		
endpackage //######################################################
 // File C:\Users\Frotty\Documents\GitHub\WurstScript\Wurstpack\.\wurstscript\lib\primitives\Primitives.wurst
 //######################################################
package Primitives
import public Boolean
		
endpackage	

 //######################################################
 // File C:\Users\Frotty\Documents\GitHub\WurstScript\Wurstpack\.\wurstscript\lib\primitives\Boolean.wurst
 //######################################################
package Boolean


public function boolean.toInt() returns int
	if this
		return 1
	else
		return 0 
		
endpackage	
		
//######################################################
 // File C:\Users\Frotty\Documents\GitHub\WurstScript\Wurstpack\.\wurstscript\lib\handles\Rect.wurst
 //######################################################
package Rect
	import NoWurst
	import Table

	Table sourceTable = new Table()
	Table regionData = new Table()
	
	public function rect.getCenterX() returns real
		return GetRectCenterX(this)
	
	public function rect.getCenterY() returns real
		return GetRectCenterY(this)
		
	public function rect.getMaxX() returns real
		return GetRectMaxX(this)
		
	public function rect.getMaxY() returns real
		return GetRectMaxY(this)
		
	public function rect.getMinX() returns real
		return GetRectMinX(this)
		
	public function rect.getMinY() returns real
		return GetRectMinY(this)
	
	public function trigger.registerRectEnterEventSource( rect r )
		TriggerRegisterEnterRectSimple(this, r)
		sourceTable.saveRect(GetHandleId(this), r)
	
	public function trigger.getSourceRect() returns rect
		return sourceTable.loadRect(GetHandleId(this))
	
	public function region.setRegionData(int data)
		regionData.saveInt(GetHandleId(this), data)
	
	public function region.loadRegionData() returns int
		return regionData.loadInt(GetHandleId(this))
endpackage 
//######################################################
 // File C:\Users\Frotty\Documents\GitHub\WurstScript\Wurstpack\.\wurstscript\lib\primitives\String.wurst
 //######################################################
package String
	import NoWurst

	public function string.substring(int start, int end) returns string
		return SubString(this, start, end)
	
	public function string.length() returns int
		return StringLength(this)
		
	public function string.charAt(int index) returns string
		return SubString(this, index, index+1)
	
	public function string.toAbilityId() returns int
		return AbilityId(this)
		
	public function string.indexOf( string s ) returns int
		for int i = 0 to this.length() - 1
			if this.substring(i, i+1) == s
				return i
		return -1

endpackage

 //######################################################
 // File C:\Users\Frotty\Documents\GitHub\WurstScript\Wurstpack\.\wurstscript\lib\small helpers\Terrain.wurst
 //######################################################
package Terrain
	import Vectors
// ******************************************************************************
// BY: Rising_Dusk
// 
// This script can be used to detect the type of pathing at a specific point.
// It is valuable to do it this way because the IsTerrainPathable is very
// counterintuitive and returns in odd ways and aren't always as you would
// expect. This library, however, facilitates detecting those things reliably
// and easily.
// 
//*****************************************************************************
// 
//	> function IsTerrainDeepWater   (real x, real y) returns boolean
//	> function IsTerrainShallowWater(real x, real y) returns boolean
//	> function IsTerrainLand		(real x, real y) returns boolean
//	> function IsTerrainPlatform	(real x, real y) returns boolean
//	> function IsTerrainWalkable	(real x, real y) returns boolean
// 
// These functions return true if the given point is of the type specified
// in the function's name and false if it is not. For the IsTerrainWalkable
// function, the MAX_RANGE constant below is the maximum deviation range from
// the supplied coordinates that will still return true.
// 
// The IsTerrainPlatform works for any preplaced walkable destructable. It will
// return true over bridges, destructable ramps, elevators, and invisible
// platforms. Walkable destructables created at runtime do not create the same
// pathing hole as preplaced ones do, so this will return false for them. All
// other functions except IsTerrainWalkable return false for platforms, because
// the platform itself erases their pathing when the map is saved.
// 
// After calling IsTerrainWalkable(x, y), the following two global variables
// gain meaning. They return the X and Y coordinates of the nearest walkable
// point to the specified coordinates. These will only deviate from the
// IsTerrainWalkable function arguments if the function returned false.
// 
// Variables that can be used from the library:
//	 [real]	TerrainPathability_X
//	 [real]	TerrainPathability_Y
// 
	constant real	MAX_RANGE	 = 10.
	constant integer DUMMY_ITEM_ID = 'wolg'
	location tempLoc = Location(0.,0.)
	public rect worldRect = GetWorldBounds()
	public real	 minWorldX
	public real	 minWorldY
	public real	 maxWorldX
	public real	 maxWorldY
	item	   dItem   = null
	rect	   find   = null
	item array hid
	integer	hidMax = 0
	real	   X	  = 0.
	real	   Y	  = 0.

	init
		find = Rect(0., 0., 128., 128.)
		dItem = CreateItem(DUMMY_ITEM_ID, 0, 0)
		SetItemVisible(dItem, false)
		minWorldX = GetRectMinX(worldRect)
		minWorldY = GetRectMinY(worldRect)
		maxWorldX = GetRectMaxX(worldRect)
		maxWorldY = GetRectMaxY(worldRect)
		
		
	public function getTerrainNormal( real x, real y, real sampleRadius) returns vec3
		MoveLocation(tempLoc, x-sampleRadius, y)
		var zx = GetLocationZ(tempLoc)
		MoveLocation(tempLoc, x+sampleRadius, y)
		zx -= GetLocationZ(tempLoc)
		MoveLocation(tempLoc, x, y-sampleRadius)
		var zy = GetLocationZ(tempLoc)
		MoveLocation(tempLoc, x, y+sampleRadius)
		zy -= GetLocationZ(tempLoc)
		var sampleRadius2 = 2*sampleRadius
		return vec3( zx*sampleRadius2, zy*sampleRadius2, sampleRadius2*sampleRadius2 )
	
	public function getTerrainZ(real x, real y) returns real
		MoveLocation( tempLoc, x, y )
		return GetLocationZ( tempLoc )

	public function isTerrainDeepWater(real x, real y) returns boolean
		return not IsTerrainPathable(x, y, PATHING_TYPE_FLOATABILITY) and IsTerrainPathable(x, y, PATHING_TYPE_WALKABILITY)
	
	public function isTerrainShallowWater(real x, real y) returns boolean
		return not IsTerrainPathable(x, y, PATHING_TYPE_FLOATABILITY) and not IsTerrainPathable(x, y, PATHING_TYPE_WALKABILITY) and IsTerrainPathable(x, y, PATHING_TYPE_BUILDABILITY)
	
	public function isTerrainLand(real x, real y) returns boolean
		return IsTerrainPathable(x, y, PATHING_TYPE_FLOATABILITY)
	
	public function isTerrainPlatform(real x, real y) returns boolean
		return not IsTerrainPathable(x, y, PATHING_TYPE_FLOATABILITY) and not IsTerrainPathable(x, y, PATHING_TYPE_WALKABILITY) and not IsTerrainPathable(x, y, PATHING_TYPE_BUILDABILITY)
	
	function hideItem()
		if IsItemVisible(GetEnumItem())
			hid[hidMax] = GetEnumItem()
			SetItemVisible(hid[hidMax], false)
			hidMax++

	public function isTerrainWalkable(real x, real y) returns boolean
		//Hide any items in the area to avoid conflicts with our item
		MoveRectTo(find, x, y)
		EnumItemsInRect(find ,null, function hideItem)
		//Try to move the test item and get its coords
		SetItemPosition(dItem, x, y) //Unhides the item
		X = GetItemX(dItem)
		Y = GetItemY(dItem)
		SetItemVisible(dItem, false)//Hide it again
		//Unhide any items hidden at the start
		while hidMax > 0
			hidMax--
			SetItemVisible(hid[hidMax], true)
			hid[hidMax] = null
		//Return walkability
		return (X-x)*(X-x)+(Y-y)*(Y-y) <= MAX_RANGE*MAX_RANGE and not IsTerrainPathable(x, y, PATHING_TYPE_WALKABILITY)

endpackage //######################################################
 // File C:\Users\Frotty\Documents\GitHub\WurstScript\Wurstpack\.\wurstscript\lib\data structures\LinkedListModule.wurst
 //######################################################
package LinkedListModule

	public module LinkedListModule
		static thistype first = null
		static thistype last = null
		static int size = 0
		thistype prev
		thistype next

		construct()
			size++
			if size == 1
				first = this
				prev = null	
			else
				prev = last
				last.next = this
				first.prev = this
			next = null
			last = this

		static function getFirst() returns thistype
			return first
			
		function getNext() returns thistype
			return next

		function getPrev() returns thistype
			return prev
			
		function remove()
			size--
			if this != first
				prev.next = next
			if this != last
				next.prev = prev	
			if this == last
				last = prev
			if this == first
				first = next
				
		ondestroy
			remove()

		
		// linked list iterator functions

/* this feature would need inner classes
		static function iterator() returns Iterator
			return new Iterator()
	
		public class Iterator
			private parenttype current
			
			construct()
				this.current = parent.current
					
			function hasNext() returns boolean
				return current.next != null
				
			function next() returns parenttype
				current = current.next
				return current
*/


endpackage
 //######################################################
 // File C:\Users\Frotty\Documents\GitHub\WurstScript\Wurstpack\.\wurstscript\lib\Basics.wurst
 //######################################################
package Basics
	import NoWurst

	/** Id of the dummy unit */
	public constant int 	DUMMY_UNIT_ID 	   		= 'e000'
	/** Id of Ravenform to allow setting fly height */
	public constant int 	HEIGHT_ENABLER	 		= 'Amrf'
	/** Id of Eattree to recognize trees */
	public constant int		TREE_RECOGNITION  		= 'Aeat'
	/** Id of Locust */
	public constant int 	LOCUST_ID				= 'Aloc'
	/** Standard Period for animation.
 		Note that 0.03125 is also possible, but doesn't work with order cancel from SetUnitPos */
	public constant real	ANIMATION_PERIOD   		=  0.03
	public constant real	MAX_COLLISION_SIZE 		=  197.0
	/** Neutral Passive (grey) */
	public constant player  DUMMY_PLAYER 			= Player(15)
	/** Neutral Hostile (darkgreen) */
	public constant player	DUMMY_HOSTILE_PLAYER 	= Player(12)
	
endpackage
 //######################################################
 // File C:\Users\Frotty\Documents\GitHub\WurstScript\Wurstpack\.\wurstscript\lib\handles\Player.wurst
 //######################################################
package Player
import NoWurst

public function player.getId() returns int
	return GetPlayerId(this)

	
public function player.getName() returns string
	return GetPlayerName(this)
		
endpackage	
	
	 //######################################################
 // File C:\Users\Frotty\Documents\GitHub\WurstScript\Wurstpack\.\wurstscript\lib\EventHandling.wurst
 //######################################################
package EventHandling
import Trigger

trigger castTrig
trigger evalTrig
conditionfunc array conds
unit array casters
int count  = 0

public function unit.registerCastEvent( conditionfunc c )
	castTrig.registerUnitEvent(this, EVENT_UNIT_SPELL_EFFECT)
	conds[count] = c
	casters[count] = this
	count++
	
public function unit.unregisterCastEvent()

	for i = 0 to count
		if casters[i] == this
			
			for j = i to count - 1
				conds[j] = conds[j+1]	
				casters[j] = casters[j+1]
		
			i--
			count--

	
	
function evaluateEvent() returns boolean
	var caster = GetSpellAbilityUnit()
	debugPrint(caster.getName(), 2)
	for i = 0 to count-1
		debugPrint(i.toString(), 2)
		if casters[i] == caster
			evalTrig.addCondition(conds[i])
			evalTrig.evaluate()
			evalTrig.clearConditions()
	return false

init
	castTrig = CreateTrigger()
	castTrig.addCondition( Condition(function evaluateEvent) )
	evalTrig = CreateTrigger()

	
		
endpackage	
		
 //######################################################
 // File C:\Users\Frotty\Documents\GitHub\WurstScript\Wurstpack\.\wurstscript\lib\handles\Trigger.wurst
 //######################################################
package Trigger
	import NoWurst
	import Table
	
	Table triggerData = new Table()
	
	public function trigger.registerUnitInRangeSource( unit whichUnit, real range ) returns event
		int h = GetHandleId(this)
		int u = GetHandleId(whichUnit)
		triggerData.saveUnit(h,whichUnit)
		triggerData.saveTrigger(u,this)
		return TriggerRegisterUnitInRange(this, whichUnit, range, null)
	
	

	public function trigger.getSource() returns unit
		return triggerData.loadUnit(GetHandleId(this))
	

	
	public function unit.clearRegister()
		int h = GetHandleId(this)
		trigger t = triggerData.loadTrigger(h)
		integer th = GetHandleId(t)
		DestroyTrigger(t)
		triggerData.removeHandle(h)
		triggerData.removeHandle(th)
		
	public function trigger.enable() returns trigger
		EnableTrigger( this )
		return this
		
	public function trigger.disable() returns trigger
		DisableTrigger( this )
		return this
		
	public function trigger.destr()
		DestroyTrigger( this )
	
	public function trigger.reset() returns trigger
		ResetTrigger( this )
		return this
		
	public function trigger.addAction(code actionFunc) returns trigger
		TriggerAddAction( this, actionFunc )
		return this
	
	public function trigger.addCondition(boolexpr condition) returns trigger
		TriggerAddCondition( this, condition )
		return this
		
	public function trigger.removeCondition(triggercondition condition) returns trigger
		TriggerRemoveCondition( this, condition )
		return this
		
	public function trigger.evaluate() returns trigger
		TriggerEvaluate( this )
		return this
	
	public function trigger.execute() returns trigger
		TriggerExecute( this )
		return this
		
	//Events
	
	public function trigger.registerAnyUnitEvent(playerunitevent whichEvent) returns trigger
		TriggerRegisterAnyUnitEventBJ(this, whichEvent)
		return this

	public function trigger.registerPlayerEvent(player whichPlayer, playerevent whichPlayerEvent) returns trigger
		TriggerRegisterPlayerEvent(this, whichPlayer, whichPlayerEvent)
		return this
   		
	public function trigger.registerDeathEvent(widget whichWidget) returns trigger
		TriggerRegisterDeathEvent(this, whichWidget)
		return this
		
	public function trigger.registerDialogButtonEvent(button whichButton) returns trigger
		TriggerRegisterDialogButtonEvent(this, whichButton)
		return this
		
	public function trigger.registerDialogEvent(dialog whichDialog) returns trigger
		TriggerRegisterDialogEvent(this, whichDialog)
		return this
		
	public function trigger.registerEnterRegion(region whichRegion, boolexpr filter) returns trigger
		TriggerRegisterEnterRegion(this, whichRegion, filter)
		return this
		
	public function trigger.registerGameEvent(gameevent whichGameEvent) returns trigger
		TriggerRegisterGameEvent(this, whichGameEvent)
		return this
   	
	public function trigger.registerGameStateEvent(gamestate whichState, limitop opcode, real limitval) returns trigger
		TriggerRegisterGameStateEvent(this, whichState, opcode, limitval)
		return this
		
	public function trigger.registerLeaveRegion(region whichRegion, boolexpr filter) returns trigger
		TriggerRegisterLeaveRegion(this, whichRegion, filter)
		return this
		
	public function trigger.registerPlayerChatEvent(player whichPlayer, string chatMessageToDetect, boolean exactMatchOnly) returns trigger
		TriggerRegisterPlayerChatEvent(this, whichPlayer, chatMessageToDetect, exactMatchOnly)
		return this
	
	public function trigger.registerPlayerStateEvent(player whichPlayer, playerstate whichState, limitop opcode, real limitval) returns trigger
		TriggerRegisterPlayerStateEvent(this, whichPlayer, whichState, opcode, limitval)
		return this
		
	public function trigger.registerPlayerUnitEventplayer(player whichPlayer, playerunitevent whichPlayerUnitEvent, boolexpr filter) returns trigger
		TriggerRegisterPlayerUnitEvent(this, whichPlayer, whichPlayerUnitEvent, filter)
		return this
		
	public function trigger.registerTimerEvent(real timeout, boolean periodic) returns trigger
		TriggerRegisterTimerEvent(this, timeout, periodic)
		return this
		
	public function trigger.registerTimerExpireEvent(timer whichTimer) returns trigger
		TriggerRegisterTimerExpireEvent(this, whichTimer)
		return this
		
	public function trigger.registerTrackableHitEvent(trackable whichTrackable) returns trigger
		TriggerRegisterTrackableHitEvent(this, whichTrackable)
		return this
		
	public function trigger.registerTrackableTrackEvent(trackable whichTrackable) returns trigger
		TriggerRegisterTrackableTrackEvent(this, whichTrackable)
		return this
		
	public function trigger.registerUnitEvent(unit whichUnit, unitevent whichEvent ) returns trigger
		TriggerRegisterUnitEvent(this, whichUnit, whichEvent)
		return this
		
	public function trigger.registerUnitInRange(unit whichUnit, real range, boolexpr filter) returns trigger
		TriggerRegisterUnitInRange(this, whichUnit, range, filter)
		return this
		
	public function trigger.registerUnitStateEvent(unit whichUnit, unitstate whichState, limitop opcode, real limitval) returns trigger
		TriggerRegisterUnitStateEvent(this, whichUnit, whichState, opcode, limitval)
		return this
		
	public function trigger.clearConditions() returns trigger
		TriggerClearConditions(this)
		return this
	
	//not allowed	
	//public function trigger.registerVariableEvent(string varName, limitop opcode, real limitval) returns trigger
	//	TriggerRegisterVariableEvent(this, varName, opcode, limitval)
	//	return this
		
endpackage  //######################################################
 // File C:\Users\Frotty\Documents\GitHub\WurstScript\Wurstpack\.\wurstscript\lib\CustomBar.wurst
 //######################################################
// *************************************************************
// *				   TTBars -- Version 1.5.0
// *						by Deaod
// *************************************************************
// *
// *	CREDITS:
// *		- Ammorth (found a bug)
// *		- Anitarf (suggestions)
// *		- Ddyq (helped testing)
// *		- Vexorian (JassHelper, ARGB)
// *		- PitzerMike (JassNewGenPack)
// *		- Pipedream (Grimoire)
// *
// *		- cohadar (used PUI for demonstration purposes)
// *		- zwiebelchen (used a modified version of a script he wrote (CastingBar) for demonstration puposes)
// *
// *	HOW TO USE:
// *		* declare a variable of type TTBar or TTGradBar
// *			- TTGradBar only has the additional feature of adding Gradients. TTBar and TTGradBar are identical in all other regards.
// *
// *		* use [TTBar or TTGradBar].create(string char, integer numochars, real size, real x, real y, real z)
// *			- char is the basic string the bar is made out of
// *			- numochars is the number of chars this bar consits of
// *			- size is the textsize of the bar
// *			- x is the x-coord of the point where this bar is created
// *			- y is the y-coord of the point where this bar is created
// *			- z is the height offabove the ground
// *
// *		* add a gradient by using YourBar.AddGradient(real threshold, ARGB color)
// *			!! This is a feature of TTGradBar. Will not work with TTBar !!
// *			- threshold is the value the bar must be equal to or lower than to apply the color specified in colorstring
// *			- example input would be "ARGB.create(SOME_ALPHA, SOME_RED, SOME_GREEN, SOME_BLUE)" or "0xAARRGGBB"
// *			  Look at ARGB's manual for detailed reference
// *			- there exists an alternative version named AddGradientString(real, threshold, string color),
// *			  where the color argument is formatted as follows: "|cAARRGGBB"
// *
// *		* you can change the value of the bar at any time by using "YourBar.Value=newval"
// *			- value is a percentage
// *			  --> use 100 to fill it completely, use 0 to display an empty bar
// *
// *		* you can lock this bar to a unit using YourBar.LockToUnit(unit u, real xOffset, real yOffset, real zOffset)
// *			- u is the unit this bar is locked to
// *			- xOffis the offin x from the position of the unit the bar is locked to
// *			- yOffis the offin y from the position of the unit the bar is locked to
// *			- zOffis the height offabove ground level
// *
// *		* of course you can also unlock the bar via YourBar.Unlock()
// *
// *		* you can change the foreground color with YourBar.SetForeground(ARGB color)
// *			!! Gradients are preferred over this !!
// *			- example input would be "ARGB.create(SOME_ALPHA, SOME_RED, SOME_GREEN, SOME_BLUE)" or "0xAARRGGBB"
// *			  Look at ARGB's manual for detailed reference
// *			- there exitsts an alternative version named SetForegroundString(string color),
// *			  which takes a string formatted as follows: "|cAARRGGBB"
// *
// *		* you can change the background color with YouBar.SetBackground(ARGB color)
// *			- example input would be "ARGB.create(SOME_ALPHA, SOME_RED, SOME_GREEN, SOME_BLUE)" or "0xAARRGGBB"
// *			  Look at ARGB's manual for detailed reference
// *
// *		* want to show the bar to more players? Use YourBar.ChangeVisibility(force disp)
// *			- disp should contain all players this bar should be displayed to; note that you have to destroy this parameter for yourself
// *			  inserting null will show the bar to all players
// *
// *		* you can change the size of the bar any time by using "YourBar.Size=newval"
// *
// *		* you can read and write a bar's X, Y and Z coordinate by using the X, and X= operators (Y and Z respectively as well).
// *		  I added another method, YourBar.SetPosXY(real x, real y), which sets the bars X and Y coordinate, for speed reasons.
// *
// *		* you have access to XOffand YOffmembers (both are of type real). They are only important when locking a bar to a unit.
// *		  You can probably guess by their names what i added them for.
// *
// *		* you can read/change a bars primitive char by reading/changing the member Char
// *
// *		* you can read/change a bars number of chars by reading/changing the member Width
// *
// *		* you can fade out bars when destroying them using YourBar.FadeOut(real overTime, boolean followThrough, real xVel, real yVel)
// *			- overTime is the time fading should take
// *			- followThrough changes whether the TTBar instance should be destroyed on the spot
// *			  of if it should destroy it when the fading is finished
// *			  "true" destroys the TTBar instance when the fading is finished
// *			  "false" destroys the TTBar instance on the spot
// *			- xVel and yVel can only be used if the Bar is not locked to a unit
// *			  and move the bar into x and y direction (respectively) by the amount specified
// *
// *************************************************************

package CustomBar
	import TimerUtils
	import Colors
	import Vectors
	import Texttag


	// TTBar
	constant	int		 DEFAULT_BACKGROUND  = 0xFF000000 // 0xAARRGGBB // alpha channel is non-functional (blame blizzard for that)

	// TTBar and TTGradBar
	constant	int	 	DEFAULT_FOREGROUND  = 0xFFFFFFFF // 0xAARRGGBB

	// TTGradBar
	constant	int	 	MAX_GRADIENTS	   = 10 // Maximum number of gradients you can add


	// I dont recommend to change anything below this line


	force 		tempForce
	CustomBar 	array bars
	int 		count = 0
	timer 		animationTimer = CreateTimer()


	public class CustomBar
		texttag t
		// background color
		colorA bg_color
		// foreground color
		colorA fg_color
		// Position
		vec3 position
		// Text
		string txt
		real textsize
		// locking to units
		integer lockindex
		boolean locked
		unit u
		
		real xOffset
		real yOffset
		// misc
		force disp
		real value // value
		integer NUM_CHARS // number of chars this bar uses
		string char // primitive char/string
		string ptext // primitive text without colors
		
		construct( vec3 pos, string char, integer numochars, real size )
			t=CreateTextTag()
			if t==null
				printError("TTBARS: TextTag limit reached!")
				
			position = pos
			bg_color = makeColor(DEFAULT_BACKGROUND)
			
			textsize = TextTagSize2Height(size)
			fg_color = makeColor(DEFAULT_FOREGROUND)
			NUM_CHARS = numochars
			setChar(char)

			locked = false
			setValue(.0)
			
			if t != null
				t.setPos( position )
				.setColor( bg_color.red, bg_color.green, bg_color.blue, bg_color.alpha)
				.setText( txt, textsize)

			rebuildText()

		static function copyForce()
			ForceAddPlayer(tempForce, GetEnumPlayer())


		static function lockCallback()
			CustomBar s
			for i = count-1 downto 0
				s = bars[i]
				s.position.x = GetUnitX(s.u)
				s.position.y = GetUnitY(s.u)
				SetTextTagPos(s.t, s.position.x+s.xOffset, s.position.y+s.yOffset, s.position.z)


		function getSize() returns real
			return textsize/0.0023


		function setSize( real size )
			textsize = TextTagSize2Height(size)


		function getValue() returns real
			return value * 100.


		function setValue( real val )
			int chars = 0
			int i = 0
			var newval = val
			// keep newval inside possible boundaries
			if newval > 100.
				newval = 100.
			else if newval < 0.
				newval = 0.
				
			value = newval / 100. // the new value
			txt = fg_color.toColorString()
			chars = (R2I((value * NUM_CHARS * char.length())+0.5) div char.length())*char.length() // calculate the number of chars needed to display the new value
			txt += ptext.substring( 0, chars)
			
			txt += "|r"
			txt += ptext.substring( 0, ptext.length()-chars)

			if t != null
				t.setText( txt, textsize)


		function getX() returns real
			return position.x

		function setX( real x )
			position.x = x
			if t != null and not locked
				t.setPos( position )


		function getY() returns real
			return position.y

		function  setY( real y )
			position.y = y
			if t != null and not locked
				t.setPos( position )


		function getZ() returns real
			return position.z

		function setZ( real z )
			position.z = z
			if t != null
				t.setPos( position )


		function isLocked() returns boolean
			return locked

		private function rebuildText()
			ptext = ""
			for i = 0 to NUM_CHARS
				ptext = ptext + char

		function getChar() returns string
			return char


		function setChar( string newStr )
			var newString = newStr
			if newString == "|"
				newString = "||"

			char = newString
			rebuildText()
			setValue(value)


		function getWidth() returns int
			return NUM_CHARS

		function setWidth( int width )
			NUM_CHARS = width
			rebuildText()
			setValue(value)

		function setPosXY( real x, real y ) // added for speed reasons
			position.x = x
			position.y = y
			if t != null and not locked
				t.setPos( position )


		function setBackground( colorA col )
			bg_color = col
			if t != null
				t.setColor( bg_color.red, bg_color.green, bg_color.blue, bg_color.alpha)


		function setForeground( colorA col )
			fg_color = col
			setValue(value)


		function setForegroundString( colorA col )
			fg_color = col
			setValue(value)


		function changeVisibility( force dsp )
			force disp = dsp
			if disp != null
				if disp == null
					disp = CreateForce()
				else
					ForceClear(disp)

				tempForce = disp
				ForForce(disp, function CustomBar.copyForce)
				if IsPlayerInForce(GetLocalPlayer(), disp) and t == null
					t = CreateTextTag()
					if t != null
						t.setColor( bg_color.red, bg_color.green, bg_color.blue, bg_color.alpha)
						.setText( txt, textsize)
						.setPos( position)
					else
						printError("CustomBar: TextTag limit reached!")

				else if t != null and not IsPlayerInForce(GetLocalPlayer(), disp)
					DestroyTextTag(t)
					t = null

			else
				if t == null
					t = CreateTextTag()
					if t != null
						t.setColor( bg_color.red, bg_color.green, bg_color.blue, bg_color.alpha)
						.setText( txt, textsize)
						.setPos( position)
					else
						printError("CustomBar: TextTag limit reached!")


		function lockToUnit( unit u, real xOffset, real yOffset, real zOff )
			if not locked
				bars[count] = this
				this.u = u
				locked = true
				lockindex = count
				this.xOffset = xOffset
				this.yOffset = yOffset
				position.z = zOff
				if count == 0
					animationTimer.startPeriodic( ANIMATION_PERIOD, function CustomBar.lockCallback)

				count++


		function unlock()
			int i = 0
			if not locked
				return

			count--
			if count == 0
				PauseTimer(animationTimer)

			bars[lockindex] = bars[count]
			bars[count].lockindex = lockindex
			locked=false


		ondestroy
			if t != null
				DestroyTextTag(t)

			if locked
				unlock()


		static function fadeOutCallback()
			thistype bar = GetExpiredTimer().getData() castTo thistype
			bar.t = null
			destroy bar
			GetExpiredTimer().release()


		function fadeOut( real overTime, boolean followThrough, real xVel, real yVel )
			timer tim
			if t != null
				t.setLifespan(overTime)
				.setAge(0)
				.setFadepoint(0)
				.setPermanent(false)
				if not locked
					t.setVelocity(TextTagSpeed2Velocity(xVel), TextTagSpeed2Velocity(yVel))

			if followThrough
				getTimer()
				.setData( this castTo int )
				.start( overTime, function CustomBar.fadeOutCallback)
			else
				t = null
				destroy this

/*
	
	class CustomGradBar extends CustomBar
		Table gradientTable
		int gradCnt

		construct( vec3 position, string char, integer numochars, real size )
			super(position, char, numochars, size)
			gradientTable = new Table()
			gradCnt = 0
			fg_color=makeColor(DEFAULT_FOREGROUND)


		function addGradient( real pthreshold, colorA col )
			var threshold = pthreshold
			if gradCnt >= MAX_GRADIENTS
				printError("TTGradBar: Cannot add any more Gradients to TTGradBar " + I2S(this castTo int) + "!")
				return

			if threshold > 100
				threshold=100
			else if threshold < 0
				threshold = 0

			gradientTable.saveReal(gradCnt, threshold)
			gradientTable.saveString( gradCnt, col.toColorString().substring(2, 16) )
			gradCnt++


		override function setValue( real val )
			real k
			int j = 0
			int l=0
			real newval = 0
			// keep newval inside possible boundaries
			if val > 100
				newval=100
			else if val < 0
				newval=0

			k=110 // some value above 100 will work just as well
			// find appropriate gradient
			for i = 0 to gradCnt -1
				if newval <= gradientTable.loadReal(i) and ((gradientTable.loadReal(i)-newval) < k)
					k = gradientTable.loadReal(i)-newval
					j=i
					l++ // count how many gradients have been considered for use

			// colorize the bar
			if l > 0
				setForeground(fromHexString(gradientTable.loadString(j)))
			else
				setForeground(fg_color)

			setValue(newval)
*/
endpackage
 //######################################################
 // File C:\Users\Frotty\Documents\GitHub\WurstScript\Wurstpack\.\wurstscript\lib\handles\Texttag.wurst
 //######################################################
package Texttag
	import public Vectors
	import public Colors
	
	public function texttag.setPos( real x, real y, real z) returns texttag
		SetTextTagPos(this, x ,y , z)
		return this
		
	public function texttag.setPos( vec3 pos ) returns texttag
		SetTextTagPos(this, pos.x , pos.y , pos.z)
		return this

	public function texttag.setColor( int r, int g, int b, int a ) returns texttag
		SetTextTagColor(this, r, g , b, a)
		return this
	
	public function texttag.setColor( colorA col) returns texttag
		SetTextTagColor(this, col.red, col.green , col.blue, col.alpha)
		return this

	public function texttag.setText( string text, real height ) returns texttag
		SetTextTagText(this, text, height)
		return this
		
	public function texttag.setLifespan( real span ) returns texttag
		SetTextTagLifespan(this, span)
		return this
		
	public function texttag.setPermanent( boolean flag ) returns texttag
		SetTextTagPermanent(this, flag)
		return this
		
	public function texttag.setFadepoint( real fadepoint ) returns texttag
		SetTextTagFadepoint(this, fadepoint)
		return this
		
	public function texttag.setAge( real age ) returns texttag
		SetTextTagAge(this, age)
		return this
		
	public function texttag.setVelocity( real xvel, real yvel ) returns texttag
		SetTextTagVelocity(this, xvel, yvel)
		return this
		
	public function texttag.setVisibility( boolean flag ) returns texttag
		SetTextTagVisibility(this, flag)
		return this
		
	public function createTTEx(vec3 pos, vec2 vel, string message, int size, real duration, colorA col ) returns texttag
		texttag tt = CreateTextTag()
		tt.setPos(pos.toVec2().withZ(20.))
		.setText( message, size * 0.0023 )
		.setColor( col )
		.setVelocity( vel.x, vel.y)
		.setLifespan( duration) 
		tt.setFadepoint(.1) 
		tt.setPermanent(false)
		return tt
		
	public function createTTEx(vec3 pos, vec2 vel, string message, int size, real duration, colorA col, player p ) returns texttag
		texttag tt = createTTEx(pos, vel, message,size,duration,col)
		if GetLocalPlayer() == p
			tt.setVisibility(true)
		else
			tt.setVisibility(false)
		return tt
		
endpackage
 //######################################################
 // File C:\Users\Frotty\Documents\GitHub\WurstScript\Wurstpack\.\wurstscript\lib\handles\Unit.wurst
 //######################################################
package Unit
	import NoWurst
	import public Vectors
	
	public function unit.getX() returns real
		return GetUnitX(this)
		
	public function unit.getY() returns real
		return GetUnitY(this)
		
	public function unit.setX(real x) returns unit
		SetUnitX(this, x)
		return this
		
	public function unit.setY(real y) returns unit
		SetUnitY(this, y)
		return this
		
	public function unit.setXY(real x, real y) returns unit
		SetUnitX(this, x)
		SetUnitY(this, y)
		return this
		
	public function unit.setXY(vec2 pos) returns unit
		SetUnitX(this, pos.x)
		SetUnitY(this, pos.y)
		return this
		
	public function unit.setPos(real x, real y) returns unit
		SetUnitPosition(this, x, y)
		return this
		
	public function unit.setPos(vec2 pos) returns unit
		SetUnitPosition(this, pos.x, pos.y)
		return this
		
	public function unit.kill() returns unit
		KillUnit(this)
		return this
		
	public function unit.addAbility(int abil) returns unit
		UnitAddAbility(this, abil)
		return this
		
	public function unit.removeAbility(int abil) returns unit
		UnitRemoveAbility(this, abil)
		return this
	
	public function unit.getOwner() returns player
		return GetOwningPlayer(this)
		
	public function unit.setOwner(player p, boolean changeColor) returns unit
		SetUnitOwner(this, p, changeColor)
		return this
		
	public function unit.setScale(real scale) returns unit
		SetUnitScale(this, scale, scale, scale)
		return this
		
	public function unit.setVertexColor(int r, int g, int b, int a) returns unit
		SetUnitVertexColor(this, r, g, b, a)
		return this
		
	public function unit.addEffect(string fx, string attachment) returns effect
		return AddSpecialEffectTarget(fx, this, attachment)
	
	public function unit.setFacing(real deg) returns unit
		SetUnitFacing(this, deg)
		return this
		
	public function unit.getFacing() returns real
		return GetUnitFacing(this)
		
	public function unit.getFlyHeight() returns real
		return GetUnitFlyHeight(this)
		
	public function unit.setFlyHeight(real height, real rate) returns unit
		SetUnitFlyHeight(this, height, rate)
		return this
	
	public function unit.hide() returns unit
		ShowUnit(this, false)
		return this
	
	public function unit.show() returns unit
		ShowUnit(this, true)
		return this
		
	public function unit.setUserData(int data) returns unit
		SetUnitUserData(this, data)
		return this
		
	public function unit.getUserData() returns int
		return GetUnitUserData(this)
		
	public function unit.remove()
		RemoveUnit(this)
		
	public function unit.setState( unitstate state, real value ) returns unit
		SetUnitState( this, state, value )
		return this
		
	public function unit.getState( unitstate state ) returns real
		return GetUnitState( this, state )
		
	public function unit.setHP( real hp ) returns unit
		this.setState( UNIT_STATE_LIFE, hp )
		return this
		
	public function unit.getHP() returns real
		return this.getState( UNIT_STATE_LIFE )
		
	public function unit.addItem(int id) returns unit
		UnitAddItemById(this, id)
		return this
		
	public function unit.setTimedLife( real time ) returns unit
		UnitApplyTimedLife( this, 'BTLF', time )
		return this

	public function unit.getName() returns string
		return GetUnitName(this)
		
	public function unit.getMoveSpeed() returns real
		return GetUnitMoveSpeed(this)
		
	public function unit.setMoveSpeed(real speed) returns unit
		SetUnitMoveSpeed(this, speed)
		return this
		
	public function unit.damageTarget(unit target, real amount) returns unit
		UnitDamageTarget(this, target, amount, false, false, ATTACK_TYPE_NORMAL, DAMAGE_TYPE_UNIVERSAL, WEAPON_TYPE_WHOKNOWS)
		return this
		
	public function unit.setAnimation(string animation) returns unit
		SetUnitAnimation(this, animation)
		return this
		
	public function unit.queueAnimation(string animation) returns unit
		QueueUnitAnimation(this, animation)
		return this
		
	public function unit.setTimeScale(real scale) returns unit
		SetUnitTimeScale(this, scale)
		return this
		

endpackage //######################################################
 // File C:\Users\Frotty\Documents\GitHub\WurstScript\Wurstpack\.\wurstscript\lib\Fx.wurst
 //######################################################
package Fx
	import DummyRecycler
	import Effect
	import Colors
	import Vectors

	/********************************************************
	 * * * * * * * * * * Fx * * * * * * * * * * * * * * * * *
	 * An Fx-Object is basically just a moveable effect.  	*
	 * Up above you find the Fx-Class. By creating			*
	 * an instace of it, you recieve the mentioned,			*
	 * moveable effect.										*
	 * Constructors and functions defined as following,		*
	 * should be self-explanatory.							*
	 * Also features automatic recycling of Fx-instances	*
	 *														*
	 * Credits to Vexorian 								  	*
	 ********************************************************/
	public class Fx
		private unit 	dummy	= null
		private effect 	fx 		= null
		private real 	zangl  = 0.
		private string 	sfxPath
		
		private colorA col
		
		construct(real x, real y, real facing)
			dummy = newDummy( x, y, 0, facing)
		
		construct(vec2 pos, real facing)
			dummy = newDummy( pos.x, pos.y, 0, facing)
		
		construct(vec2 pos, real facing, string fxpath)
			dummy = newDummy( pos.x, pos.y, 0, facing)
			setFx( fxpath )
		
		construct(vec3 pos, real facing)
			dummy = newDummy( pos.x, pos.y, 0, facing)
			setZ(pos.z)	
		
		construct(vec3 pos, real facing, string fxpath)
			dummy = newDummy( pos.x, pos.y, 0, facing)
			setZ(pos.z)
			setFx( fxpath )	
		
		construct(real x, real y, real facing, string fxpath)
			dummy = newDummy( x, y, 0, facing)
			//print(GetUnitName(dummy))
			setFx( fxpath )
				
		/** Get the owner of this Fx Object */
		function getOwner() returns player
			return dummy.getOwner()
			
		/** Set the owner of this Fx Object */
		function setOwner(player p, boolean changeColor) returns Fx
			dummy.setOwner(p, changeColor)
			return this
			
		/** Set the teamcolor of this Fx Object */
		function setTeamcolor(playercolor c) returns Fx
			SetUnitColor(dummy, c)
			return this
		
		/** Set the scale of this Fx Object */
		function setScale(real value) returns Fx
			dummy.setScale(value)
			return this

		/** Get the green color value (rgba) */
		function getGreen() returns int
			return col.green
		
		/** Get the blue color value (rgba) */
		function getBlue() returns int
			return col.blue
		
		/** Get the red color value (rgba) */
		function getRed() returns int
			return col.red
		
		/** Get the alpha color value (rgba) */
		function getAlpha() returns int
			return col.alpha
		
		/** Recolor the Fx object with the given color values (rgba) 
		Color: 0 = no color - 255 = full color
		Alpha: 0 = transparent - 255 = visible */
		function recolor(int r, int g, int b, int a) returns Fx
			col.red = r
			col.green = g
			col.blue = b
			col.alpha = a
			dummy.setVertexColor(r, g, b, a)
			return this
		
		/** Recolor the Fx object with the given color tuple (colorA) 
		Color: 0 = no color - 255 = full color
		Alpha: 0 = transparent - 255 = visible */
		function recolor(colorA newColor) returns Fx
			col.red = newColor.red
			col.green = newColor.green
			col.blue = newColor.blue
			col.alpha = newColor.alpha
			dummy.setVertexColor(newColor)
			return this

		/** "Flashs" the given effect.
		Flashing plays the death animation of the effect at the fx' position. */
		function flash(string fx) returns Fx
			dummy.addEffect(fx, "origin").destr()
			return this
		
		/** Get the xy angl in radians */
		function getXYangl() returns real
			return dummy.getFacing()*bj_DEGTORAD
 
		/** Set the angl in degrees */
		function setXYangl(real value) returns Fx
			dummy.setFacing(value)
			return this
		
		/** Creates a new dummy with the given facing in order to achieve instant turning. */
		function setXYanglInstant(real value) returns Fx
			fx.destr()
			recycleDummy(dummy)
			dummy = newDummy( getX(), getY(), 0, value)
			setFx(sfxPath)
			return this
		
		/** Get the z angl in radians */
		function getZangl() returns real
			return zangl
		
		/** Set the z angl in radians */
		function setZangl(real value) returns Fx
			int i = R2I(value*bj_RADTODEG + 90.5)
			zangl = value
			if i >= 180
				i = 179
			else if i < 0
				i = 0
			SetUnitAnimationByIndex(dummy, i)
			return this
		
		/** Get the x coordinate */
		function getX() returns real
			return dummy.getX()
		
		/** Get the y coordinate */
		function getY() returns real
			return dummy.getY()
		
		/** Get the z coordinate (fly height) */
		function getZ() returns real
			return dummy.getFlyHeight()
			
		/** Get the xy position as vector tuple */			
		function getPos2() returns vec2
			return vec2(getX(), getY())
		
		/** Set the x coordinate */
		function setX(real x) returns Fx
			dummy.setX(x)
			return this
		
		/** Set the y coordinate */
		function setY(real y) returns Fx
			dummy.setY(y)
			return this
			
		/** Set the position to the given xy coordinates */
		function setPos(real x, real y) returns Fx
			dummy.setPos(x, y)
			return this
		
		/** Set the position to the given xyz coordinates
		z = flyHeight */
		function setPos(real x, real y, real z) returns Fx
			dummy.setPos(x, y)
			dummy.setFlyHeight(z, 0.)
			return this
		
		/** Set the position to the given xy vector tuple */
		function setPos(vec2 pos) returns Fx
			dummy.setPos(pos.x, pos.y)
			return this
		
		/** Set the position to the given xyz vector tuple */
		function setPos(vec3 pos) returns Fx
			dummy.setPos(pos.x, pos.y)
			setZ(pos.z)
			return this
			
		/** Set the z coordinate (flyHeight) */
		function setZ(real z) returns Fx
			dummy.setFlyHeight(z, 0.)
			return this
			
		/** Set the path to the sfx model that shoulöd be displayed. 
		If there is already a model displayed, it will be replaced with the new one.*/
		function setFx(string newpath) returns Fx
			if fx != null
				fx.destr()
			if newpath == ""
				fx = null
			else
				fx = dummy.addEffect(newpath, "origin")
			sfxPath = newpath
			return this
				
		ondestroy  			
			if fx != null
				fx.destr()

			recycleDummy(dummy)

		/** Destroys the Fx object without showing the effect's death animation */
		function hiddenDestroy()
			dummy.hide()
			destroy this
			

			
endpackage
 //######################################################
 // File C:\Users\Frotty\Documents\GitHub\WurstScript\Wurstpack\.\wurstscript\lib\DummyRecycler.wurst
 //######################################################
package DummyRecycler
	import MapBounds /*

	=========================================================================
	Calibration Guide:
	-------------------------------------------------------------------------
	The thing that surprised me the most about this system was, no matter how
	complex it turned out, it became very configurable. So I should let you
	know what the constants do so you know if/how much you want to modify.

	constant int ANG_N = 8

	-   How many different angls are recognized by the system. You can't do
	360 different angls because  you're going to have thousands of dummy
	units stored and that's ridiculous, the game lags enough at 1000 units.
	Increasing ANG_N increases realism but decreases the chance that a dummy
	unit will be available to be recycled. I don't recommend making this any
	lower, though the max I'd recommend would be 16.

	constant int ANG_STORAGE_MAX = 12

	-   How many dummy units are stored per angl. This limit is important
	because you might have a spike at one point in the game where many units
	are created, which could lead to many of those dummy units never being
	used again.
		In general, I advise that the factor of ANG_N x ANG_STORAGE_MAX does
	not exceed 100. More than that is too much in my opinion.
		Preloads ANG_N x ANG_STORAGE_MAX dummy units. Preloading dummies is
	useful as it dumps a lot of CreateUnit calls in initialization where you
	won't see a frame glitch.

	=========================================================================
	API Guide:
	-------------------------------------------------------------------------
	You obviously need some functions so you can get a recycled dummy unit or
	recycle it. Therefore I provide these:

	function GetRecycledMissile
		takes real x, real y, real z, real facing
			returns unit

		Returns a new dummy unit that acts as a projectile missile. The args
		are simply the last three arguments you'd use for a CreateUnit call,
		with the addition of a z parameter to represent the flying height -
		it isn't the absolute z but relative to the ground because it uses
		SetUnitFlyHeight on that value directly.

	function RecycleMissile
		takes unit u
			returns nothing

		When you are done with that dummy unit, recycle it via this function.
		This function is pretty intelligent and resets that unit's animation
		and its facing angl so you don't have to.
*/

	constant int ANG_N = 8				//# of indexed angls. Higher value increases realism but decreases recycle frequency.
	constant int ANG_STORAGE_MAX = 12   //Max dummies per indexed angl. I recommend lowering this if you increase ANG_N.

	constant real DEATH_TIME = 2. //Allow the special effect on
	//the unit to complete its "death" animation in this timeframe. Must
	//be higher than 0.74 seconds to allow the unit time to turn. This
	//number should not be lower than the maximum death-animation time of
	//your missile-units' effect attachments, just to be safe.


	constant int ANG_VAL = 360 div ANG_N //Generate angl value from ANG_N.
	constant int ANG_MID = ANG_VAL div 2 //The middle value of angl value.

	//Misc vars
	unit array stack	   //Recycled dummy units.
	int array stackN   //How many units are in the stack?
	real array timeStamp   //Prevents early recycling of units.
	int array queueNext
	int array queueLast
	int recycle = 0
	timer gameTime  = CreateTimer() //Used for visual continuity.
	group protect   = CreateGroup() //Used to prevent double frees.



	//=======================================================================
	// Get a recycled dummy missile unit. If there are no recycled dummies
	// that are already facing the angl you need, it creates a new dummy for
	// you.
	//
	public function newDummy( real x, real y, real z, real facing ) returns unit
		int i = ModuloInteger(R2I(facing), 360) div ANG_VAL
		int qn = queueNext[i]
		unit u
		if qn != 0 and TimerGetElapsed(gameTime) >= timeStamp[qn] 
			//Dequeue this
			queueNext[i] = queueNext[qn]
			if queueNext[i] == 0 
				queueLast[i] = i

			stackN[i] = stackN[i] - 1
			//Recycle this index
			queueLast[qn] = recycle
			recycle = qn
			//Old unit will return as new
			u = stack[qn]
			SetUnitFacing(u, facing)
			GroupRemoveUnit(protect, u)
		else
			u = CreateUnit(DUMMY_PLAYER, DUMMY_UNIT_ID, x, y, facing)
			u.addAbility(HEIGHT_ENABLER).removeAbility(HEIGHT_ENABLER)
			u.addAbility(LOCUST_ID)
			PauseUnit(u, true)

		u.setX(x)
		u.setY(y)
		u.setFlyHeight(z, 0)
		u.show()
		bj_lastCreatedUnit = u
		return bj_lastCreatedUnit

	//=======================================================================
	// You should recycle the dummy missile unit when its job is done.
	//
	public function recycleDummy( unit u )
		int rc = recycle
		u.removeAbility(LOCUST_ID)
		u.addAbility(LOCUST_ID)
		if GetUnitTypeId(u) == DUMMY_UNIT_ID and not IsUnitInGroup(u, protect) 
			if rc == 0 
				RemoveUnit(u)
				return
			//Recycle this
			recycle = queueLast[rc]
			//Index the dummy unit to an available facing angl.
			int i = R2I(GetUnitFacing(u)) div ANG_VAL
			if stackN[i] < ANG_STORAGE_MAX 
				i = ANG_N
				while stackN[i] > ANG_STORAGE_MAX
					i--

			//Enqueue this
			queueNext[queueLast[i]] = rc
			queueLast[i] = rc
			queueNext[rc] = 0
			stackN[i] = stackN[i] + 1
			//Allow a time barrier for the effect to destroy/turn to complete.
			timeStamp[rc] = TimerGetElapsed(gameTime) + DEATH_TIME
			stack[rc] = u
			//Prevent double-free of this unit.
			GroupAddUnit(protect, u)
			//Rethe dummy's properties.
			SetUnitFacing(u, (i * ANG_VAL + ANG_MID).toReal())
			SetUnitVertexColor(u, 255, 255, 255, 255)
			SetUnitAnimationByIndex(u, 90)
			SetUnitScale(u, 1, 0, 0)
			u.setOwner(DUMMY_PLAYER, true)
			//PauseUnit(u, false) -- you can disable "resets" that you don't need to worry about.
		else
			printError("[MissileRecycler] Error: Attempt to recycle invalid unit.")

	//=======================================================================
	// Map the dummy units to their facing angls (map below is if ANG_N is
	// 4 and ANG_STORAGE_MAX is 3).
	//
	// angl[0] (0)   -  [4] [5] [6]
	// angl[1] (90)  -  [7] [8] [9]
	// angl[2] (180) - [10][11][12]
	// angl[3] (270) - [13][14][15]
	//
	init
		int end
		int n = ANG_N
		real angl
		real x = maxx
		real y = maxy
		for int i = ANG_N downto 0
			stackN[i] = ANG_STORAGE_MAX
			queueNext[i] = n
			angl = (i * ANG_VAL + ANG_MID).toReal()
			end = n + ANG_STORAGE_MAX
			queueLast[i] = end - 1
			while n < end
				queueNext[n] = n + 1
				stack[n] = CreateUnit(DUMMY_PLAYER, DUMMY_UNIT_ID, x, y, angl)
				stack[n].addAbility(HEIGHT_ENABLER).removeAbility(HEIGHT_ENABLER)
				stack[n].addAbility(LOCUST_ID)
				PauseUnit(stack[n], true)
				n++

			queueNext[n - 1] = 0


		TimerStart(gameTime, 1000000., false, null)


endpackage //######################################################
 // File C:\Users\Frotty\Documents\GitHub\WurstScript\Wurstpack\.\wurstscript\lib\small helpers\SoundQueue.wurst
 //######################################################
package SoundQueue
import Queue
import SoundHelper

code c = function SoundQueue.nextSound
public class SoundQueue
	Queue<Sound> queue = new Queue<Sound>()

	timer tm = getTimer()
	
	construct()
		tm.setData(this castTo int)
	
	function addSound(Sound snd)
		queue.enqueue(snd)
		
	function startQueue()
		if queue.size > 0
			let snd = queue.dequeue()
			snd.play()
			debugPrint("playing Sound " + (snd castTo int).toString() , 1)
			tm.start(snd.duration * 0.001, c)
		else
			tm.release()
			destroy this
		
	static function nextSound()
		var tm = GetExpiredTimer()
		var sndq = tm.getData() castTo SoundQueue
		sndq.startQueue()
		
endpackage	

 //######################################################
 // File C:\Users\Frotty\Documents\GitHub\WurstScript\Wurstpack\.\wurstscript\lib\data structures\Queue.wurst
 //######################################################
package Queue

	public class Queue<T>
		private SEntry<T> dummy
		private SEntry<T> front
		private SEntry<T> back
		private int size = 0

		construct()
			dummy = new SEntry<T>(null, null)
			front = dummy

		// add an element
		function enqueue(T elem)
			if front == dummy
				front = new SEntry(elem, dummy)
				back = front
			else
				back.next = new SEntry(elem, dummy)
				back = back.next
			size++
			
		// get & remove the top element
		function dequeue() returns T
			let tmp = front
			front = front.next
			size--
			return tmp.elem
			

		// add all elements from elems to this queue
		function addAll(Queue<T> elems)
			for T elem in elems
				enqueue(elem)

		
		// gets the size of the queue
		function getSize() returns int
			return size

		// get an iterator for this queue
		function iterator() returns SIterator<T>
			return new SIterator(dummy, front)			

		ondestroy
			SEntry<T> current = front
			while current != dummy
				let temp = current
				current = current.next
				destroy temp
			destroy dummy

	class SEntry<S>
		S elem
		SEntry<S> next

		construct(S elem, SEntry<S> next)
			this.elem = elem
			this.next = next

	class SIterator<Q>
		SEntry<Q> dummy
		SEntry<Q> current

		construct(SEntry<Q> dummy, SEntry<Q> front)
			this.dummy = dummy
			this.current = front
			
		// remove the current element from the queue
		function remove()
			if current != dummy
				let cp = current.next
				destroy current
				current = cp
				

		function hasNext() returns boolean
			return current.next != dummy

		function next() returns Q
			let tmp = current
			current = current.next
			return tmp.elem

		function close()
			destroy this


	

endpackage
 //######################################################
 // File C:\Users\Frotty\Documents\GitHub\WurstScript\Wurstpack\.\wurstscript\lib\primitives\Integer.wurst
 //######################################################
package Integer
	import NoWurst
	
	public function int.abs() returns int
		if this >= 0
			return this
		else
			return -this

	public function int.squared() returns int
		return this*this
			
	public function int.sign() returns int
		if this > 0
			return 1
		else if this < 0
			return -1
		else
			return 0

	public function int.toReal() returns real
		return I2R(this)
	
	public function int.toString() returns string
		return I2S(this)

endpackage
