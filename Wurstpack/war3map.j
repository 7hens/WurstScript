//===========================================================================
// 
// xe 0.9
// 
//   Warcraft III map script
//   Generated by the Warcraft III World Editor
//   Date: Mon May 28 15:33:05 2012
//   Map Author: Vexorian, Anitarf, Blizzard(map)
// 
//===========================================================================

//***************************************************************************
//*
//*  Global Variables
//*
//***************************************************************************

globals
    // Generated
    trigger                 gg_trg_Melee_Initialization = null
    trigger                 gg_trg_xepreload           = null
    trigger                 gg_trg_xedummy             = null
    trigger                 gg_trg_xecast              = null
    trigger                 gg_trg_xefx                = null
    trigger                 gg_trg_xedamage            = null
    trigger                 gg_trg_xecollider          = null
    trigger                 gg_trg_xemissile           = null
    trigger                 gg_trg_xe_readme           = null
    trigger                 gg_trg_xepreload_readme    = null
    trigger                 gg_trg_xedummy_readme      = null
    trigger                 gg_trg_xecast_readme       = null
    trigger                 gg_trg_xefx_readme         = null
    trigger                 gg_trg_xedamage_readme     = null
    trigger                 gg_trg_xecollider_readme   = null
    trigger                 gg_trg_xemissile_readme    = null
    trigger                 gg_trg_IllusionRune        = null
    trigger                 gg_trg_SheepStaff          = null
    trigger                 gg_trg_BiGreenFire         = null
    trigger                 gg_trg_FireNovaStrike      = null
    trigger                 gg_trg_StormyDreams        = null
    trigger                 gg_trg_ChainInferno        = null
    trigger                 gg_trg_Fireblast           = null
endglobals

function InitGlobals takes nothing returns nothing
endfunction

//***************************************************************************
//*
//*  Unit Item Tables
//*
//***************************************************************************

function Unit000022_DropItems takes nothing returns nothing
    local widget  trigWidget = null
    local unit    trigUnit   = null
    local integer itemID     = 0
    local boolean canDrop    = true

    set trigWidget = bj_lastDyingWidget
    if (trigWidget == null) then
        set trigUnit = GetTriggerUnit()
    endif

    if (trigUnit != null) then
        set canDrop = not IsUnitHidden(trigUnit)
        if (canDrop and GetChangingUnit() != null) then
            set canDrop = (GetChangingUnitPrevOwner() == Player(PLAYER_NEUTRAL_AGGRESSIVE))
        endif
    endif

    if (canDrop) then
        // Item set 0
        call RandomDistReset(  )
        call RandomDistAddItem( ChooseRandomItemEx( ITEM_TYPE_PERMANENT, 4 ), 100 )
        set itemID = RandomDistChoose(  )
        if (trigUnit != null) then
            call UnitDropItem( trigUnit, itemID )
        else
            call WidgetDropItem( trigWidget, itemID )
        endif

    endif

    set bj_lastDyingWidget = null
    call DestroyTrigger(GetTriggeringTrigger())
endfunction

function Unit000027_DropItems takes nothing returns nothing
    local widget  trigWidget = null
    local unit    trigUnit   = null
    local integer itemID     = 0
    local boolean canDrop    = true

    set trigWidget = bj_lastDyingWidget
    if (trigWidget == null) then
        set trigUnit = GetTriggerUnit()
    endif

    if (trigUnit != null) then
        set canDrop = not IsUnitHidden(trigUnit)
        if (canDrop and GetChangingUnit() != null) then
            set canDrop = (GetChangingUnitPrevOwner() == Player(PLAYER_NEUTRAL_AGGRESSIVE))
        endif
    endif

    if (canDrop) then
        // Item set 0
        call RandomDistReset(  )
        call RandomDistAddItem( ChooseRandomItemEx( ITEM_TYPE_CHARGED, 3 ), 100 )
        set itemID = RandomDistChoose(  )
        if (trigUnit != null) then
            call UnitDropItem( trigUnit, itemID )
        else
            call WidgetDropItem( trigWidget, itemID )
        endif

        // Item set 1
        call RandomDistReset(  )
        call RandomDistAddItem( ChooseRandomItemEx( ITEM_TYPE_POWERUP, 1 ), 100 )
        set itemID = RandomDistChoose(  )
        if (trigUnit != null) then
            call UnitDropItem( trigUnit, itemID )
        else
            call WidgetDropItem( trigWidget, itemID )
        endif

    endif

    set bj_lastDyingWidget = null
    call DestroyTrigger(GetTriggeringTrigger())
endfunction

function Unit000037_DropItems takes nothing returns nothing
    local widget  trigWidget = null
    local unit    trigUnit   = null
    local integer itemID     = 0
    local boolean canDrop    = true

    set trigWidget = bj_lastDyingWidget
    if (trigWidget == null) then
        set trigUnit = GetTriggerUnit()
    endif

    if (trigUnit != null) then
        set canDrop = not IsUnitHidden(trigUnit)
        if (canDrop and GetChangingUnit() != null) then
            set canDrop = (GetChangingUnitPrevOwner() == Player(PLAYER_NEUTRAL_AGGRESSIVE))
        endif
    endif

    if (canDrop) then
        // Item set 0
        call RandomDistReset(  )
        call RandomDistAddItem( ChooseRandomItemEx( ITEM_TYPE_PERMANENT, 2 ), 100 )
        set itemID = RandomDistChoose(  )
        if (trigUnit != null) then
            call UnitDropItem( trigUnit, itemID )
        else
            call WidgetDropItem( trigWidget, itemID )
        endif

    endif

    set bj_lastDyingWidget = null
    call DestroyTrigger(GetTriggeringTrigger())
endfunction

function Unit000038_DropItems takes nothing returns nothing
    local widget  trigWidget = null
    local unit    trigUnit   = null
    local integer itemID     = 0
    local boolean canDrop    = true

    set trigWidget = bj_lastDyingWidget
    if (trigWidget == null) then
        set trigUnit = GetTriggerUnit()
    endif

    if (trigUnit != null) then
        set canDrop = not IsUnitHidden(trigUnit)
        if (canDrop and GetChangingUnit() != null) then
            set canDrop = (GetChangingUnitPrevOwner() == Player(PLAYER_NEUTRAL_AGGRESSIVE))
        endif
    endif

    if (canDrop) then
        // Item set 0
        call RandomDistReset(  )
        call RandomDistAddItem( ChooseRandomItemEx( ITEM_TYPE_CHARGED, 3 ), 100 )
        set itemID = RandomDistChoose(  )
        if (trigUnit != null) then
            call UnitDropItem( trigUnit, itemID )
        else
            call WidgetDropItem( trigWidget, itemID )
        endif

        // Item set 1
        call RandomDistReset(  )
        call RandomDistAddItem( ChooseRandomItemEx( ITEM_TYPE_POWERUP, 1 ), 100 )
        set itemID = RandomDistChoose(  )
        if (trigUnit != null) then
            call UnitDropItem( trigUnit, itemID )
        else
            call WidgetDropItem( trigWidget, itemID )
        endif

    endif

    set bj_lastDyingWidget = null
    call DestroyTrigger(GetTriggeringTrigger())
endfunction

function Unit000041_DropItems takes nothing returns nothing
    local widget  trigWidget = null
    local unit    trigUnit   = null
    local integer itemID     = 0
    local boolean canDrop    = true

    set trigWidget = bj_lastDyingWidget
    if (trigWidget == null) then
        set trigUnit = GetTriggerUnit()
    endif

    if (trigUnit != null) then
        set canDrop = not IsUnitHidden(trigUnit)
        if (canDrop and GetChangingUnit() != null) then
            set canDrop = (GetChangingUnitPrevOwner() == Player(PLAYER_NEUTRAL_AGGRESSIVE))
        endif
    endif

    if (canDrop) then
        // Item set 0
        call RandomDistReset(  )
        call RandomDistAddItem( ChooseRandomItemEx( ITEM_TYPE_PERMANENT, 3 ), 100 )
        set itemID = RandomDistChoose(  )
        if (trigUnit != null) then
            call UnitDropItem( trigUnit, itemID )
        else
            call WidgetDropItem( trigWidget, itemID )
        endif

        // Item set 1
        call RandomDistReset(  )
        call RandomDistAddItem( ChooseRandomItemEx( ITEM_TYPE_POWERUP, 1 ), 100 )
        set itemID = RandomDistChoose(  )
        if (trigUnit != null) then
            call UnitDropItem( trigUnit, itemID )
        else
            call WidgetDropItem( trigWidget, itemID )
        endif

    endif

    set bj_lastDyingWidget = null
    call DestroyTrigger(GetTriggeringTrigger())
endfunction

function Unit000043_DropItems takes nothing returns nothing
    local widget  trigWidget = null
    local unit    trigUnit   = null
    local integer itemID     = 0
    local boolean canDrop    = true

    set trigWidget = bj_lastDyingWidget
    if (trigWidget == null) then
        set trigUnit = GetTriggerUnit()
    endif

    if (trigUnit != null) then
        set canDrop = not IsUnitHidden(trigUnit)
        if (canDrop and GetChangingUnit() != null) then
            set canDrop = (GetChangingUnitPrevOwner() == Player(PLAYER_NEUTRAL_AGGRESSIVE))
        endif
    endif

    if (canDrop) then
        // Item set 0
        call RandomDistReset(  )
        call RandomDistAddItem( ChooseRandomItemEx( ITEM_TYPE_PERMANENT, 3 ), 100 )
        set itemID = RandomDistChoose(  )
        if (trigUnit != null) then
            call UnitDropItem( trigUnit, itemID )
        else
            call WidgetDropItem( trigWidget, itemID )
        endif

        // Item set 1
        call RandomDistReset(  )
        call RandomDistAddItem( 'rwat', 100 )
        set itemID = RandomDistChoose(  )
        if (trigUnit != null) then
            call UnitDropItem( trigUnit, itemID )
        else
            call WidgetDropItem( trigWidget, itemID )
        endif

    endif

    set bj_lastDyingWidget = null
    call DestroyTrigger(GetTriggeringTrigger())
endfunction

function Unit000046_DropItems takes nothing returns nothing
    local widget  trigWidget = null
    local unit    trigUnit   = null
    local integer itemID     = 0
    local boolean canDrop    = true

    set trigWidget = bj_lastDyingWidget
    if (trigWidget == null) then
        set trigUnit = GetTriggerUnit()
    endif

    if (trigUnit != null) then
        set canDrop = not IsUnitHidden(trigUnit)
        if (canDrop and GetChangingUnit() != null) then
            set canDrop = (GetChangingUnitPrevOwner() == Player(PLAYER_NEUTRAL_AGGRESSIVE))
        endif
    endif

    if (canDrop) then
        // Item set 0
        call RandomDistReset(  )
        call RandomDistAddItem( ChooseRandomItemEx( ITEM_TYPE_PERMANENT, 4 ), 100 )
        set itemID = RandomDistChoose(  )
        if (trigUnit != null) then
            call UnitDropItem( trigUnit, itemID )
        else
            call WidgetDropItem( trigWidget, itemID )
        endif

    endif

    set bj_lastDyingWidget = null
    call DestroyTrigger(GetTriggeringTrigger())
endfunction

function Unit000047_DropItems takes nothing returns nothing
    local widget  trigWidget = null
    local unit    trigUnit   = null
    local integer itemID     = 0
    local boolean canDrop    = true

    set trigWidget = bj_lastDyingWidget
    if (trigWidget == null) then
        set trigUnit = GetTriggerUnit()
    endif

    if (trigUnit != null) then
        set canDrop = not IsUnitHidden(trigUnit)
        if (canDrop and GetChangingUnit() != null) then
            set canDrop = (GetChangingUnitPrevOwner() == Player(PLAYER_NEUTRAL_AGGRESSIVE))
        endif
    endif

    if (canDrop) then
        // Item set 0
        call RandomDistReset(  )
        call RandomDistAddItem( ChooseRandomItemEx( ITEM_TYPE_PERMANENT, 4 ), 100 )
        set itemID = RandomDistChoose(  )
        if (trigUnit != null) then
            call UnitDropItem( trigUnit, itemID )
        else
            call WidgetDropItem( trigWidget, itemID )
        endif

    endif

    set bj_lastDyingWidget = null
    call DestroyTrigger(GetTriggeringTrigger())
endfunction

function Unit000048_DropItems takes nothing returns nothing
    local widget  trigWidget = null
    local unit    trigUnit   = null
    local integer itemID     = 0
    local boolean canDrop    = true

    set trigWidget = bj_lastDyingWidget
    if (trigWidget == null) then
        set trigUnit = GetTriggerUnit()
    endif

    if (trigUnit != null) then
        set canDrop = not IsUnitHidden(trigUnit)
        if (canDrop and GetChangingUnit() != null) then
            set canDrop = (GetChangingUnitPrevOwner() == Player(PLAYER_NEUTRAL_AGGRESSIVE))
        endif
    endif

    if (canDrop) then
        // Item set 0
        call RandomDistReset(  )
        call RandomDistAddItem( ChooseRandomItemEx( ITEM_TYPE_POWERUP, 2 ), 100 )
        set itemID = RandomDistChoose(  )
        if (trigUnit != null) then
            call UnitDropItem( trigUnit, itemID )
        else
            call WidgetDropItem( trigWidget, itemID )
        endif

    endif

    set bj_lastDyingWidget = null
    call DestroyTrigger(GetTriggeringTrigger())
endfunction

function Unit000051_DropItems takes nothing returns nothing
    local widget  trigWidget = null
    local unit    trigUnit   = null
    local integer itemID     = 0
    local boolean canDrop    = true

    set trigWidget = bj_lastDyingWidget
    if (trigWidget == null) then
        set trigUnit = GetTriggerUnit()
    endif

    if (trigUnit != null) then
        set canDrop = not IsUnitHidden(trigUnit)
        if (canDrop and GetChangingUnit() != null) then
            set canDrop = (GetChangingUnitPrevOwner() == Player(PLAYER_NEUTRAL_AGGRESSIVE))
        endif
    endif

    if (canDrop) then
        // Item set 0
        call RandomDistReset(  )
        call RandomDistAddItem( ChooseRandomItemEx( ITEM_TYPE_PERMANENT, 3 ), 100 )
        set itemID = RandomDistChoose(  )
        if (trigUnit != null) then
            call UnitDropItem( trigUnit, itemID )
        else
            call WidgetDropItem( trigWidget, itemID )
        endif

        // Item set 1
        call RandomDistReset(  )
        call RandomDistAddItem( 'rwat', 100 )
        set itemID = RandomDistChoose(  )
        if (trigUnit != null) then
            call UnitDropItem( trigUnit, itemID )
        else
            call WidgetDropItem( trigWidget, itemID )
        endif

    endif

    set bj_lastDyingWidget = null
    call DestroyTrigger(GetTriggeringTrigger())
endfunction

function Unit000059_DropItems takes nothing returns nothing
    local widget  trigWidget = null
    local unit    trigUnit   = null
    local integer itemID     = 0
    local boolean canDrop    = true

    set trigWidget = bj_lastDyingWidget
    if (trigWidget == null) then
        set trigUnit = GetTriggerUnit()
    endif

    if (trigUnit != null) then
        set canDrop = not IsUnitHidden(trigUnit)
        if (canDrop and GetChangingUnit() != null) then
            set canDrop = (GetChangingUnitPrevOwner() == Player(PLAYER_NEUTRAL_AGGRESSIVE))
        endif
    endif

    if (canDrop) then
        // Item set 0
        call RandomDistReset(  )
        call RandomDistAddItem( ChooseRandomItemEx( ITEM_TYPE_PERMANENT, 4 ), 100 )
        set itemID = RandomDistChoose(  )
        if (trigUnit != null) then
            call UnitDropItem( trigUnit, itemID )
        else
            call WidgetDropItem( trigWidget, itemID )
        endif

    endif

    set bj_lastDyingWidget = null
    call DestroyTrigger(GetTriggeringTrigger())
endfunction

function Unit000061_DropItems takes nothing returns nothing
    local widget  trigWidget = null
    local unit    trigUnit   = null
    local integer itemID     = 0
    local boolean canDrop    = true

    set trigWidget = bj_lastDyingWidget
    if (trigWidget == null) then
        set trigUnit = GetTriggerUnit()
    endif

    if (trigUnit != null) then
        set canDrop = not IsUnitHidden(trigUnit)
        if (canDrop and GetChangingUnit() != null) then
            set canDrop = (GetChangingUnitPrevOwner() == Player(PLAYER_NEUTRAL_AGGRESSIVE))
        endif
    endif

    if (canDrop) then
        // Item set 0
        call RandomDistReset(  )
        call RandomDistAddItem( ChooseRandomItemEx( ITEM_TYPE_PERMANENT, 1 ), 100 )
        set itemID = RandomDistChoose(  )
        if (trigUnit != null) then
            call UnitDropItem( trigUnit, itemID )
        else
            call WidgetDropItem( trigWidget, itemID )
        endif

    endif

    set bj_lastDyingWidget = null
    call DestroyTrigger(GetTriggeringTrigger())
endfunction

function Unit000063_DropItems takes nothing returns nothing
    local widget  trigWidget = null
    local unit    trigUnit   = null
    local integer itemID     = 0
    local boolean canDrop    = true

    set trigWidget = bj_lastDyingWidget
    if (trigWidget == null) then
        set trigUnit = GetTriggerUnit()
    endif

    if (trigUnit != null) then
        set canDrop = not IsUnitHidden(trigUnit)
        if (canDrop and GetChangingUnit() != null) then
            set canDrop = (GetChangingUnitPrevOwner() == Player(PLAYER_NEUTRAL_AGGRESSIVE))
        endif
    endif

    if (canDrop) then
        // Item set 0
        call RandomDistReset(  )
        call RandomDistAddItem( ChooseRandomItemEx( ITEM_TYPE_PERMANENT, 1 ), 100 )
        set itemID = RandomDistChoose(  )
        if (trigUnit != null) then
            call UnitDropItem( trigUnit, itemID )
        else
            call WidgetDropItem( trigWidget, itemID )
        endif

    endif

    set bj_lastDyingWidget = null
    call DestroyTrigger(GetTriggeringTrigger())
endfunction

function Unit000065_DropItems takes nothing returns nothing
    local widget  trigWidget = null
    local unit    trigUnit   = null
    local integer itemID     = 0
    local boolean canDrop    = true

    set trigWidget = bj_lastDyingWidget
    if (trigWidget == null) then
        set trigUnit = GetTriggerUnit()
    endif

    if (trigUnit != null) then
        set canDrop = not IsUnitHidden(trigUnit)
        if (canDrop and GetChangingUnit() != null) then
            set canDrop = (GetChangingUnitPrevOwner() == Player(PLAYER_NEUTRAL_AGGRESSIVE))
        endif
    endif

    if (canDrop) then
        // Item set 0
        call RandomDistReset(  )
        call RandomDistAddItem( ChooseRandomItemEx( ITEM_TYPE_PERMANENT, 1 ), 100 )
        set itemID = RandomDistChoose(  )
        if (trigUnit != null) then
            call UnitDropItem( trigUnit, itemID )
        else
            call WidgetDropItem( trigWidget, itemID )
        endif

    endif

    set bj_lastDyingWidget = null
    call DestroyTrigger(GetTriggeringTrigger())
endfunction

function Unit000068_DropItems takes nothing returns nothing
    local widget  trigWidget = null
    local unit    trigUnit   = null
    local integer itemID     = 0
    local boolean canDrop    = true

    set trigWidget = bj_lastDyingWidget
    if (trigWidget == null) then
        set trigUnit = GetTriggerUnit()
    endif

    if (trigUnit != null) then
        set canDrop = not IsUnitHidden(trigUnit)
        if (canDrop and GetChangingUnit() != null) then
            set canDrop = (GetChangingUnitPrevOwner() == Player(PLAYER_NEUTRAL_AGGRESSIVE))
        endif
    endif

    if (canDrop) then
        // Item set 0
        call RandomDistReset(  )
        call RandomDistAddItem( ChooseRandomItemEx( ITEM_TYPE_PERMANENT, 2 ), 100 )
        set itemID = RandomDistChoose(  )
        if (trigUnit != null) then
            call UnitDropItem( trigUnit, itemID )
        else
            call WidgetDropItem( trigWidget, itemID )
        endif

    endif

    set bj_lastDyingWidget = null
    call DestroyTrigger(GetTriggeringTrigger())
endfunction

function Unit000073_DropItems takes nothing returns nothing
    local widget  trigWidget = null
    local unit    trigUnit   = null
    local integer itemID     = 0
    local boolean canDrop    = true

    set trigWidget = bj_lastDyingWidget
    if (trigWidget == null) then
        set trigUnit = GetTriggerUnit()
    endif

    if (trigUnit != null) then
        set canDrop = not IsUnitHidden(trigUnit)
        if (canDrop and GetChangingUnit() != null) then
            set canDrop = (GetChangingUnitPrevOwner() == Player(PLAYER_NEUTRAL_AGGRESSIVE))
        endif
    endif

    if (canDrop) then
        // Item set 0
        call RandomDistReset(  )
        call RandomDistAddItem( ChooseRandomItemEx( ITEM_TYPE_PERMANENT, 2 ), 100 )
        set itemID = RandomDistChoose(  )
        if (trigUnit != null) then
            call UnitDropItem( trigUnit, itemID )
        else
            call WidgetDropItem( trigWidget, itemID )
        endif

    endif

    set bj_lastDyingWidget = null
    call DestroyTrigger(GetTriggeringTrigger())
endfunction

function Unit000078_DropItems takes nothing returns nothing
    local widget  trigWidget = null
    local unit    trigUnit   = null
    local integer itemID     = 0
    local boolean canDrop    = true

    set trigWidget = bj_lastDyingWidget
    if (trigWidget == null) then
        set trigUnit = GetTriggerUnit()
    endif

    if (trigUnit != null) then
        set canDrop = not IsUnitHidden(trigUnit)
        if (canDrop and GetChangingUnit() != null) then
            set canDrop = (GetChangingUnitPrevOwner() == Player(PLAYER_NEUTRAL_AGGRESSIVE))
        endif
    endif

    if (canDrop) then
        // Item set 0
        call RandomDistReset(  )
        call RandomDistAddItem( ChooseRandomItemEx( ITEM_TYPE_CHARGED, 3 ), 100 )
        set itemID = RandomDistChoose(  )
        if (trigUnit != null) then
            call UnitDropItem( trigUnit, itemID )
        else
            call WidgetDropItem( trigWidget, itemID )
        endif

        // Item set 1
        call RandomDistReset(  )
        call RandomDistAddItem( ChooseRandomItemEx( ITEM_TYPE_POWERUP, 1 ), 100 )
        set itemID = RandomDistChoose(  )
        if (trigUnit != null) then
            call UnitDropItem( trigUnit, itemID )
        else
            call WidgetDropItem( trigWidget, itemID )
        endif

    endif

    set bj_lastDyingWidget = null
    call DestroyTrigger(GetTriggeringTrigger())
endfunction

function Unit000081_DropItems takes nothing returns nothing
    local widget  trigWidget = null
    local unit    trigUnit   = null
    local integer itemID     = 0
    local boolean canDrop    = true

    set trigWidget = bj_lastDyingWidget
    if (trigWidget == null) then
        set trigUnit = GetTriggerUnit()
    endif

    if (trigUnit != null) then
        set canDrop = not IsUnitHidden(trigUnit)
        if (canDrop and GetChangingUnit() != null) then
            set canDrop = (GetChangingUnitPrevOwner() == Player(PLAYER_NEUTRAL_AGGRESSIVE))
        endif
    endif

    if (canDrop) then
        // Item set 0
        call RandomDistReset(  )
        call RandomDistAddItem( ChooseRandomItemEx( ITEM_TYPE_PERMANENT, 2 ), 100 )
        set itemID = RandomDistChoose(  )
        if (trigUnit != null) then
            call UnitDropItem( trigUnit, itemID )
        else
            call WidgetDropItem( trigWidget, itemID )
        endif

    endif

    set bj_lastDyingWidget = null
    call DestroyTrigger(GetTriggeringTrigger())
endfunction

function Unit000086_DropItems takes nothing returns nothing
    local widget  trigWidget = null
    local unit    trigUnit   = null
    local integer itemID     = 0
    local boolean canDrop    = true

    set trigWidget = bj_lastDyingWidget
    if (trigWidget == null) then
        set trigUnit = GetTriggerUnit()
    endif

    if (trigUnit != null) then
        set canDrop = not IsUnitHidden(trigUnit)
        if (canDrop and GetChangingUnit() != null) then
            set canDrop = (GetChangingUnitPrevOwner() == Player(PLAYER_NEUTRAL_AGGRESSIVE))
        endif
    endif

    if (canDrop) then
        // Item set 0
        call RandomDistReset(  )
        call RandomDistAddItem( ChooseRandomItemEx( ITEM_TYPE_PERMANENT, 5 ), 100 )
        set itemID = RandomDistChoose(  )
        if (trigUnit != null) then
            call UnitDropItem( trigUnit, itemID )
        else
            call WidgetDropItem( trigWidget, itemID )
        endif

        // Item set 1
        call RandomDistReset(  )
        call RandomDistAddItem( ChooseRandomItemEx( ITEM_TYPE_POWERUP, 2 ), 100 )
        set itemID = RandomDistChoose(  )
        if (trigUnit != null) then
            call UnitDropItem( trigUnit, itemID )
        else
            call WidgetDropItem( trigWidget, itemID )
        endif

    endif

    set bj_lastDyingWidget = null
    call DestroyTrigger(GetTriggeringTrigger())
endfunction

function Unit000088_DropItems takes nothing returns nothing
    local widget  trigWidget = null
    local unit    trigUnit   = null
    local integer itemID     = 0
    local boolean canDrop    = true

    set trigWidget = bj_lastDyingWidget
    if (trigWidget == null) then
        set trigUnit = GetTriggerUnit()
    endif

    if (trigUnit != null) then
        set canDrop = not IsUnitHidden(trigUnit)
        if (canDrop and GetChangingUnit() != null) then
            set canDrop = (GetChangingUnitPrevOwner() == Player(PLAYER_NEUTRAL_AGGRESSIVE))
        endif
    endif

    if (canDrop) then
        // Item set 0
        call RandomDistReset(  )
        call RandomDistAddItem( ChooseRandomItemEx( ITEM_TYPE_PERMANENT, 1 ), 100 )
        set itemID = RandomDistChoose(  )
        if (trigUnit != null) then
            call UnitDropItem( trigUnit, itemID )
        else
            call WidgetDropItem( trigWidget, itemID )
        endif

    endif

    set bj_lastDyingWidget = null
    call DestroyTrigger(GetTriggeringTrigger())
endfunction

function Unit000089_DropItems takes nothing returns nothing
    local widget  trigWidget = null
    local unit    trigUnit   = null
    local integer itemID     = 0
    local boolean canDrop    = true

    set trigWidget = bj_lastDyingWidget
    if (trigWidget == null) then
        set trigUnit = GetTriggerUnit()
    endif

    if (trigUnit != null) then
        set canDrop = not IsUnitHidden(trigUnit)
        if (canDrop and GetChangingUnit() != null) then
            set canDrop = (GetChangingUnitPrevOwner() == Player(PLAYER_NEUTRAL_AGGRESSIVE))
        endif
    endif

    if (canDrop) then
        // Item set 0
        call RandomDistReset(  )
        call RandomDistAddItem( ChooseRandomItemEx( ITEM_TYPE_PERMANENT, 5 ), 100 )
        set itemID = RandomDistChoose(  )
        if (trigUnit != null) then
            call UnitDropItem( trigUnit, itemID )
        else
            call WidgetDropItem( trigWidget, itemID )
        endif

        // Item set 1
        call RandomDistReset(  )
        call RandomDistAddItem( ChooseRandomItemEx( ITEM_TYPE_POWERUP, 2 ), 100 )
        set itemID = RandomDistChoose(  )
        if (trigUnit != null) then
            call UnitDropItem( trigUnit, itemID )
        else
            call WidgetDropItem( trigWidget, itemID )
        endif

    endif

    set bj_lastDyingWidget = null
    call DestroyTrigger(GetTriggeringTrigger())
endfunction

function Unit000090_DropItems takes nothing returns nothing
    local widget  trigWidget = null
    local unit    trigUnit   = null
    local integer itemID     = 0
    local boolean canDrop    = true

    set trigWidget = bj_lastDyingWidget
    if (trigWidget == null) then
        set trigUnit = GetTriggerUnit()
    endif

    if (trigUnit != null) then
        set canDrop = not IsUnitHidden(trigUnit)
        if (canDrop and GetChangingUnit() != null) then
            set canDrop = (GetChangingUnitPrevOwner() == Player(PLAYER_NEUTRAL_AGGRESSIVE))
        endif
    endif

    if (canDrop) then
        // Item set 0
        call RandomDistReset(  )
        call RandomDistAddItem( ChooseRandomItemEx( ITEM_TYPE_CHARGED, 3 ), 100 )
        set itemID = RandomDistChoose(  )
        if (trigUnit != null) then
            call UnitDropItem( trigUnit, itemID )
        else
            call WidgetDropItem( trigWidget, itemID )
        endif

        // Item set 1
        call RandomDistReset(  )
        call RandomDistAddItem( ChooseRandomItemEx( ITEM_TYPE_POWERUP, 1 ), 100 )
        set itemID = RandomDistChoose(  )
        if (trigUnit != null) then
            call UnitDropItem( trigUnit, itemID )
        else
            call WidgetDropItem( trigWidget, itemID )
        endif

    endif

    set bj_lastDyingWidget = null
    call DestroyTrigger(GetTriggeringTrigger())
endfunction

function Unit000092_DropItems takes nothing returns nothing
    local widget  trigWidget = null
    local unit    trigUnit   = null
    local integer itemID     = 0
    local boolean canDrop    = true

    set trigWidget = bj_lastDyingWidget
    if (trigWidget == null) then
        set trigUnit = GetTriggerUnit()
    endif

    if (trigUnit != null) then
        set canDrop = not IsUnitHidden(trigUnit)
        if (canDrop and GetChangingUnit() != null) then
            set canDrop = (GetChangingUnitPrevOwner() == Player(PLAYER_NEUTRAL_AGGRESSIVE))
        endif
    endif

    if (canDrop) then
        // Item set 0
        call RandomDistReset(  )
        call RandomDistAddItem( ChooseRandomItemEx( ITEM_TYPE_POWERUP, 2 ), 100 )
        set itemID = RandomDistChoose(  )
        if (trigUnit != null) then
            call UnitDropItem( trigUnit, itemID )
        else
            call WidgetDropItem( trigWidget, itemID )
        endif

    endif

    set bj_lastDyingWidget = null
    call DestroyTrigger(GetTriggeringTrigger())
endfunction

function Unit000093_DropItems takes nothing returns nothing
    local widget  trigWidget = null
    local unit    trigUnit   = null
    local integer itemID     = 0
    local boolean canDrop    = true

    set trigWidget = bj_lastDyingWidget
    if (trigWidget == null) then
        set trigUnit = GetTriggerUnit()
    endif

    if (trigUnit != null) then
        set canDrop = not IsUnitHidden(trigUnit)
        if (canDrop and GetChangingUnit() != null) then
            set canDrop = (GetChangingUnitPrevOwner() == Player(PLAYER_NEUTRAL_AGGRESSIVE))
        endif
    endif

    if (canDrop) then
        // Item set 0
        call RandomDistReset(  )
        call RandomDistAddItem( 'rhe2', 100 )
        set itemID = RandomDistChoose(  )
        if (trigUnit != null) then
            call UnitDropItem( trigUnit, itemID )
        else
            call WidgetDropItem( trigWidget, itemID )
        endif

    endif

    set bj_lastDyingWidget = null
    call DestroyTrigger(GetTriggeringTrigger())
endfunction

function Unit000094_DropItems takes nothing returns nothing
    local widget  trigWidget = null
    local unit    trigUnit   = null
    local integer itemID     = 0
    local boolean canDrop    = true

    set trigWidget = bj_lastDyingWidget
    if (trigWidget == null) then
        set trigUnit = GetTriggerUnit()
    endif

    if (trigUnit != null) then
        set canDrop = not IsUnitHidden(trigUnit)
        if (canDrop and GetChangingUnit() != null) then
            set canDrop = (GetChangingUnitPrevOwner() == Player(PLAYER_NEUTRAL_AGGRESSIVE))
        endif
    endif

    if (canDrop) then
        // Item set 0
        call RandomDistReset(  )
        call RandomDistAddItem( ChooseRandomItemEx( ITEM_TYPE_POWERUP, 2 ), 100 )
        set itemID = RandomDistChoose(  )
        if (trigUnit != null) then
            call UnitDropItem( trigUnit, itemID )
        else
            call WidgetDropItem( trigWidget, itemID )
        endif

    endif

    set bj_lastDyingWidget = null
    call DestroyTrigger(GetTriggeringTrigger())
endfunction

function Unit000098_DropItems takes nothing returns nothing
    local widget  trigWidget = null
    local unit    trigUnit   = null
    local integer itemID     = 0
    local boolean canDrop    = true

    set trigWidget = bj_lastDyingWidget
    if (trigWidget == null) then
        set trigUnit = GetTriggerUnit()
    endif

    if (trigUnit != null) then
        set canDrop = not IsUnitHidden(trigUnit)
        if (canDrop and GetChangingUnit() != null) then
            set canDrop = (GetChangingUnitPrevOwner() == Player(PLAYER_NEUTRAL_AGGRESSIVE))
        endif
    endif

    if (canDrop) then
        // Item set 0
        call RandomDistReset(  )
        call RandomDistAddItem( ChooseRandomItemEx( ITEM_TYPE_POWERUP, 2 ), 100 )
        set itemID = RandomDistChoose(  )
        if (trigUnit != null) then
            call UnitDropItem( trigUnit, itemID )
        else
            call WidgetDropItem( trigWidget, itemID )
        endif

    endif

    set bj_lastDyingWidget = null
    call DestroyTrigger(GetTriggeringTrigger())
endfunction

function Unit000103_DropItems takes nothing returns nothing
    local widget  trigWidget = null
    local unit    trigUnit   = null
    local integer itemID     = 0
    local boolean canDrop    = true

    set trigWidget = bj_lastDyingWidget
    if (trigWidget == null) then
        set trigUnit = GetTriggerUnit()
    endif

    if (trigUnit != null) then
        set canDrop = not IsUnitHidden(trigUnit)
        if (canDrop and GetChangingUnit() != null) then
            set canDrop = (GetChangingUnitPrevOwner() == Player(PLAYER_NEUTRAL_AGGRESSIVE))
        endif
    endif

    if (canDrop) then
        // Item set 0
        call RandomDistReset(  )
        call RandomDistAddItem( ChooseRandomItemEx( ITEM_TYPE_POWERUP, 2 ), 100 )
        set itemID = RandomDistChoose(  )
        if (trigUnit != null) then
            call UnitDropItem( trigUnit, itemID )
        else
            call WidgetDropItem( trigWidget, itemID )
        endif

    endif

    set bj_lastDyingWidget = null
    call DestroyTrigger(GetTriggeringTrigger())
endfunction

function Unit000106_DropItems takes nothing returns nothing
    local widget  trigWidget = null
    local unit    trigUnit   = null
    local integer itemID     = 0
    local boolean canDrop    = true

    set trigWidget = bj_lastDyingWidget
    if (trigWidget == null) then
        set trigUnit = GetTriggerUnit()
    endif

    if (trigUnit != null) then
        set canDrop = not IsUnitHidden(trigUnit)
        if (canDrop and GetChangingUnit() != null) then
            set canDrop = (GetChangingUnitPrevOwner() == Player(PLAYER_NEUTRAL_AGGRESSIVE))
        endif
    endif

    if (canDrop) then
        // Item set 0
        call RandomDistReset(  )
        call RandomDistAddItem( ChooseRandomItemEx( ITEM_TYPE_POWERUP, 2 ), 100 )
        set itemID = RandomDistChoose(  )
        if (trigUnit != null) then
            call UnitDropItem( trigUnit, itemID )
        else
            call WidgetDropItem( trigWidget, itemID )
        endif

    endif

    set bj_lastDyingWidget = null
    call DestroyTrigger(GetTriggeringTrigger())
endfunction

function Unit000110_DropItems takes nothing returns nothing
    local widget  trigWidget = null
    local unit    trigUnit   = null
    local integer itemID     = 0
    local boolean canDrop    = true

    set trigWidget = bj_lastDyingWidget
    if (trigWidget == null) then
        set trigUnit = GetTriggerUnit()
    endif

    if (trigUnit != null) then
        set canDrop = not IsUnitHidden(trigUnit)
        if (canDrop and GetChangingUnit() != null) then
            set canDrop = (GetChangingUnitPrevOwner() == Player(PLAYER_NEUTRAL_AGGRESSIVE))
        endif
    endif

    if (canDrop) then
        // Item set 0
        call RandomDistReset(  )
        call RandomDistAddItem( ChooseRandomItemEx( ITEM_TYPE_PERMANENT, 3 ), 100 )
        set itemID = RandomDistChoose(  )
        if (trigUnit != null) then
            call UnitDropItem( trigUnit, itemID )
        else
            call WidgetDropItem( trigWidget, itemID )
        endif

        // Item set 1
        call RandomDistReset(  )
        call RandomDistAddItem( ChooseRandomItemEx( ITEM_TYPE_POWERUP, 1 ), 100 )
        set itemID = RandomDistChoose(  )
        if (trigUnit != null) then
            call UnitDropItem( trigUnit, itemID )
        else
            call WidgetDropItem( trigWidget, itemID )
        endif

    endif

    set bj_lastDyingWidget = null
    call DestroyTrigger(GetTriggeringTrigger())
endfunction

function Unit000114_DropItems takes nothing returns nothing
    local widget  trigWidget = null
    local unit    trigUnit   = null
    local integer itemID     = 0
    local boolean canDrop    = true

    set trigWidget = bj_lastDyingWidget
    if (trigWidget == null) then
        set trigUnit = GetTriggerUnit()
    endif

    if (trigUnit != null) then
        set canDrop = not IsUnitHidden(trigUnit)
        if (canDrop and GetChangingUnit() != null) then
            set canDrop = (GetChangingUnitPrevOwner() == Player(PLAYER_NEUTRAL_AGGRESSIVE))
        endif
    endif

    if (canDrop) then
        // Item set 0
        call RandomDistReset(  )
        call RandomDistAddItem( 'rhe2', 100 )
        set itemID = RandomDistChoose(  )
        if (trigUnit != null) then
            call UnitDropItem( trigUnit, itemID )
        else
            call WidgetDropItem( trigWidget, itemID )
        endif

    endif

    set bj_lastDyingWidget = null
    call DestroyTrigger(GetTriggeringTrigger())
endfunction


//***************************************************************************
//*
//*  Items
//*
//***************************************************************************

function CreateAllItems takes nothing returns nothing
    local integer itemID

    call CreateItem( 'I001', -512.3, 466.9 )
    call CreateItem( 'I002', -238.4, 205.9 )
endfunction

//***************************************************************************
//*
//*  Unit Creation
//*
//***************************************************************************

//===========================================================================
function CreateUnitsForPlayer0 takes nothing returns nothing
    local player p = Player(0)
    local unit u
    local integer unitID
    local trigger t
    local real life

    set u = CreateUnit( p, 'Hblm', 19.2, 311.6, 218.514 )
    set u = CreateUnit( p, 'Hblm', -474.1, 200.8, 349.859 )
    set u = CreateUnit( p, 'Hmkg', -176.5, 51.2, 99.100 )
endfunction

//===========================================================================
function CreateUnitsForPlayer1 takes nothing returns nothing
    local player p = Player(1)
    local unit u
    local integer unitID
    local trigger t
    local real life

    set u = CreateUnit( p, 'opeo', -352.9, 553.1, 115.701 )
    set u = CreateUnit( p, 'opeo', -280.2, 413.6, 50.989 )
    set u = CreateUnit( p, 'opeo', -168.4, 419.1, 352.232 )
    set u = CreateUnit( p, 'opeo', -106.9, 528.5, 184.631 )
    set u = CreateUnit( p, 'opeo', -148.1, 610.3, 310.538 )
    set u = CreateUnit( p, 'opeo', -267.1, 579.8, 359.857 )
    set u = CreateUnit( p, 'opeo', -303.1, 502.8, 301.024 )
    set u = CreateUnit( p, 'opeo', -224.6, 542.4, 293.289 )
    set u = CreateUnit( p, 'opeo', -220.5, 626.4, 245.486 )
    set u = CreateUnit( p, 'opeo', -214.3, 407.5, 133.587 )
    set u = CreateUnit( p, 'opeo', -187.6, 523.5, 2.175 )
endfunction

//===========================================================================
function CreateNeutralHostile takes nothing returns nothing
    local player p = Player(PLAYER_NEUTRAL_AGGRESSIVE)
    local unit u
    local integer unitID
    local trigger t
    local real life

    set u = CreateUnit( p, 'nmrr', 4084.1, -3575.0, 154.804 )
    call SetUnitAcquireRange( u, 200.0 )
    set u = CreateUnit( p, 'nogl', 4621.4, 4324.2, 233.760 )
    set t = CreateTrigger(  )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_DEATH )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_CHANGE_OWNER )
    call TriggerAddAction( t, function Unit000089_DropItems )
    set u = CreateUnit( p, 'ntrg', -3976.1, 3593.6, 311.370 )
    call SetUnitAcquireRange( u, 200.0 )
    set t = CreateTrigger(  )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_DEATH )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_CHANGE_OWNER )
    call TriggerAddAction( t, function Unit000041_DropItems )
    set u = CreateUnit( p, 'nftb', 4535.7, 4627.7, 255.283 )
    set u = CreateUnit( p, 'nftb', 4828.3, 4297.5, 191.098 )
    set u = CreateUnit( p, 'nogr', 4690.8, 4124.2, 225.468 )
    set u = CreateUnit( p, 'nogr', 4443.7, 4281.5, 221.065 )
    set u = CreateUnit( p, 'nomg', -2789.3, -3501.1, 44.490 )
    call SetUnitState( u, UNIT_STATE_MANA, 0 )
    call SetUnitAcquireRange( u, 200.0 )
    set t = CreateTrigger(  )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_DEATH )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_CHANGE_OWNER )
    call TriggerAddAction( t, function Unit000043_DropItems )
    set u = CreateUnit( p, 'nomg', -3852.7, -4890.5, 57.770 )
    set t = CreateTrigger(  )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_DEATH )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_CHANGE_OWNER )
    call TriggerAddAction( t, function Unit000093_DropItems )
    set u = CreateUnit( p, 'nftt', -2703.1, -3706.6, 51.115 )
    call SetUnitAcquireRange( u, 200.0 )
    set u = CreateUnit( p, 'nftt', -2989.1, -3409.7, 20.930 )
    call SetUnitAcquireRange( u, 200.0 )
    set t = CreateTrigger(  )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_DEATH )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_CHANGE_OWNER )
    call TriggerAddAction( t, function Unit000098_DropItems )
    set u = CreateUnit( p, 'ntrg', 137.3, -2685.8, 130.730 )
    call SetUnitAcquireRange( u, 200.0 )
    set t = CreateTrigger(  )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_DEATH )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_CHANGE_OWNER )
    call TriggerAddAction( t, function Unit000038_DropItems )
    set u = CreateUnit( p, 'ntrt', -20.7, -2876.7, 154.031 )
    call SetUnitAcquireRange( u, 200.0 )
    set u = CreateUnit( p, 'nmrm', -3799.5, 3698.2, 333.420 )
    call SetUnitAcquireRange( u, 200.0 )
    set u = CreateUnit( p, 'ntrg', 2800.7, -58.3, 145.500 )
    call SetUnitAcquireRange( u, 200.0 )
    set t = CreateTrigger(  )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_DEATH )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_CHANGE_OWNER )
    call TriggerAddAction( t, function Unit000078_DropItems )
    set u = CreateUnit( p, 'nmrm', 4242.8, -3593.9, 165.818 )
    call SetUnitAcquireRange( u, 200.0 )
    set u = CreateUnit( p, 'nmrr', 3964.6, -3748.6, 129.869 )
    call SetUnitAcquireRange( u, 200.0 )
    set u = CreateUnit( p, 'nomg', 3124.9, 2733.6, 227.390 )
    call SetUnitState( u, UNIT_STATE_MANA, 0 )
    call SetUnitAcquireRange( u, 200.0 )
    set t = CreateTrigger(  )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_DEATH )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_CHANGE_OWNER )
    call TriggerAddAction( t, function Unit000051_DropItems )
    set u = CreateUnit( p, 'nmrm', 4065.5, -3916.4, 165.818 )
    call SetUnitAcquireRange( u, 200.0 )
    set u = CreateUnit( p, 'ntrg', 4275.6, -3814.7, 163.070 )
    call SetUnitAcquireRange( u, 200.0 )
    set t = CreateTrigger(  )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_DEATH )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_CHANGE_OWNER )
    call TriggerAddAction( t, function Unit000110_DropItems )
    set u = CreateUnit( p, 'ntrt', 3881.2, -732.1, 0.000 )
    call SetUnitAcquireRange( u, 200.0 )
    set t = CreateTrigger(  )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_DEATH )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_CHANGE_OWNER )
    call TriggerAddAction( t, function Unit000061_DropItems )
    set u = CreateUnit( p, 'ntrh', 3759.8, -819.5, 254.169 )
    call SetUnitAcquireRange( u, 200.0 )
    set u = CreateUnit( p, 'nftt', 3018.4, 2930.2, 223.180 )
    call SetUnitAcquireRange( u, 200.0 )
    set t = CreateTrigger(  )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_DEATH )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_CHANGE_OWNER )
    call TriggerAddAction( t, function Unit000048_DropItems )
    set u = CreateUnit( p, 'nmrm', -4103.5, 3374.9, 333.420 )
    call SetUnitAcquireRange( u, 200.0 )
    set u = CreateUnit( p, 'nmrr', -3722.5, 3502.1, 297.471 )
    call SetUnitAcquireRange( u, 200.0 )
    set u = CreateUnit( p, 'nogr', 2973.2, 2765.5, 241.220 )
    call SetUnitAcquireRange( u, 200.0 )
    set u = CreateUnit( p, 'nogr', 3235.3, 2573.2, 220.447 )
    call SetUnitAcquireRange( u, 200.0 )
    set u = CreateUnit( p, 'nomg', 4414.0, 4481.8, 244.580 )
    set t = CreateTrigger(  )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_DEATH )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_CHANGE_OWNER )
    call TriggerAddAction( t, function Unit000114_DropItems )
    set u = CreateUnit( p, 'ntrg', 336.1, 2010.8, 322.840 )
    call SetUnitAcquireRange( u, 200.0 )
    set t = CreateTrigger(  )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_DEATH )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_CHANGE_OWNER )
    call TriggerAddAction( t, function Unit000027_DropItems )
    set u = CreateUnit( p, 'ntrt', 373.5, 2246.8, 332.000 )
    call SetUnitAcquireRange( u, 200.0 )
    set u = CreateUnit( p, 'ntrg', -2299.5, -751.2, 322.840 )
    call SetUnitAcquireRange( u, 200.0 )
    set t = CreateTrigger(  )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_DEATH )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_CHANGE_OWNER )
    call TriggerAddAction( t, function Unit000090_DropItems )
    set u = CreateUnit( p, 'ntrt', 2775.2, -290.0, 174.368 )
    call SetUnitAcquireRange( u, 200.0 )
    set u = CreateUnit( p, 'nftt', 3327.8, 2716.8, 223.180 )
    call SetUnitAcquireRange( u, 200.0 )
    set u = CreateUnit( p, 'nmrr', -4113.2, 3168.9, 322.405 )
    call SetUnitAcquireRange( u, 200.0 )
    set u = CreateUnit( p, 'ntrt', 2982.1, 69.8, 104.946 )
    call SetUnitAcquireRange( u, 200.0 )
    set u = CreateUnit( p, 'ntrt', 142.8, 1960.2, 262.573 )
    call SetUnitAcquireRange( u, 200.0 )
    set u = CreateUnit( p, 'ntrt', -2283.4, -502.1, 350.835 )
    call SetUnitAcquireRange( u, 200.0 )
    set u = CreateUnit( p, 'nogr', -2838.2, -3291.4, 33.151 )
    call SetUnitAcquireRange( u, 200.0 )
    set u = CreateUnit( p, 'ntrt', -2405.4, -914.1, 281.412 )
    call SetUnitAcquireRange( u, 200.0 )
    set u = CreateUnit( p, 'nogl', -4081.5, -4687.7, 61.750 )
    set t = CreateTrigger(  )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_DEATH )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_CHANGE_OWNER )
    call TriggerAddAction( t, function Unit000086_DropItems )
    set u = CreateUnit( p, 'nogr', -2642.6, -3575.1, 71.262 )
    call SetUnitAcquireRange( u, 200.0 )
    set u = CreateUnit( p, 'ntrh', 3876.0, -593.1, 23.262 )
    call SetUnitAcquireRange( u, 200.0 )
    set u = CreateUnit( p, 'nogr', -1183.1, -5382.3, 87.270 )
    call SetUnitAcquireRange( u, 200.0 )
    set t = CreateTrigger(  )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_DEATH )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_CHANGE_OWNER )
    call TriggerAddAction( t, function Unit000081_DropItems )
    set u = CreateUnit( p, 'nogr', -986.1, -5452.0, 79.122 )
    call SetUnitAcquireRange( u, 200.0 )
    set u = CreateUnit( p, 'nftr', -1215.4, -5596.4, 59.813 )
    call SetUnitAcquireRange( u, 200.0 )
    set u = CreateUnit( p, 'nftr', -1028.1, -5637.2, 83.329 )
    call SetUnitAcquireRange( u, 200.0 )
    set u = CreateUnit( p, 'ntrt', 1064.6, -3659.8, 0.000 )
    call SetUnitAcquireRange( u, 200.0 )
    set t = CreateTrigger(  )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_DEATH )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_CHANGE_OWNER )
    call TriggerAddAction( t, function Unit000088_DropItems )
    set u = CreateUnit( p, 'nogr', 5190.2, 1437.3, 145.910 )
    call SetUnitAcquireRange( u, 200.0 )
    set t = CreateTrigger(  )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_DEATH )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_CHANGE_OWNER )
    call TriggerAddAction( t, function Unit000073_DropItems )
    set u = CreateUnit( p, 'nogr', 5210.5, 1662.2, 171.938 )
    call SetUnitAcquireRange( u, 200.0 )
    set u = CreateUnit( p, 'nftr', 5335.6, 1429.7, 152.630 )
    call SetUnitAcquireRange( u, 200.0 )
    set u = CreateUnit( p, 'ntrt', 337.2, -2580.7, 84.609 )
    call SetUnitAcquireRange( u, 200.0 )
    set u = CreateUnit( p, 'nftr', 5321.7, 1687.8, 176.146 )
    call SetUnitAcquireRange( u, 200.0 )
    set u = CreateUnit( p, 'ntrh', 984.8, -3780.4, 238.626 )
    call SetUnitAcquireRange( u, 200.0 )
    set u = CreateUnit( p, 'nogr', 1572.9, 5482.1, 287.590 )
    call SetUnitAcquireRange( u, 200.0 )
    set t = CreateTrigger(  )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_DEATH )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_CHANGE_OWNER )
    call TriggerAddAction( t, function Unit000037_DropItems )
    set u = CreateUnit( p, 'nogr', 1296.0, 5473.7, 273.680 )
    call SetUnitAcquireRange( u, 200.0 )
    set u = CreateUnit( p, 'nftr', 1545.9, 5653.9, 254.371 )
    call SetUnitAcquireRange( u, 200.0 )
    set u = CreateUnit( p, 'nftr', 1364.1, 5623.6, 277.888 )
    call SetUnitAcquireRange( u, 200.0 )
    set u = CreateUnit( p, 'nogr', -5202.7, -2150.2, 359.310 )
    call SetUnitAcquireRange( u, 200.0 )
    set t = CreateTrigger(  )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_DEATH )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_CHANGE_OWNER )
    call TriggerAddAction( t, function Unit000068_DropItems )
    set u = CreateUnit( p, 'nftk', -5445.2, 1890.3, 303.390 )
    set t = CreateTrigger(  )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_DEATH )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_CHANGE_OWNER )
    call TriggerAddAction( t, function Unit000022_DropItems )
    set u = CreateUnit( p, 'nogr', -5154.5, -2437.2, 7.669 )
    call SetUnitAcquireRange( u, 200.0 )
    set u = CreateUnit( p, 'nftr', -5337.9, -2247.4, 348.360 )
    call SetUnitAcquireRange( u, 200.0 )
    set u = CreateUnit( p, 'nftr', -5254.6, -2492.1, 11.877 )
    call SetUnitAcquireRange( u, 200.0 )
    set u = CreateUnit( p, 'nftb', -4006.9, -4906.4, 93.427 )
    set u = CreateUnit( p, 'nftb', -4291.4, -4696.6, 29.242 )
    set u = CreateUnit( p, 'nogr', -4231.2, -4500.9, 63.612 )
    set u = CreateUnit( p, 'nogr', -3892.9, -4689.1, 59.209 )
    set u = CreateUnit( p, 'nftk', -2361.6, 4873.3, 303.390 )
    set t = CreateTrigger(  )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_DEATH )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_CHANGE_OWNER )
    call TriggerAddAction( t, function Unit000047_DropItems )
    set u = CreateUnit( p, 'nftb', -2540.7, 4867.8, 326.670 )
    set t = CreateTrigger(  )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_DEATH )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_CHANGE_OWNER )
    call TriggerAddAction( t, function Unit000092_DropItems )
    set u = CreateUnit( p, 'nftk', 2789.3, -5502.6, 114.870 )
    set t = CreateTrigger(  )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_DEATH )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_CHANGE_OWNER )
    call TriggerAddAction( t, function Unit000059_DropItems )
    set u = CreateUnit( p, 'nftb', -5624.3, 1884.8, 326.670 )
    set t = CreateTrigger(  )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_DEATH )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_CHANGE_OWNER )
    call TriggerAddAction( t, function Unit000094_DropItems )
    set u = CreateUnit( p, 'nftb', -5437.1, 2135.7, 301.627 )
    set u = CreateUnit( p, 'nogr', -5500.0, 1652.6, 327.682 )
    set u = CreateUnit( p, 'nogr', -5244.8, 1932.7, 300.611 )
    set u = CreateUnit( p, 'nftk', 5477.2, -2364.2, 114.870 )
    set t = CreateTrigger(  )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_DEATH )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_CHANGE_OWNER )
    call TriggerAddAction( t, function Unit000046_DropItems )
    set u = CreateUnit( p, 'nftb', 5655.2, -2385.3, 138.154 )
    set t = CreateTrigger(  )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_DEATH )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_CHANGE_OWNER )
    call TriggerAddAction( t, function Unit000103_DropItems )
    set u = CreateUnit( p, 'nftb', -2316.6, 5090.0, 301.627 )
    set u = CreateUnit( p, 'nogr', -2379.5, 4606.9, 327.682 )
    set u = CreateUnit( p, 'nogr', -2124.4, 4887.0, 300.611 )
    set u = CreateUnit( p, 'nftb', 2967.2, -5523.7, 138.154 )
    set t = CreateTrigger(  )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_DEATH )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_CHANGE_OWNER )
    call TriggerAddAction( t, function Unit000106_DropItems )
    set u = CreateUnit( p, 'nftb', 5372.3, -2546.5, 120.105 )
    set u = CreateUnit( p, 'nogr', 5448.0, -2065.3, 146.160 )
    set u = CreateUnit( p, 'nogr', 5185.5, -2338.5, 119.089 )
    set u = CreateUnit( p, 'nftb', 2745.6, -5705.0, 120.105 )
    set u = CreateUnit( p, 'nogr', 2821.3, -5223.8, 146.160 )
    set u = CreateUnit( p, 'nogr', 2558.9, -5497.0, 119.089 )
    set u = CreateUnit( p, 'ntrh', 1177.4, -3557.9, 345.607 )
    call SetUnitAcquireRange( u, 200.0 )
    set u = CreateUnit( p, 'ntrt', -3412.4, 20.0, 141.088 )
    call SetUnitAcquireRange( u, 200.0 )
    set t = CreateTrigger(  )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_DEATH )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_CHANGE_OWNER )
    call TriggerAddAction( t, function Unit000063_DropItems )
    set u = CreateUnit( p, 'ntrh', -3514.8, -119.0, 209.689 )
    call SetUnitAcquireRange( u, 200.0 )
    set u = CreateUnit( p, 'ntrh', -3333.5, 129.5, 57.040 )
    call SetUnitAcquireRange( u, 200.0 )
    set u = CreateUnit( p, 'ntrt', -384.0, 3071.4, 140.886 )
    call SetUnitAcquireRange( u, 200.0 )
    set t = CreateTrigger(  )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_DEATH )
    call TriggerRegisterUnitEvent( t, u, EVENT_UNIT_CHANGE_OWNER )
    call TriggerAddAction( t, function Unit000065_DropItems )
    set u = CreateUnit( p, 'ntrh', -447.4, 2967.9, 217.359 )
    call SetUnitAcquireRange( u, 200.0 )
    set u = CreateUnit( p, 'ntrh', -295.8, 3159.1, 348.891 )
    call SetUnitAcquireRange( u, 200.0 )
endfunction

//===========================================================================
function CreateNeutralPassiveBuildings takes nothing returns nothing
    local player p = Player(PLAYER_NEUTRAL_PASSIVE)
    local unit u
    local integer unitID
    local trigger t
    local real life

    set u = CreateUnit( p, 'ngol', -5760.0, 2176.0, 270.000 )
    call SetResourceAmount( u, 12500 )
    set u = CreateUnit( p, 'ngol', 5888.0, -2688.0, 270.000 )
    call SetResourceAmount( u, 12500 )
    set u = CreateUnit( p, 'ngol', -2560.0, 5248.0, 270.000 )
    call SetResourceAmount( u, 12500 )
    set u = CreateUnit( p, 'ngol', 3072.0, -5888.0, 270.000 )
    call SetResourceAmount( u, 12500 )
    set u = CreateUnit( p, 'ngol', 3072.0, -256.0, 270.000 )
    call SetResourceAmount( u, 15000 )
    set u = CreateUnit( p, 'ngol', 256.0, -2944.0, 270.000 )
    call SetResourceAmount( u, 15000 )
    set u = CreateUnit( p, 'ngol', 4800.0, 4544.0, 270.000 )
    call SetResourceAmount( u, 10000 )
    set u = CreateUnit( p, 'nmh0', -4256.0, 3232.0, 270.000 )
    set u = CreateUnit( p, 'ngol', -4288.0, -4928.0, 270.000 )
    call SetResourceAmount( u, 10000 )
    set u = CreateUnit( p, 'nmh1', 4192.0, -4128.0, 270.000 )
    set u = CreateUnit( p, 'nmh0', -3872.0, 3936.0, 270.000 )
    set u = CreateUnit( p, 'ngme', -2944.0, -3712.0, 270.000 )
    set u = CreateUnit( p, 'nmh0', 4512.0, -3552.0, 270.000 )
    set u = CreateUnit( p, 'nmh0', 4512.0, -3936.0, 270.000 )
    set u = CreateUnit( p, 'ngme', 3264.0, 2944.0, 270.000 )
    set u = CreateUnit( p, 'nmh1', -4192.0, 3616.0, 270.000 )
    set u = CreateUnit( p, 'ntav', 512.0, -256.0, 270.000 )
    call SetUnitColor( u, ConvertPlayerColor(0) )
    set u = CreateUnit( p, 'ngol', 128.0, 2240.0, 270.000 )
    call SetResourceAmount( u, 15000 )
    set u = CreateUnit( p, 'ngol', -2560.0, -640.0, 270.000 )
    call SetResourceAmount( u, 15000 )
endfunction

//===========================================================================
function CreateNeutralPassive takes nothing returns nothing
    local player p = Player(PLAYER_NEUTRAL_PASSIVE)
    local unit u
    local integer unitID
    local trigger t
    local real life

    set u = CreateUnit( p, 'nech', 528.7, 100.3, 65.788 )
    set u = CreateUnit( p, 'nfro', 2419.8, -2830.5, 201.561 )
    set u = CreateUnit( p, 'nfro', 3847.6, -3612.3, 27.577 )
    set u = CreateUnit( p, 'necr', 1347.5, -4522.6, 327.095 )
    set u = CreateUnit( p, 'necr', -4379.1, -4344.4, 31.081 )
    set u = CreateUnit( p, 'necr', -5218.1, 2268.3, 197.288 )
    set u = CreateUnit( p, 'necr', -2890.8, 4953.1, 15.480 )
    set u = CreateUnit( p, 'necr', 4772.7, 3262.1, 98.473 )
    set u = CreateUnit( p, 'necr', 5589.5, -1303.4, 47.078 )
    set u = CreateUnit( p, 'nech', 474.1, 1941.1, 0.989 )
    set u = CreateUnit( p, 'nfro', -4532.9, -2144.6, 114.547 )
    set u = CreateUnit( p, 'nfro', -1341.2, -3800.8, 127.764 )
    set u = CreateUnit( p, 'nvul', 677.6, -251.9, 285.170 )
    set u = CreateUnit( p, 'nvul', 541.3, -478.9, 332.270 )
    set u = CreateUnit( p, 'nvul', 294.6, -234.5, 139.717 )
    set u = CreateUnit( p, 'nvul', 554.5, -33.4, 235.741 )
endfunction

//===========================================================================
function CreatePlayerBuildings takes nothing returns nothing
endfunction

//===========================================================================
function CreatePlayerUnits takes nothing returns nothing
    call CreateUnitsForPlayer0(  )
    call CreateUnitsForPlayer1(  )
endfunction

//===========================================================================
function CreateAllUnits takes nothing returns nothing
    call CreateNeutralPassiveBuildings(  )
    call CreatePlayerBuildings(  )
    call CreateNeutralHostile(  )
    call CreateNeutralPassive(  )
    call CreatePlayerUnits(  )
endfunction

//***************************************************************************
//*
//*  Triggers
//*
//***************************************************************************

//===========================================================================
// Trigger: xepreload
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
package PreloadHandler

    unit dum

    // use this function to preload an ability
    public function preloadAbility( int abilid )
        UnitAddAbility(dum, abilid)
		if dum == null 
            printError("PreloadAbility: do not load abilities after map init or during modules' onInit")
		else if GetUnitAbilityLevel(dum, abilid) == 0
			printWarning("PreloadAbility: Ability "+debugIdInteger2IdString(abilid)+" does not exist.")

    //================================================================================
    // Convert a integer id value into a 4-letter id code.
    function debugIdInteger2IdString (int value) returns string
		string charMap = ".................................!.#$%&'()*+,-./0123456789:;<=>.@ABCDEFGHIJKLMNOPQRSTUVWXYZ[.]^_`abcdefghijklmnopqrstuvwxyz{|}~................................................................................................................................."
		string result = ""
		int remainingValue = value
		int charValue

		for int byteno = 0 to 3
			charValue = ModuloInteger(remainingValue, 256)
			remainingValue = remainingValue div 256
			result = SubString(charMap, charValue, charValue + 1) + result

		return result
    

    function kill()
        RemoveUnit(dum)
        DestroyTimer(GetExpiredTimer())

    init
        dum = CreateUnit( Player(15), DUMMY_UNIT_ID, 0., 0., 0. )
        if dum == null
            printError("xePreload : DUMMY_UNITID ("+debugIdInteger2IdString(DUMMY_UNIT_ID)+") not added correctly to the map.")

        TimerStart( CreateTimer(), 0.0, false, function kill )

endpackage //===========================================================================
// Trigger: xedummy
//===========================================================================
//TESH.scrollpos=176
//TESH.alwaysfold=0
package Dummy
    import LinkedListModule
// 
//	Credits: 
//		* Anitarf (original xedummy)

//==============================================================================

    // The number of different angles at which the dummy units will be stored.
    constant int ANGLE_RESOLUTION = 12

    // The total number of xe dummy units that will be preloaded on map initialization.
    constant int INITIAL_DUMMY_COUNT  = 36
    
    // Don't allow to keep more than DUMMY_STACK_LIMIT inactive dummy units.
    constant int DUMMY_STACK_LIMIT    = 240


// END OF CALIBRATION SECTION
// ================================================================
//                        ---API---
// ================================================================

    public function newDummyUnit( player p, real x, real y, real face ) returns unit
        return Dummy.newDummy( p,x,y,face )


    public function releaseDummyUnit( unit u )
        Dummy.release( u )
        
// ================================================================
    
    RecycleQueue array rqs
    
    class RecycleQueue
        use LinkedListModule

        real angle = 0.
        int queueSize
        
        Dummy firstDummy
        Dummy lastDummy
        
        construct( real angle )
            this.angle = angle
        
        static function get( real angle ) returns RecycleQueue
            return rqs[R2I(angle/360.0*ANGLE_RESOLUTION)]
    
        static function initRecycleQueues()
            for int i = 0 to ANGLE_RESOLUTION
                rqs[i] = new RecycleQueue((i-0.5)*(360.0/ANGLE_RESOLUTION))
                
            RecycleQueue.first.prev = RecycleQueue.last
            RecycleQueue.last.next = RecycleQueue.first



// ================================================================

    class Dummy
        static  group g=CreateGroup()
        unit u

        // ----------------------------------------------------------------

        Dummy next
        
        private function queueInsert(RecycleQueue q)
            SetUnitFacing(u, q.angle)
            Dummy dum
            if q.queueSize == 0
                q.firstDummy = this
            else
                q.lastDummy.next = this

            q.lastDummy = this
            this.next = null

            // Recursively check adajcent queues and migrate xedummies as needed.
            if q.queueSize > q.next.queueSize
                dum = q.firstDummy
                q.firstDummy = dum.next
                dum.queueInsert(q.next)
            else if q.queueSize > q.prev.queueSize
                dum = q.firstDummy
                q.firstDummy = dum.next
                dum.queueInsert(q.prev)
            else
                q.queueSize++

        
        private static function queueRemove( RecycleQueue q ) returns Dummy
            // Recursively check adajcent queues and migrate xedummies as needed.
            Dummy d
            if q.queueSize < q.next.queueSize
                d = q.lastDummy
                q.lastDummy = queueRemove(q.next)
                d.next = q.lastDummy
                SetUnitFacing(q.lastDummy.u, q.angle)
            else if q.queueSize < q.prev.queueSize
                d = q.lastDummy
                q.lastDummy = queueRemove(q.prev)
                d.next = q.lastDummy
                SetUnitFacing(q.lastDummy.u, q.angle)
            else
                q.queueSize = q.queueSize-1
                if q.queueSize == 0
                    q.lastDummy = null


            d = q.firstDummy
            q.firstDummy = d.next
            d.next = null
            return d

    
        // ----------------------------------------------------------------

        construct( unit u )
            if GetUnitTypeId(u) != DUMMY_UNIT_ID
                printError("ReleaseDummy error: Method called on a unit of an incorrect type.")
            else if IsUnitInGroup(u, g)
                printError("ReleaseDummy error: Method called on an already released unit.")
            else
                if this castTo int > DUMMY_STACK_LIMIT
                    RemoveUnit(u)
                    destroy this
                
                this.u=u
                GroupAddUnit(g, u)
                queueInsert(RecycleQueue.get(GetUnitFacing(u)))
                SetUnitAnimationByIndex(u, 90)
                SetUnitScale(u, 1, 0, 0)
                SetUnitVertexColor(u, 255, 255, 255, 255)
                // ShowUnit(u, false) // Do not hide the unit, it is rather costly and not needed.
                printTimed("unit recycled", 10.)

        ondestroy
            GroupRemoveUnit(g, u)
            ShowUnit(u, true) // Show the unit in case it was hidden before being recycled.
        
        // ----------------------------------------------------------------
        private static unit staticDummy

        static function newDummy( player p, real x, real y, real face ) returns unit
            RecycleQueue q
            Dummy dum
            real angle = face
            while angle <= 0.0 
                angle += 360.0

            while angle >= 360.0 
                angle -= 360.0

            q = RecycleQueue.get(angle)
            
            if q.queueSize == 0
                Dummy.staticDummy = CreateUnit(p, DUMMY_UNIT_ID, x,y,angle)
                UnitAddAbility(staticDummy,HEIGHT_ENABLER)
                UnitAddAbility(staticDummy,'Aloc')
                UnitRemoveAbility(staticDummy,HEIGHT_ENABLER)
                SetUnitX(staticDummy, x)
                SetUnitY(staticDummy, y)
            else
                dum = queueRemove(q)
                Dummy.staticDummy = dum.u
                destroy dum
                SetUnitX(staticDummy, x)
                SetUnitY(staticDummy, y)
                SetUnitFacing(staticDummy, angle)
                SetUnitOwner(staticDummy, p, true)

            return Dummy.staticDummy


        static function release( unit u )
            new Dummy(u)

    init
        RecycleQueue.initRecycleQueues()
        
        int i = INITIAL_DUMMY_COUNT
        RecycleQueue q = rqs[0]
        if i > DUMMY_STACK_LIMIT
            printWarning("dummy error: INITIAL_DUMMY_COUNT can not be larger than DUMMY_STACK_LIMIT.")
            i = DUMMY_STACK_LIMIT

        while i > 0
            Dummy.staticDummy = CreateUnit(Player(15), DUMMY_UNIT_ID, 0.0,0.0,q.angle)
            UnitAddAbility(Dummy.staticDummy,HEIGHT_ENABLER)
            UnitAddAbility(Dummy.staticDummy,'Aloc')
            UnitRemoveAbility(Dummy.staticDummy,HEIGHT_ENABLER)
            new Dummy(Dummy.staticDummy)
            i--
            q=q.next
   



endpackage //===========================================================================
// Trigger: xecast
//===========================================================================
//TESH.scrollpos=384
//TESH.alwaysfold=0
package DummyCaster
//******************************************************************************
// @credit Anitarf
// ------
//  Because dummy casters REALLY ARE this complicated!
//
//******************************************************************************
    
    
    constant int INITIAL_DUMMY_COUNT  = 12
    //don't allow to keep more than DUMMY_STACK_LIMIT innactive dummy units :
    constant int DUMMY_STACK_LIMIT    = 50
    
    // If your map does not give visibility to all players, or
    // for other reasons, you might want xecast to work on
    // units that are not visible to the player, in that case
    // change this to true, else it is just a performance loss.
    constant boolean FORCE_INVISIBLE_CAST = false

    //When AUTO_RESET_MANA_COOLDOWN is to true, xecast will reset
    // the dummy unit's cooldown and mana before casting every spell.
    // it is a performance penalty, so if you are sure that all dummy spells
    // in your map got 0 mana and cooldown cost, you may it to false.    
    constant boolean AUTO_RESET_MANA_COOLDOWN = true 


//=========================================================================
// Please notice all textmacros in this library are considered private.
//  in other words: DON'T RUN THOSE TEXTMACROS!
//


    real EPSILON=0.001 //noticed in war3 this is the sort of precision we want...


    public class DummyCaster

        int abilityId    = 0    //ID (rawcode) of the ability to cast
        int level        = 1    //Level of the ability to cast

        real    recycledelay = 0.0  //Please notice, some spells need a recycle delay
                                           // This is, a time period before they get recycle.
                                           // For example, some spells are not instant, there is
                                           // also the problem with damaging spells, this recycle
                                           // delay must be large enough to contain all the time
                                           // in which the spell can do damage.


        player  owningplayer = DUMMY_PLAYER  //which player to credit for the ability cast?
                                                //notice this can also affect what units are targeteable

        //==================================================================================================
        // You need an order id for the ability so the dummy unit is able to cast it, two ways to assign it
        //   instance.orderid     = 288883            //would assign an int orderid
        //   instance.orderstring = "chainlightning"  //would assign an orderstring
        //                                                 (as those in the object editor)
        //
        function setOrderId( int id ) 
            orderId = id

        function setOrderString( string s )
            orderId = OrderId(s)
        

        //=================================================================================================
        // Finally, you can determine from which point to cast the ability: z is the height coordinate.
        //
        boolean customSource = false //Use a custom casting source?

        real    sourceX     // Determine the casting source for the dummy spell, require customSource =true
        real    sourceY     // You might prefer to use the setSourcePoint method
        real    sourceZ = 0.0 //

        function setSourcePoint( real x, real y, real z )
           sourceX = x
           sourceY = y
           sourceZ = z
           customSource = true


        private boolean autodestroy  = false
        //========================================================================================================
        // you are always allowed to use .create() but you can also use createBasic which sets some things that
        // are usually necessary up.
        //
        construct( int abilityId, string orderString, player owner, boolean autodestroy )
            this.orderId     = OrderId( orderString )
            this.abilityId   = abilityId
            owningplayer     = owner
            this.autodestroy = autodestroy


        //==========================================================================================================
        // So, create the dummy, assign options and cast the skill!
        // .castOnTarget(u)       : If you want to hit a unit u with the ability, supports FORCE_INVISIBLE_CAST.
        // .castOnWidgetTarget(w) : If you want to hit a widget w with the ability.
        // .castOnPoint(x,y)      : If you want to hit a point (x,y) with the ability.
        // .castInPoint(x,y)      : For spells like warstomp which do not have a target.
        // .castOnAOE(x,y,radius) : Classic area of effect cast. Considers collision size.
        // .castOnGroup(g)        : Cast unit the unit group g, notice it will empty the group yet not destroy it.
        //

        //**********************************************************************************************************
        // The implementation of such methods follows: 

        private static  unit array  dummystack
        private static  int         top = 0
        private static  unit        instantdummy

        private int                 orderId = 0

        private static timer        gametime
        private static timer        T
        private static unit array   recycle
        private static real array   expiretime
        private static int          rn = 0

        


        private static trigger abilityRemove


        function createDummyCaster( DummyCaster dc ) returns unit
            unit dummy
            if dc.recycledelay < EPSILON
                dummy = DummyCaster.instantdummy
                SetUnitOwner( dummy, dc.owningplayer, false )
                print("static one")
            else if DummyCaster.top > 0
                DummyCaster.top--
                dummy = DummyCaster.dummystack[DummyCaster.top]
                SetUnitOwner( dummy, dc.owningplayer, false )
                print("old one")
            else
                dummy = CreateUnit( dc.owningplayer, DUMMY_UNIT_ID, 0., 0., 0. )
                TriggerRegisterUnitEvent( DummyCaster.abilityRemove, dummy, EVENT_UNIT_SPELL_ENDCAST )
                UnitAddAbility( dummy, 'Aloc' )
                UnitAddAbility( dummy, HEIGHT_ENABLER )
                UnitRemoveAbility( dummy, HEIGHT_ENABLER )
                print("new one")

            UnitAddAbility( dummy, abilityId )
            if AUTO_RESET_MANA_COOLDOWN
                UnitResetCooldown( dummy )
                SetUnitState( dummy, UNIT_STATE_MANA, 10000.0 )

            if level > 1 
                SetUnitAbilityLevel(dummy, abilityId, level)
            
            return dummy

        private static int  cparent
        private static int  current
        private static real cexpire
        
        function destroyDummyCaster( DummyCaster dc, unit dummy )
            if dc.recycledelay >= EPSILON 
                DummyCaster.cexpire = TimerGetElapsed(DummyCaster.gametime) + dc.recycledelay
                DummyCaster.current = DummyCaster.rn
                DummyCaster.rn++
                DummyCaster.cparent = (DummyCaster.current-1) div 2
                while current > 0 or DummyCaster.expiretime[DummyCaster.cparent] > DummyCaster.cexpire
                    DummyCaster.recycle[DummyCaster.current] = DummyCaster.recycle[DummyCaster.cparent]
                    DummyCaster.expiretime[DummyCaster.current]=DummyCaster.expiretime[DummyCaster.cparent]
                    DummyCaster.current=DummyCaster.cparent
                    DummyCaster.cparent=(DummyCaster.current-1) div 2

                DummyCaster.expiretime[DummyCaster.current]=DummyCaster.cexpire
                DummyCaster.recycle[DummyCaster.current]=dummy
                SetUnitUserData(dummy,dc.abilityId)
                TimerStart(DummyCaster.T, DummyCaster.expiretime[0]-TimerGetElapsed(DummyCaster.gametime), false, function dorecycle)
            else
                SetUnitUserData(dummy,0)
                SetUnitFlyHeight(dummy,0.,0.)
                UnitRemoveAbility(dummy,dc.abilityId)


        function castOnTarget( unit target )
            unit dummy = createDummyCaster( this )
            if customSource
                SetUnitX(dummy,sourceX)
                SetUnitY(dummy,sourceY)
                SetUnitFlyHeight(dummy,sourceZ,0.0)
            else
                SetUnitX(dummy,GetWidgetX(target))
                SetUnitY(dummy,GetWidgetY(target))

            if FORCE_INVISIBLE_CAST
                UnitShareVision(target, owningplayer, true)
                IssueTargetOrderById(dummy,orderId,target)
                UnitShareVision(target, owningplayer, false)
            else
                IssueTargetOrderById(dummy,orderId,target)


            destroyDummyCaster( this, dummy )
            if autodestroy
                destroy this

        //accepts units, items and destructables, if you know it is
        // a unit it is better to use castOnTarget since that would
        // be able to use FORCE_INVISIBLE_CAST if necessary.
        //
        function castOnWidgetTarget( widget target )
            unit dummy = createDummyCaster( this )

            if customSource
                SetUnitX(dummy,sourceX)
                SetUnitY(dummy,sourceY)
                SetUnitFlyHeight(dummy,sourceZ,0.0)
            else
                SetUnitX(dummy,GetWidgetX(target))
                SetUnitY(dummy,GetWidgetY(target))
                
            IssueTargetOrderById(dummy,orderId,target)


            destroyDummyCaster( this, dummy )
            if autodestroy
                destroy this



        function castOnPoint( real x, real y )
            unit dummy = createDummyCaster( this )
            if customSource
                SetUnitX(dummy,sourceX)
                SetUnitY(dummy,sourceY)
                SetUnitFlyHeight(dummy,sourceZ,0.0)
            else
                SetUnitX(dummy,x)
                SetUnitY(dummy,y)

            IssuePointOrderById(dummy,orderId,x,y)
            
            destroyDummyCaster( this, dummy )
            if autodestroy
                destroy this
                


        //ignores custom source x and y (for obvious reasons)
        function castInPoint( real x, real y )
            unit dummy = createDummyCaster( this )
            if customSource
                SetUnitFlyHeight(dummy,sourceZ,0.0)

            SetUnitX(dummy, x)
            SetUnitY(dummy, y)
            IssueImmediateOrderById(dummy,orderId)
            
            destroyDummyCaster( this, dummy )
            if autodestroy
                destroy this



        //===================================================================================================
        // For method castOnAOE:
        //
        private static group        enumgroup
        private static real         aoex
        private static real         aoey
        private static real         aoeradius
        private static DummyCaster  cinstance
        private static boolexpr     aoefunc

        


        //
        function castOnAOE( real x, real y, real radius )
            boolean ad = autodestroy

            if ad
                autodestroy=false

            aoex=x
            aoey=y
            aoeradius=radius
            cinstance=this
            GroupEnumUnitsInRange(DummyCaster.enumgroup,x,y,radius + MAX_COLLISION_SIZE , DummyCaster.aoefunc)
            if ad
                destroy this



        //==================================================================================================
        // A quick and dirt castOnGroup method, perhaps it'll later have castOntarget inlined, but not now
        //
        function castOnGroup( group g )
            boolean ad = autodestroy    

            if ad
                this.autodestroy=false

            for unit u from g
                castOnTarget(u)

            if ad
                destroy this


    function removeAbility() returns boolean
        unit u=GetTriggerUnit()
        if(GetUnitUserData(u)!=0)
            PauseUnit(u,true)

        //This is necessary, picture a value for recycle delay that's higher than the casting time,
        //for example if the spell does dps, if you leave the dummy caster with the ability and it 
        //is owned by an AI player it will start casting the ability on player units, so it is
        // a good idea to pause it...


        return true

    // Might look wrong, but this is the way to make it consider collision size, a spell that
        // got a target circle and uses this method will let the user know which units it will
        // hit with the mass cast.
    function filterAOE() returns boolean
        unit u=GetFilterUnit()
        if IsUnitInRangeXY(u, DummyCaster.aoex, DummyCaster.aoey, DummyCaster.aoeradius)
            DummyCaster.cinstance.castOnTarget(u)


        return false
    //==========================================================================================================
        // private dorecycle method, sorry but I need this up here.
        //
    function dorecycle()
        unit u = DummyCaster.recycle[0]
        int l
        int r
        int p
        real    lt
        IssueImmediateOrder(u,"stop")
        UnitRemoveAbility(u,GetUnitUserData(u))
        SetUnitUserData(u,0)
        SetUnitFlyHeight(u,0,0)
        PauseUnit(u,false)
        
        if DummyCaster.top == DUMMY_STACK_LIMIT
            RemoveUnit(u)
        else
            DummyCaster.dummystack[DummyCaster.top] = u
            DummyCaster.top++
            
        DummyCaster.rn--
        if DummyCaster.rn == 0
            return

        p = 0
        lt = DummyCaster.expiretime[DummyCaster.rn]
        l = p * 2 + 1
        while l < DummyCaster.rn
            r = p * 2 + 2
            if r >= DummyCaster.rn 
                if DummyCaster.expiretime[l] < lt
                    DummyCaster.expiretime[p] = DummyCaster.expiretime[l]
                    DummyCaster.recycle[p] = DummyCaster.recycle[l]
                    p = l
                else
                    break

            else if lt <= DummyCaster.expiretime[l] and lt <= DummyCaster.expiretime[r]
                break
            else if DummyCaster.expiretime[l] < DummyCaster.expiretime[r]
                DummyCaster.expiretime[p] = DummyCaster.expiretime[l]
                DummyCaster.recycle[p] = DummyCaster.recycle[l]
                p = l
            else
                DummyCaster.expiretime[p] = DummyCaster.expiretime[r]
                DummyCaster.recycle[p] = DummyCaster.recycle[r]
                p = r

            l=p*2+1

        DummyCaster.recycle[p] = DummyCaster.recycle[DummyCaster.rn]
        DummyCaster.expiretime[p] = lt
        TimerStart(DummyCaster.T, DummyCaster.expiretime[0] - TimerGetElapsed(DummyCaster.gametime), false, function dorecycle)
            
    init
        unit u
        DummyCaster.aoefunc=Condition(function filterAOE)
        DummyCaster.enumgroup=CreateGroup()
        DummyCaster.abilityRemove = CreateTrigger()
        for int i = INITIAL_DUMMY_COUNT downto 0
            u=CreateUnit(Player(15),DUMMY_UNIT_ID,0,0,0)
            TriggerRegisterUnitEvent(DummyCaster.abilityRemove,u,EVENT_UNIT_SPELL_ENDCAST)
            UnitAddAbility(u,'Aloc')
            UnitAddAbility(u,HEIGHT_ENABLER)
            UnitRemoveAbility(u,HEIGHT_ENABLER)
            DummyCaster.dummystack[DummyCaster.top]=u
            DummyCaster.top++
            print(i.toString())


        TriggerAddCondition(DummyCaster.abilityRemove, Condition(function removeAbility ) )
        DummyCaster.top--
        DummyCaster.instantdummy=DummyCaster.dummystack[DummyCaster.top]
        DummyCaster.T=CreateTimer()
        DummyCaster.gametime=CreateTimer()
        TimerStart(DummyCaster.gametime,12.*60.*60.,false,null)


endpackage 

//===========================================================================
// Trigger: xefx
//===========================================================================
//TESH.scrollpos=180
//TESH.alwaysfold=0
package Fx
/*
This is mostly a copy of xefx, credits for that go to Vexorian
*/
	import Basics
	import ExtensionFunctions
    import Dummy
	
	
    
    //Delay in order to show the death animation of the effect correctly when xefx is destroyed.
    //You may need to increase this if you are using effects with longer death animations.
    constant real    MIN_RECYCLE_DELAY = 4.0

    //The delay does not need to be exact so we do cleanup in batches instead of individually.
    //This determines how often the recycler runs, should be less than MIN_RECYCLE_DELAY.
    constant real    RECYCLE_INTERVAL = 0.5

    //if this is true and the xedummy library is present, units will be recycled instead of removed.
    constant boolean RECYCLE_DUMMY_UNITS = true
    
    timer    recycler = CreateTimer()

    Recyclebin array list
    
    function recycle()
            Recyclebin rb = list[Recyclebin.readindex]
            while Recyclebin.count > 0

                releaseDummyUnit(rb.u)
                rb.u = null
                Recyclebin.count--
                destroy rb
                rb = rb.next

            list[Recyclebin.readindex] = null
            Recyclebin.writeindex=Recyclebin.readindex
            //Recyclebin.readindex++
            if Recyclebin.readindex>R2I(MIN_RECYCLE_DELAY/RECYCLE_INTERVAL+1.0) 
                Recyclebin.readindex=0

            if Recyclebin.count != 0 
                TimerStart(recycler, RECYCLE_INTERVAL, false, function recycle)
                
    class Recyclebin
        unit u

        private Recyclebin next

        private static int readindex = 0
        private static int writeindex = 0
        private static int count = 0

        construct( unit u )
            if Recyclebin.count==0 
                TimerStart(recycler, RECYCLE_INTERVAL, false, function recycle)
                
            Recyclebin.count++
            this.u = u
            SetUnitOwner(u,DUMMY_PLAYER,false)
            next=list[Recyclebin.writeindex]
            list[Recyclebin.writeindex]=this
	
	public class Fx
		private unit dummy
		private effect fx = null
		private real zang  = 0.
        private string sfxPath
		private integer red = 255
		private integer green = 255
		private integer blue = 255
		private integer alpha = 255
		
		// needed?
		private integer abil=0
		
		construct(real x, real y, real facing)
			dummy = newDummyUnit(DUMMY_PLAYER, x,y, facing*bj_RADTODEG)
        
        construct(real x, real y, real facing, string fxpath)
			dummy = newDummyUnit(DUMMY_PLAYER, x,y, facing*bj_RADTODEG)
            setFx( fxpath )
				
		function getOwner() returns player
			return dummy.getOwner()
			
		function setOwner(player p) returns Fx
			dummy.setOwner(p, false)
			return this
			
		function setTeamcolor(playercolor c) returns Fx
			SetUnitColor(dummy, c)
			return this
		
		function setScale(real value) returns Fx
			dummy.setScale(value)
			return this

		function getGreen() returns int
			return green
		
		function getBlue() returns int
			return blue
		
		function getRed() returns int
			return red
		
		function getAlpha() returns int
			return alpha
		
		
		function recolor(int r, int g, int b, int a) returns Fx
			red = r
			green = g
			blue = b
			alpha = a
			dummy.setVertexColor(r, g, b, a)
			return this


		function flash(string fx) returns Fx
			dummy.addEffect(fx, "origin").destr()
			return this

		function getXYAngle() returns real
			return dummy.getFacing()*bj_DEGTORAD

		function setXYAngle(real value) returns Fx
			dummy.setFacing(value*bj_RADTODEG)
			return this
            
        function setXYAngleInstant(real value) returns Fx
            real x = getX()
            real y = getY()
            fx.destr()
			RemoveUnit(dummy)
            dummy = CreateUnit(DUMMY_PLAYER, DUMMY_UNIT_ID, x, y, value*bj_RADTODEG)
				.addAbility('Amrf')
				.removeAbility('Amrf')
				.addAbility('Aloc')
				.setPos(x,y)
            setFx(sfxPath)
			return this

		function getZAngle() returns real
			return zang
			
		function setZAngle(real value) returns Fx
			int i = R2I(value*bj_RADTODEG + 90.5)
			zang = value
			if i >= 180
				i = 179
			else if i < 0
				i = 0
			SetUnitAnimationByIndex(dummy, i)
			return this
		
		function getX() returns real
			return dummy.getX()
			
		function getY() returns real
			return dummy.getY()
		
		function getZ() returns real
			return dummy.getFlyHeight()
		
		function setX(real x) returns Fx
			dummy.setX(x)
			return this
			
		function setY(real y) returns Fx
			dummy.setY(y)
			return this
			
		function setPos(real x, real y) returns Fx
			dummy.setPos(x, y)
			return this
		
		function setZ(real z) returns Fx
			dummy.setFlyHeight(z, 0.)
			return this
		
		function setFx(string newpath) returns Fx
			if fx != null
				fx.destr()
			if newpath == ""
				fx = null
			else                
				fx = dummy.addEffect(newpath, "origin")
            sfxPath = newpath
			return this
				
		ondestroy
            if abil != 0
               UnitRemoveAbility(dummy,abil)
               
            if fx != null
				fx.destr()

            new Recyclebin(dummy)
            dummy=null

		
		function hiddenDestroy()
			dummy.hide()
			destroy this
			
endpackage
//===========================================================================
// Trigger: xedamage
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
package Damager
//===========================================================================================================
    constant integer   MAX_SUB_OPTIONS = 3
    
    constant real      FACTOR_TEST_DAMAGE = 0.01 
    // a low damage to do on units to test their damage factors for specific
    // attacktype/damagetype combos.
    // You'll need something as high as 20.0 to make it work well with armor resistances.
    // (Yes, you read it correctly, 20 ...
    //
    // If you use such a large value, there may be conflicts with some things relying on damage
    // (ie they are not away of the isDummyDamage tag that xedamage posseses.) which may be quite bad if you think about it...
    //  maybe it is better to change it to 0.01 ...  will work fine, just fine - but it will generally ignore armor - 
    // I am leaving it as 0.01 by default, because honestly, I'd rather make it ignore armor than have a lot of people sending me
    // rants about how they detect 20.0 damage where none is visible...
    constant real      MAX_DAMAGE_FACTOR = 3.00
    // The maximum damage factor in the map. I think 3 is fine.
   

    //=======================================================
    constant real      EPSILON = 0.000000001
    unit     dmger
    constant int   MAX_SPACE = 8190 // MAX_SPACE/MAX_SUB_OPTIONS is the instance limit for xedamage, usually big enough...

    public class Damager

        //----
        // fields and methods for a xedamage object, they aid determining valid targets and special
        // damage factor conditions.
        //
        // Notice the default values.
        //
        boolean damageSelf    = false  // the damage and factor methods  usually have a source unit parameter
                                       // xedamage would consider this unit as immune unless you damageSelf to true

        boolean damageAllies  = false  // Alliance dependent target options.
        boolean damageEnemies = true   // *
        boolean damageNeutral = true   // *
        boolean ranged        = true   // Is the attack ranged? This has some effect on the AI of the affected units
                                       // true by default, you may not really need to modify this.

        boolean visibleOnly   = false  // Should only units that are visible for source unit's owner be affected?
        boolean deadOnly      = false  // Should only corpses be affected by "the damage"? (useful when using xedamage as a target selector)
        boolean alsoDead      = false  // Should even corpses and alive units be considered?

        boolean damageTrees   = false  //Also damage destructables? Notice this is used only in certain methods.
                                       //AOE for example targets a circle, so it can affect the destructables
                                       //in that circle, a custom spell using xedamage for targetting configuration
                                       //could also have an if--else implemented so it can verify if it is true
                                       // affect trees manually.

        //
        // Damage type stuff:
        //    .dtype : the "damagetype" , determines if the spell is physical, magical or ultimate.
        //    .atype : the "attacktype" , deals with armor.
        //    .wtype : the "weapontype" , determines the sound effect to be played when damage is done.
        //
        //  Please use common.j/blizzard.j/ some guide to know what damage/attack/weapon types can be used
        //
        damagetype dtype  = DAMAGE_TYPE_UNIVERSAL
        attacktype atype  = ATTACK_TYPE_NORMAL
        weapontype wtype  = WEAPON_TYPE_WHOKNOWS

        //
        // Damage type 'tag' people might use xedamage.isInUse() to detect xedamage usage, there are other static
        //  variables like xedamage.CurrentDamageType and xedamage.CurrentDamageTag. The tag allows you to specify
        //  a custom id for the damage type ** Notice the tag would aid you for some spell stuff, for example,
        //  you can use it in a way similar to Rising_Dusk's damage system.
        //
        int    tag    = 0

        //
        // if true, forceDamage will make xedamage ignore dtype and atype and try as hard as possible to deal 100%
        // damage.
        boolean    forceDamage = false


        //
        // Ally factor! Certain spells probably have double purposes and heal allies while harming enemies. This
        // field allows you to do such thing.
        //
        real     allyfactor = 1.0

        //
        // field: .exception = SOME_UNIT_TYPE
        // This field adds an exception unittype (classification), if the unit belongs to this unittype it will
        // be ignored.
        //
        function setException( unittype ut )
            use_ex = true
            ex_ut = ut


        //
        // field: .required = SOME_UNIT_TYPE
        // This field adds a required unittype (classification), if the unit does not belong to this unittype
        //  it will be ignored.
        //
        function setReq( unittype ut )
            use_req = true
            req_ut = ut

        boolean  use_ex    =  false
        unittype ex_ut = null

        boolean  use_req   = false
        unittype req_ut  = null


        Table fct = new Table()
        Table fc = new Table()
        integer  fcn=0

        //
        // method .factor(SOME_UNIT_TYPE, factor)
        //  You might factor() if you wish to specify a special damage factor for a certain classification,
        // for example d.factor(UNIT_TYPE_STRUCTURE, 0.5) makes xedamage do half damage to structures.
        //
        function factor( unittype ut, real fc )
            if fcn == MAX_SUB_OPTIONS
                printWarning("In one instance of Damager, you are doing too much calls to factor(), please increase MAX_SUB_OPTIONS to allow more, or cut the number of factor() calls")
                return

            fct.setInt( fcn, convertUnitTypeToInt( ut ))
            this.fc.setReal( fcn, fc )
            fcn++


        Table abifct = new Table()
        Table abifc = new Table()
        int  abifcn=0

        //
        // method .abilityFactor('abil', factor)
        //  You might abilityFactor() if you wish to specify a special damage factor for units that have a
        // certain ability/buff.
        // for example d.abilityFactor('A000', 1.5 ) makes units that have the A000 ability take 50% more
        // damage than usual.
        //
        
        function abilityFactor( int abilityId, real fc )
            if abifcn == MAX_SUB_OPTIONS
                printWarning("In one instance of Damager, you are doing too much calls to abilityFactor(), please increase MAX_SUB_OPTIONS to allow more, or cut the number of abilityFactor() calls")
                return

            abifct.setInt( abifcn, abilityId )
            abifc.setReal( abifcn, fc )
            abifcn++


        boolean  usefx  = false
        string   fxpath
        string   fxattach

        //
        // method .useSpecialEffect("effect\\path.mdl", "origin")
        // Makes it add (and destroy) an effect when damage is performed.
        //
        function useSpecialEffect( string path, string attach )
            usefx = true
            fxpath=path
            fxattach=attach


        //********************************************************************
        //* Now, the usage stuff:
        //*

        //================================================================================
        // static method xedamage.isInUse()  will return true during a unit damaged
        // event in case this damage was caused by xedamage, in this case, you can
        // read variables like CurrentDamageType, CurrentAttackType and CurrentDamageTag
        // to be able to recognize what sort of damage was done.
        //
        static damagetype currentDamageType=null
        static attacktype currentAttackType=null
        static int    currentDamageTag =0

        static int    inUse = 0
        function isInUse() returns boolean
            return inUse > 0 //inline friendly.

        
        static boolean isDummyDamage = false

        //========================================================================================================
        // This function calculates the damage factor caused by a certain attack and damage
        // type, it is static : xedamage.getDamageTypeFactor(someunit, ATTAcK_TYPE_NORMAL, DAMAGE_TYPE_FIRE, 100)
        //
        static function getDamageTypeFactor( unit u, attacktype a, damagetype d ) returns real
            real hp = GetWidgetLife(u)
            real mana = GetUnitState(u,UNIT_STATE_MANA)
            real r
            real fc = FACTOR_TEST_DAMAGE

            //Since a unit is in that point, we don't need checks.
            SetUnitX(dmger,GetUnitX(u))
            SetUnitY(dmger,GetUnitY(u))

            SetUnitOwner(dmger,GetOwningPlayer(u),false)
            r = hp
            if hp < FACTOR_TEST_DAMAGE*MAX_DAMAGE_FACTOR 
                 SetWidgetLife(u, hp + FACTOR_TEST_DAMAGE*MAX_DAMAGE_FACTOR )
                 r = hp + FACTOR_TEST_DAMAGE*MAX_DAMAGE_FACTOR
                 fc = GetWidgetLife(u)-hp + EPSILON

            isDummyDamage = true
            UnitDamageTarget(dmger,u, fc ,false,false,a,d,null)
            
            if IsUnitType(u, UNIT_TYPE_DEAD) and (hp>0.405) 
                printError("xedamage: For some reason, the unit being tested by getDamageTypeFactor has died. Verify MAX_DAMAGE_FACTOR is to a correct value. ") 

            
            isDummyDamage = false
            SetUnitOwner(dmger,Player(15),false)
            if (mana>GetUnitState(u,UNIT_STATE_MANA)) 
                //Unit had mana shield, return 1 and restore mana too.
                SetUnitState(u,UNIT_STATE_MANA,mana)
                r=1
            else
                r= (r-GetWidgetLife(u)) / fc

            SetWidgetLife(u,hp)
            return r



        function getTargetFactorCore( unit source, unit target, boolean usetypes ) returns real
            player p=GetOwningPlayer(source)
            boolean allied=IsUnitAlly(target,p)
            boolean enemy =IsUnitEnemy(target,p)
            boolean neutral=allied
            real   f
            real   negf=1.0
            int i

            if damageAllies != damageNeutral
                neutral= allied and not (GetPlayerAlliance(GetOwningPlayer(target),p, ALLIANCE_HELP_REQUEST ))
                //I thought accuracy was not as important as speed , I think that REQUEST is false is enough to consider
                // it neutral.
                //neutral= allied and not (GetPlayerAlliance(GetOwningPlayer(target),p, ALLIANCE_HELP_RESPONSE ))
                //neutral= allied and not (GetPlayerAlliance(GetOwningPlayer(target),p, ALLIANCE_SHARED_XP ))
                //neutral= allied and not (GetPlayerAlliance(GetOwningPlayer(target),p, ALLIANCE_SHARED_SPELLS ))
                allied= allied and not(neutral)


            if (not this.damageAllies) and allied 
                return 0.0
            else if (not this.damageEnemies) and enemy 
                return 0.0
            else if( (not this.damageSelf) and (source==target) ) 
                return 0.0
            else if (not this.damageNeutral) and neutral  
                return 0.0
            else if( this.use_ex and IsUnitType(target, this.ex_ut) ) 
                return 0.0
            else if( this.visibleOnly and not IsUnitVisible(target,p) ) 
                return 0.0
            else if ( this.deadOnly and not IsUnitType(target,UNIT_TYPE_DEAD) ) 
                return 0.0
            else if ( not(this.alsoDead) and IsUnitType(target,UNIT_TYPE_DEAD) ) 
                return 0.0               


            f=1.0
            
            if ( IsUnitAlly(target,p) ) 
                f=f*this.allyfactor
                if f <= -EPSILON  
                    f=-f
                    negf=-1.0

            if (this.use_req and not IsUnitType(target,this.req_ut)) 
                return 0.0


            i=fcn-1
            while i > 0

                if( IsUnitType(target, ConvertUnitType(this.fct.getInt(i)) ) ) 
                    f=f*this.fc.getReal(i)
                    if(f <= -EPSILON) 
                        f=-f
                        negf=-1.0

                i=i-1

            i= abifcn-1
            while i > 0
                if( GetUnitAbilityLevel(target,this.abifct.getInt(i) )>0 ) 
                    f=f*this.abifc.getReal(i)
                    if(f <= -EPSILON) 
                        f=-f
                        negf=-1.0

                i=i-1

            f=f*negf

            if ( f < EPSILON) and (f > -EPSILON) 
                return 0.0

            if( this.forceDamage or not usetypes ) 
                return f

            f=f*Damager.getDamageTypeFactor(target,this.atype,this.dtype)

            if ( f < EPSILON) and (f > -EPSILON) 
                return 0.0


            return f


        //====================================================================
        // With this you might decide if a unit is a valid target for a spell.
        //
        function getTargetFactor( unit source, unit target ) returns real
            return this.getTargetFactorCore(source,target,true)


        //======================================================================
        // a little better, I guess
        //
        function allowedTarget( unit source, unit target ) returns boolean
            return (this.getTargetFactorCore(source,target,false)!=0.0)


        //=======================================================================
        // performs damage to the target unit, for unit 'source'. 
        //
        function damageTarget( unit source, unit target, real damage ) returns boolean
            damagetype dt=currentDamageType
            attacktype at=currentAttackType
            int    tg=currentDamageTag
            real       f = this.getTargetFactorCore(source,target,false)
            real       pl

            if(f!=0.0) 
                currentDamageType = dtype
                currentAttackType = atype
                currentDamageTag  = tag

                
                inUse = inUse +1
                pl=GetWidgetLife(target)
                UnitDamageTarget(source,target,  f*damage, true, ranged, atype, dtype, wtype )
                inUse = inUse -1
                currentDamageTag = tg
                currentDamageType = dt
                currentAttackType = at
                if(pl != GetWidgetLife(target) ) 
                    if(usefx) 
                         DestroyEffect(  AddSpecialEffectTarget(this.fxpath, target, this.fxattach) )

                    return true


            return false


        //=======================================================================================
        // The same as damageTarget, but it forces a specific damage value, good if you already
        // know the target.
        //
        function damageTargetForceValue( unit source, unit target, real damage )
            damagetype dt= currentDamageType
            attacktype at= currentAttackType
            int    tg= currentDamageTag

            currentDamageType = dtype
            currentAttackType = atype
            currentDamageTag  = tag

            if( usefx) 
                DestroyEffect(  AddSpecialEffectTarget(fxpath, target, fxattach) )
            
            inUse = inUse +1
            UnitDamageTarget(source,target,  damage, true, ranged, null, null, wtype )
            inUse = inUse -1
            currentDamageTag  = tg
            currentDamageType = dt
            currentAttackType = at

        //=====================================================================================
        // Notice: this will not Destroy the group, but it will certainly empty the group.
        //
        function damageGroup( unit source, group targetGroup, real damage ) returns int
            damagetype dt=currentDamageType
            attacktype at=currentAttackType
            int    tg=currentDamageTag
            unit       target
            real       f
            int    count=0
            real hp = 0.

            currentDamageType = dtype
            currentAttackType = atype
            currentDamageTag  = tag
            inUse = inUse +1
            target=FirstOfGroup(targetGroup)
            while target != null
                

                GroupRemoveUnit(targetGroup,target)
                f= this.getTargetFactorCore(source,target,false)
                if (f!=0.0) 
                    count=count+1
                    if(usefx) 
                        hp = GetWidgetLife(target)


                    UnitDamageTarget(source,target, f*damage, true, ranged, atype, dtype, wtype )
                    if(usefx and (hp > GetWidgetLife(target)) ) 
                        DestroyEffect(  AddSpecialEffectTarget(this.fxpath, target, this.fxattach) )

                target=FirstOfGroup(targetGroup)



            inUse = inUse -1
            currentDamageTag=tg
            currentDamageType = dt
            currentAttackType = at
            return count


        static Damager instc
        
        int countAOE
        unit    sourceAOE
        real    aoeX
        real    aoeY
        real    aoeRadius
        real    aoeDamage
        static boolexpr filterAOE
        static boolexpr filterDestAOE
        static group    enumgroup
        static rect     aoeRect

        

        //==========================================================================================
        // will affect trees if damageTrees is true!
        // 
        function damageAOE( unit source, real x, real y, real radius, real damage ) returns int
            damagetype dt=currentDamageType
            attacktype at=currentAttackType
            int    tg=currentDamageTag

            currentDamageType = dtype
            currentAttackType = atype
            currentDamageTag  = tag
            inUse = inUse +1
            instc=this
            countAOE=0
            sourceAOE=source
            aoeX=x
            aoeRadius=radius
            aoeY=y
            aoeDamage=damage
            GroupEnumUnitsInRange(enumgroup,x,y,radius+MAX_COLLISION_SIZE, filterAOE)
            if(damageTrees) 
                SetRect(aoeRect, x-radius, y-radius, x+radius, y+radius)
                aoeRadius=aoeRadius*aoeRadius
                EnumDestructablesInRect(aoeRect, filterDestAOE, null)

            inUse = inUse -1
            currentDamageTag  = tg
            currentDamageType = dt
            currentAttackType = at
            return countAOE
    

        //==========================================================================================
        // only affects trees, ignores damageTrees
        // 
        function damageDestructablesAOE( unit source, real x, real y, real radius, real damage ) returns int
            instc=this
            countAOE=0
            sourceAOE=source
            aoeX=x
            aoeRadius=radius*radius
            aoeY=y
            aoeDamage=damage
            //if(.damageTrees) 
            SetRect(aoeRect, x-radius, y-radius, x+radius, y+radius)
            EnumDestructablesInRect(aoeRect, filterDestAOE, null)
            //endif
            return countAOE


        //'friend' with the library init
        static function initD()
            aoeRect= Rect(0,0,0,0)
            filterAOE= Condition(function damageAOE_Enum)
            filterDestAOE = Condition( function damageAOE_DestructablesEnum)
            enumgroup = CreateGroup()
            
    function damageAOE_Enum() returns boolean
        unit target=GetFilterUnit()
        Damager dmg=Damager.instc //adopting a instance.
        real f
        real hp = 0.
     
        if( not IsUnitInRangeXY(target, dmg.aoeX, dmg.aoeY, dmg.aoeRadius) ) 
            target=null
            return false

        f = dmg.getTargetFactorCore(dmg.sourceAOE, target, false)
        if(f!=0.0) 
            dmg.countAOE++
            if(dmg.usefx) 
                hp =GetWidgetLife(target)

            UnitDamageTarget(dmg.sourceAOE,target, f*dmg.aoeDamage, true, dmg.ranged, dmg.atype, dmg.dtype, dmg.wtype )
            if dmg.usefx and (hp > GetWidgetLife(target) ) 
                DestroyEffect(  AddSpecialEffectTarget(dmg.fxpath, target, dmg.fxattach) )


        Damager.instc= dmg //better restore, nesting IS possible!
        target=null
        return false


    function damageAOE_DestructablesEnum() returns boolean
        destructable target=GetFilterDestructable()
        Damager dmg=Damager.instc //adopting a instance.
        real     dx=dmg.aoeX-GetDestructableX(target)
        real     dy=dmg.aoeY-GetDestructableY(target)

        if( dx*dx + dy*dy >= dmg.aoeRadius+EPSILON )  
            target=null
            return false

        dmg.countAOE++
        if(dmg.usefx) 
            DestroyEffect(  AddSpecialEffectTarget(dmg.fxpath, target, dmg.fxattach) )
      
        UnitDamageTarget(dmg.sourceAOE,target, dmg.aoeDamage, true, dmg.ranged, dmg.atype, dmg.dtype, dmg.wtype )

        Damager.instc= dmg //better restore, nesting IS possible!
        target=null
        return false

    init
        dmger=CreateUnit(Player(15), DUMMY_UNIT_ID , 0.,0.,0.)
        UnitAddAbility(dmger,'Aloc')
        Damager.initD()


endpackage


//===========================================================================
// Trigger: xecollider
//===========================================================================
//TESH.scrollpos=289
//TESH.alwaysfold=0
package Collider
    import Fx

//****************************************************************
//*
//* xecollider 0.9
//* --------------
//*  A xecollider object is a special effect that has a collision
//* size that can trigger a hit event and also many options to
//* configure its automatic movement.
//*
//*  Please use .terminate() instead of .destroy() this ensures
//* that it will be safe to destroy it (else you would have to
//* worry about destroying it during the animation loop/etc.)
//*
//*  To use this struct is a little different than the other
//* current parts of xe. Instead of just creating the xecollider
//* (which works, but it would only be a xefx that can have speed)
//* you probably need to make it do something special on the
//* unit hit event... For this reason, you need to make a new
//* struct extending xecollider that declares an onUnitHit method
//* you may also declare a loopControl method, very useful, can
//* help you reduce 'attaching'.
//*
//****************************************************************

//================================================================

    constant real DEFAULT_COLLISION_SIZE  =   50.0 // These are defaults, on one hand you can change them
    constant real DEFAULT_MAX_SPEED       = 1500.0 // on the other hand, if a spell relies on the defaults
    constant real DEFAULT_EXPIRATION_TIME =    5.0 // changing them would make the behavior vary...

    constant real PI2 = 6.28318 //It might not be wise to change this

//================================================================
//  Global Enums, don't change

    constant int ANGLE_HOMING_UNIT  = 1
    constant int ANGLE_HOMING_POINT = 2
    constant int ANGLE_NO_MOVEMENT  = 0
    constant int ANGLE_ROTATING     = 3

    //===========================================================================
    // So, this exists merely so you can declare your own event handler methods
    // if interfaces make your brain blow out, please skip the next four lines.
    //
    interface EventHandler
        function onUnitHit( unit hitTarget )
        function loopControl()

    //===========================================================================
    class Collider extends Fx implements EventHandler
     // use terminate() instead of .destroy() to "kill" the collider.
     // don't worry, terminate will destroy automatically.


        //##==========================================================================
        // public variables:
        //
        real expirationTime = DEFAULT_EXPIRATION_TIME

        // Movement speed for the missile.
        real speed          = 0.0

        // Speed added per second (notice you can use a negative value here)
        real acceleration   = 0.0

        // If there is acceleration, it is wise to have a cap...
        real maxSpeed       = DEFAULT_MAX_SPEED
        real minSpeed       = 0.0

        real angleSpeed     = 0.0 //The increment in radians per second to the
                                         // direction angle, allows curved movement.

        private static int lastSeen = 0
        private group   seen

        //##==========================================================================
        // public methods:
        //

        //----
        // Well, it is a good idea to actually create the missiles.
        // notice that if your custom missile struct needs to declare its own create
        // method, you can this as allocate(x,y,dir).
        //
        // Sorry, no Loc version.
        //
        construct( real x, real y, real dir )
            super( x, y, dir )
            this.dir = dir
            Collider.V[Collider.N] = this
            Collider.N++
            if Collider.N == 1
                TimerStart( Collider.T, ANIMATION_PERIOD, true, function timerLoop )
            
            if Collider.lastSeen < this castTo int  //with this I do group recycling
                Collider.lastSeen = this castTo int
                seen = CreateGroup()

        //----
        // The direction is just the angle in radians to which the missile's model faces
        // and the automatic movement uses.
        //
        function setDirection( real v )
            dir = v
            xyangle = v


        //---
        // targetUnit is a unit to follow (or try to follow), notice that homing
        // options require an angleSpeed different to 0.0
        //
        function setTargetUnit( unit u )
            if u == null 
                angleMode = ANGLE_NO_MOVEMENT
            else
                angleMode = ANGLE_HOMING_UNIT
            
            homingTargetUnit = u


        //----
        // targetPoint is a point to reach (or try to reach), notice that homing
        // options require an angleSpeed different to 0.0
        //
        function setTargetPoint( real x, real y )
            angleMode = ANGLE_HOMING_POINT
            homingTargetX = x
            homingTargetY = y

        //----
        // this in case you used targetUnit or TargetPoint so the missile
        // forgets the order to home that target.
        //
        function forgetTarget()
            angleMode = ANGLE_NO_MOVEMENT
        
        function isRotating() returns boolean
            return angleMode == ANGLE_ROTATING

        function setRotating( boolean val )
            if val
                 angleMode = ANGLE_ROTATING
            else if angleMode == ANGLE_ROTATING
                 angleMode = ANGLE_NO_MOVEMENT
                 
        
        private boolean silent = false
        
        ondestroy
            GroupClear( seen )            


        function terminate()
            dead = true
            fxpath = ""
            
        // declare hiddenDestroy so people don't directly on the delegate xefx
        function hiddenTerminate()
            silent = true
            terminate()


        //--------
        private static timer      T
        private static int    N=0
        private static Collider array V
        
        private        boolean dead = false


        real collisionSize = DEFAULT_COLLISION_SIZE
        real dir



        
        private        int angleMode  =0

        private unit homingTargetUnit = null
        private real homingTargetX
        private real homingTargetY


        private static real       newx
        private static real       newy
        private static group      enumGroup
        private static group      tempGroup

        private static unit array picked
        private static int    pickedN

    function timerLoop()
        int c=0
        Collider cl
        real d
        real ns
        real wa
        real df1
        real df2
        unit u
        group g

        for int i = 0 to Collider.N
            cl = Collider.V[i] //adopt-a-instance
            cl.expirationTime -= ANIMATION_PERIOD
            if cl.dead or cl.expirationTime <= 0.0  
                if silent
                    cl.hiddenDestroy()
                else
                    destroy cl
            else
               ns = cl.angleSpeed * XE_ANIMATION_PERIOD
               if ns != 0.0 
                    if cl.angleMode == ANGLE_HOMING_UNIT 
                       u = cl.homingTargetUnit
                       if ( GetUnitTypeId(u) == 0 ) or IsUnitType( u, UNIT_TYPE_DEAD )  
                           cl.angleMode = ANGLE_NO_MOVEMENT
                           cl.homingTargetUnit = null
                       else
                           cl.homingTargetX = GetUnitX(u)
                           cl.homingTargetY = GetUnitY(u)
                       
                       u = null                           
                    else if cl.angleMode != ANGLE_NO_MOVEMENT 
                        if ns <= 0.
                            ns = -ns
                       
                        wa = Atan2( cl.homingTargetY - cl.y, cl.homingTargetX - cl.x )

                        df1 = wa - cl.dir
                        df2 = (PI2 + wa) - cl.dir

                        if df1 <= 0
                            if df2 <= 0 
                                if df2 >= df1 
                                    df1 = df2
                            else
                                if -df1 >= df2
                                    df1 = df2
                        else
                            if df2 <= 0 
                                if -df2 <= df1
                                    df1 = df2
                            else
                                if df2 <= df1 
                                    df1 = df2
                        if df1 <= 0 
                            if -df1 >= ns 
                                ns = -ns
                            else
                                ns = df1
                        else
                            if df1 <= ns 
                                ns = df1
                    else
                        ns = 0
                   
                    d = cl.dir
                    d += ns
                    if d >= PI2
                        d -= PI2
                    else if d < 0
                        d += PI2
                   
                    cl.dir = d
                    cl.xyangle = d
               

               // function calls are expensive, damned we are, long code inside of loop
               // correct software dev. tells us cl should go to another function,
               // but cl is Jass, not real life.

                ns = cl.speed + cl.acceleration * ANIMATION_PERIOD
                if ns < cl.minSpeed
                    ns = cl.minSpeed
                else if ns > cl.maxSpeed
                    ns = cl.maxSpeed
               
                d = ((cl.speed + ns) /2) * ANIMATION_PERIOD
                cl.speed = ns
                Collider.newx= cl.x+d*Cos(cl.dir)
                Collider.newy= cl.y+d*Sin(cl.dir)
                cl.x = Collider.newx
                cl.y = Collider.newy

                GroupEnumUnitsInRange( Collider.enumGroup, Collider.newx, Collider.newy, cl.collisionSize + MAX_COLLISION_SIZE, null)
                for unit u2 from Collider.enumGroup
                    if not IsUnitType(u2, UNIT_TYPE_DEAD)  and not(cl.dead) and (GetUnitTypeId(u2) != DUMMY_UNITID) and IsUnitInRangeXY(u, Collider.newx, Collider.newy, cl.collisionSize) 
                        GroupAddUnit(Collider.tempGroup, u)
                        if not IsUnitInGroup (u, cl.seen ) 
                            cl.onUnitHit(u)

                g = Collider.tempGroup
                GroupClear(cl.seen)
                Collider.tempGroup = cl.seen
                cl.seen = g
                g = null

                Collider.V[c]=cl
                c++
                if not cl.dead 
                    cl.loopControl()
                   

            //BJDebugMsg("}")
            Collider.N = c
            if c == 0 
                PauseTimer(Collider.T)


        //============================================================================
        // you aren't supposed to doInit yourself, try not to do it.
        //
    init
        Collider.enumGroup = CreateGroup()
        Collider.tempGroup = CreateGroup()
        Collider.T=CreateTimer()

endpackage 

//===========================================================================
// Trigger: SheepStaff
//===========================================================================
//TESH.scrollpos=9
//TESH.alwaysfold=0
//**********************************************
//* Sheep staff.
//*
//* A quick sample for xecast.AOEloc

package SheepStaff
    import Damager
    
    function spellIdMatch() returns boolean
      return (GetSpellAbilityId()=='A006')


    function onSpellCast()
        unit     u   = GetTriggerUnit()
        Damager dmg  = new Damager()
        dmg.dtype = DAMAGE_TYPE_FIRE   // Do spell, fire (magic) damage
        dmg.atype = ATTACK_TYPE_NORMAL //

        dmg.factor( UNIT_TYPE_STRUCTURE , 0.5) //half damage to buildings.

        dmg.damageEnemies = true  // This evil spell pretty much hits
        dmg.damageAllies  = true  // anything that is not invulnerable or
        dmg.damageNeutral = true  // the casting hero himSelf... it would
        dmg.damageSelf    = false // be quite dumb if it was able to hit the hero...
        real x = GetSpellTargetX() 
        real y = GetSpellTargetY()
        
        dmg.damageAOE(u, x, y, 256., 128. )
        SetUnitAnimation(u, "attack")                       // Let's focus on the look of the item cast for a second...


    init
        trigger t=CreateTrigger()
        TriggerAddCondition(t, Condition( function spellIdMatch) )
        TriggerAddAction(t,    function onSpellCast)
        TriggerRegisterAnyUnitEventBJ( t, EVENT_PLAYER_UNIT_SPELL_EFFECT )


endpackage



//===========================================================================
function InitCustomTriggers takes nothing returns nothing
    call InitTrig_xepreload(  )
    call InitTrig_xedummy(  )
    call InitTrig_xecast(  )
    call InitTrig_xefx(  )
    call InitTrig_xedamage(  )
    call InitTrig_xecollider(  )
    call InitTrig_SheepStaff(  )
endfunction

//***************************************************************************
//*
//*  Players
//*
//***************************************************************************

function InitCustomPlayerSlots takes nothing returns nothing

    // Player 0
    call SetPlayerStartLocation( Player(0), 0 )
    call SetPlayerColor( Player(0), ConvertPlayerColor(0) )
    call SetPlayerRacePreference( Player(0), RACE_PREF_HUMAN )
    call SetPlayerRaceSelectable( Player(0), true )
    call SetPlayerController( Player(0), MAP_CONTROL_USER )

    // Player 1
    call SetPlayerStartLocation( Player(1), 1 )
    call SetPlayerColor( Player(1), ConvertPlayerColor(1) )
    call SetPlayerRacePreference( Player(1), RACE_PREF_ORC )
    call SetPlayerRaceSelectable( Player(1), true )
    call SetPlayerController( Player(1), MAP_CONTROL_USER )

    // Player 2
    call SetPlayerStartLocation( Player(2), 2 )
    call SetPlayerColor( Player(2), ConvertPlayerColor(2) )
    call SetPlayerRacePreference( Player(2), RACE_PREF_UNDEAD )
    call SetPlayerRaceSelectable( Player(2), true )
    call SetPlayerController( Player(2), MAP_CONTROL_USER )

    // Player 3
    call SetPlayerStartLocation( Player(3), 3 )
    call SetPlayerColor( Player(3), ConvertPlayerColor(3) )
    call SetPlayerRacePreference( Player(3), RACE_PREF_NIGHTELF )
    call SetPlayerRaceSelectable( Player(3), true )
    call SetPlayerController( Player(3), MAP_CONTROL_USER )

endfunction

function InitCustomTeams takes nothing returns nothing
    // Force: TRIGSTR_014
    call SetPlayerTeam( Player(0), 0 )
    call SetPlayerTeam( Player(1), 0 )
    call SetPlayerTeam( Player(2), 0 )
    call SetPlayerTeam( Player(3), 0 )

endfunction

function InitAllyPriorities takes nothing returns nothing

    call SetStartLocPrioCount( 0, 1 )
    call SetStartLocPrio( 0, 0, 3, MAP_LOC_PRIO_HIGH )

    call SetStartLocPrioCount( 1, 1 )
    call SetStartLocPrio( 1, 0, 2, MAP_LOC_PRIO_HIGH )

    call SetStartLocPrioCount( 2, 1 )
    call SetStartLocPrio( 2, 0, 1, MAP_LOC_PRIO_HIGH )

    call SetStartLocPrioCount( 3, 1 )
    call SetStartLocPrio( 3, 0, 0, MAP_LOC_PRIO_HIGH )
endfunction

//***************************************************************************
//*
//*  Main Initialization
//*
//***************************************************************************

//===========================================================================
function main takes nothing returns nothing
    call SetCameraBounds( -6656.0 + GetCameraMargin(CAMERA_MARGIN_LEFT), -6784.0 + GetCameraMargin(CAMERA_MARGIN_BOTTOM), 6656.0 - GetCameraMargin(CAMERA_MARGIN_RIGHT), 6528.0 - GetCameraMargin(CAMERA_MARGIN_TOP), -6656.0 + GetCameraMargin(CAMERA_MARGIN_LEFT), 6528.0 - GetCameraMargin(CAMERA_MARGIN_TOP), 6656.0 - GetCameraMargin(CAMERA_MARGIN_RIGHT), -6784.0 + GetCameraMargin(CAMERA_MARGIN_BOTTOM) )
    call SetDayNightModels( "Environment\\DNC\\DNCLordaeron\\DNCLordaeronTerrain\\DNCLordaeronTerrain.mdl", "Environment\\DNC\\DNCLordaeron\\DNCLordaeronUnit\\DNCLordaeronUnit.mdl" )
    call NewSoundEnvironment( "Default" )
    call SetAmbientDaySound( "LordaeronSummerDay" )
    call SetAmbientNightSound( "LordaeronSummerNight" )
    call SetMapMusic( "Music", true, 0 )
    call CreateAllItems(  )
    call CreateAllUnits(  )
    call InitBlizzard(  )
    call InitGlobals(  )
    call InitCustomTriggers(  )

endfunction

//***************************************************************************
//*
//*  Map Configuration
//*
//***************************************************************************

function config takes nothing returns nothing
    call SetMapName( "TRIGSTR_020" )
    call SetMapDescription( "TRIGSTR_022" )
    call SetPlayers( 4 )
    call SetTeams( 4 )
    call SetGamePlacement( MAP_PLACEMENT_TEAMS_TOGETHER )

    call DefineStartLocation( 0, -2112.0, 4608.0 )
    call DefineStartLocation( 1, 5376.0, -2112.0 )
    call DefineStartLocation( 2, 2624.0, -5248.0 )
    call DefineStartLocation( 3, -5248.0, 1600.0 )

    // Player setup
    call InitCustomPlayerSlots(  )
    call SetPlayerSlotAvailable( Player(0), MAP_CONTROL_USER )
    call SetPlayerSlotAvailable( Player(1), MAP_CONTROL_USER )
    call SetPlayerSlotAvailable( Player(2), MAP_CONTROL_USER )
    call SetPlayerSlotAvailable( Player(3), MAP_CONTROL_USER )
    call InitGenericPlayerSlots(  )
    call InitAllyPriorities(  )
endfunction

