//===========================================================================
// 
// Sunken Defense 05p
// 
//   Warcraft III map script
//   Generated by the Warcraft III World Editor
//   Date: Sat May 26 11:30:02 2012
//   Map Author: Frotty
// 
//===========================================================================

//***************************************************************************
//*
//*  Global Variables
//*
//***************************************************************************

globals
    // User-defined
    integer                 udg_Spielerzahl            = 0
    timer array             udg_Gametimer
    timerdialog array       udg_TimerWIndow
    unit                    udg_Termal_Eruption_Caster = null
    player                  udg_Termal_Eruption_Owner  = null
    location                udg_Termal_Eruption_Location = null
    integer                 udg_Termal_Eruption_Ability_Level = 0
    real                    udg_Termal_Eruption_Area_of_Effect = 0
    real                    udg_Termal_Eruption_Base_Damage = 0
    real                    udg_Termal_Eruption_Total_Damage = 0
    integer                 udg_Termal_Eruption_Loop_Number = 0
    integer                 udg_Termal_Eruption_Dummy_Ability = 0
    integer                 udg_Termal_Eruption_DummyAbility2 = 0
    group                   udg_Termal_Eruption_Damage_Group = null
    location                udg_Termal_Eruption_Loop_Location = null
    unit                    udg_Multi_Shot_Caster      = null
    player                  udg_Multi_Shot_Owner       = null
    integer                 udg_Multi_Shot_Ability_Level = 0
    real                    udg_Multi_Shot_Facing      = 0
    location                udg_Multi_Shot_Location    = null
    location                udg_Multi_Shot_Location_2  = null
    integer                 udg_Multi_Shot_Base_Arrow_Count = 0
    integer                 udg_Multi_Shot_Total_Arrow_Count = 0
    integer                 udg_Multi_Shot_Dummy_Ability = 0
    location                udg_Multi_Shot_Loop_Location = null
    location                udg_Multi_Shot_Loop_Location2 = null
    hashtable               udg_BA_Hashtable           = null
    integer                 udg_BA_To_Finish           = 0
    location                udg_BA_Startpt             = null
    location                udg_BA_Targetpt            = null
    integer                 udg_BA_Flame_Lvl           = 0
    integer                 udg_BA_Distance            = 0
    real                    udg_BA_Damage              = 0
    real                    udg_BA_Arrow_Angle         = 0
    location                udg_BA_Creatept            = null
    group                   udg_BA_Arrows              = null
    real                    udg_BA_Dealdmg             = 0
    unit                    udg_BA_Arrow               = null
    location                udg_BA_Arrowpt             = null
    location                udg_BA_Movept              = null
    group                   udg_BA_Victims             = null
    hashtable               udg_SphereTable            = null
    location array          udg_Sloc
    integer array           udg_SphereValue
    group                   udg_MissileGroup1          = null
    group                   udg_SphereDamage           = null
    unit                    udg_SphereCaster           = null
    group                   udg_SphereGroup            = null
    group                   udg_MissileGroup2          = null
    integer                 udg_SphereInt              = 0
    real array              udg_SReal
    integer                 udg_creeplvl               = 0
    integer array           udg_integer
    rect array              udg_Gebiet
    unit array              udg_PlayerHero
    integer array           udg_Bosswaves
    integer array           udg_Knight_Bonus
    integer array           udg_Heronumber
    real                    udg_Termal_Eruption_Add_Damage = 0
    string array            udg_CreepStrings

    // Generated
    rect                    gg_rct_Region_000          = null
    rect                    gg_rct_Hero_spawn          = null
    rect                    gg_rct_Mid                 = null
    rect                    gg_rct_Spawn_left_bot      = null
    rect                    gg_rct_Spawn_left_up       = null
    rect                    gg_rct_Spawn_Right_bot     = null
    rect                    gg_rct_Ally_spawn          = null
    rect                    gg_rct_Start               = null
    rect                    gg_rct_Ping_1              = null
    rect                    gg_rct_Ping_2              = null
    rect                    gg_rct_Ping_3              = null
    sound                   gg_snd_HarpyDeath          = null
    sound                   gg_snd_CreepAggroWhat1     = null
    sound                   gg_snd_Rescue              = null
    sound                   gg_snd_Warning             = null
    sound                   gg_snd_Hint                = null
    sound                   gg_snd_GoodJob             = null
    sound                   gg_snd_Credits             = null
    sound                   gg_snd_SecretFound         = null
    trigger                 gg_trg_GlobalInit          = null
    trigger                 gg_trg_Constants           = null
    trigger                 gg_trg_PlayerData          = null
    trigger                 gg_trg_Board               = null
    trigger                 gg_trg_Quests              = null
    trigger                 gg_trg_QueenLevelUp        = null
    trigger                 gg_trg_PlayerCommands      = null
    trigger                 gg_trg_ModeChoosing        = null
    trigger                 gg_trg_HeroChoosing        = null
    trigger                 gg_trg_HeroRevive          = null
    trigger                 gg_trg_RecipeData          = null
    trigger                 gg_trg_Items               = null
    trigger                 gg_trg_WarriorSet          = null
    trigger                 gg_trg_SpawnSystem         = null
    trigger                 gg_trg_BossKill            = null
    trigger                 gg_trg_TowerSystem         = null
    trigger                 gg_trg_Gold                = null
    trigger                 gg_trg_dmginout            = null
    trigger                 gg_trg_FallenSoldier       = null
    trigger                 gg_trg_Deathstop           = null
    trigger                 gg_trg_Deadlife            = null
    trigger                 gg_trg_Death_Aura          = null
    trigger                 gg_trg_AquaBurst           = null
    trigger                 gg_trg_TermalEruption      = null
    trigger                 gg_trg_ExHydratia          = null
    trigger                 gg_trg_Water_Cyclone       = null
    trigger                 gg_trg_Multi_Shot          = null
    trigger                 gg_trg_MultiShot           = null
    trigger                 gg_trg_Hashtable           = null
    trigger                 gg_trg_BA_Init             = null
    trigger                 gg_trg_BA_Loop             = null
    trigger                 gg_trg_Shadow_Explosion    = null
    trigger                 gg_trg_Dark_Arrows         = null
    trigger                 gg_trg_SunRay              = null
    trigger                 gg_trg_Holy_Call           = null
    trigger                 gg_trg_LightShield         = null
    trigger                 gg_trg_Reflections_of_Light = null
    trigger                 gg_trg_Fireball            = null
    trigger                 gg_trg_Hydra               = null
    trigger                 gg_trg_Fire_Attack         = null
    trigger                 gg_trg_Fireworks           = null
    trigger                 gg_trg_Minions             = null
    trigger                 gg_trg_Autocast            = null
    trigger                 gg_trg_DEXP_System         = null
    trigger                 gg_trg_DEXP                = null
    trigger                 gg_trg_Text_Library        = null
    trigger                 gg_trg_xebasic             = null
    trigger                 gg_trg_xepreload           = null
    trigger                 gg_trg_xecast              = null
    trigger                 gg_trg_xefx                = null
    trigger                 gg_trg_xedamage            = null
    trigger                 gg_trg_xecollider          = null
    trigger                 gg_trg_Baum                = null
    trigger                 gg_trg_Knockback           = null
    trigger                 gg_trg_BoolexprUtils       = null
    trigger                 gg_trg_DesLib              = null
    trigger                 gg_trg_ParabolicMovement   = null
    trigger                 gg_trg_BoundSentinel       = null
    trigger                 gg_trg_GroupUtils          = null
    trigger                 gg_trg_timerutils          = null
    trigger                 gg_trg_autofly             = null
    trigger                 gg_trg_table               = null
    trigger                 gg_trg_DDS                 = null
    trigger                 gg_trg_TimerUtils          = null
    trigger                 gg_trg_ABuff               = null
    trigger                 gg_trg_ADamage             = null
    trigger                 gg_trg_SimError            = null
    trigger                 gg_trg_LastOrder           = null
    trigger                 gg_trg_UnitUserData        = null
    trigger                 gg_trg_AbortSpell          = null
    unit                    gg_unit_n000_0000          = null
    unit                    gg_unit_H000_0008          = null
    unit                    gg_unit_n00L_0027          = null
    unit                    gg_unit_n00H_0026          = null
    unit                    gg_unit_n001_0021          = null
    unit                    gg_unit_n00G_0022          = null
    unit                    gg_unit_n00H_0023          = null
    unit                    gg_unit_n00H_0025          = null
endglobals

function InitGlobals takes nothing returns nothing
    local integer i = 0
    set udg_Spielerzahl = 0
    set i = 0
    loop
        exitwhen (i > 10)
        set udg_Gametimer[i] = CreateTimer()
        set i = i + 1
    endloop

    set udg_Termal_Eruption_Ability_Level = 0
    set udg_Termal_Eruption_Area_of_Effect = 0
    set udg_Termal_Eruption_Base_Damage = 0
    set udg_Termal_Eruption_Total_Damage = 0
    set udg_Termal_Eruption_Loop_Number = 0
    set udg_Termal_Eruption_Damage_Group = CreateGroup()
    set udg_Multi_Shot_Ability_Level = 0
    set udg_Multi_Shot_Facing = 0
    set udg_Multi_Shot_Base_Arrow_Count = 0
    set udg_Multi_Shot_Total_Arrow_Count = 0
    set udg_BA_To_Finish = 0
    set udg_BA_Flame_Lvl = 0
    set udg_BA_Distance = 0
    set udg_BA_Damage = 0
    set udg_BA_Arrow_Angle = 0
    set udg_BA_Arrows = CreateGroup()
    set udg_BA_Dealdmg = 0
    set udg_BA_Victims = CreateGroup()
    set i = 0
    loop
        exitwhen (i > 1)
        set udg_SphereValue[i] = 0
        set i = i + 1
    endloop

    set udg_MissileGroup1 = CreateGroup()
    set udg_SphereDamage = CreateGroup()
    set udg_SphereGroup = CreateGroup()
    set udg_MissileGroup2 = CreateGroup()
    set i = 0
    loop
        exitwhen (i > 1)
        set udg_SReal[i] = 0
        set i = i + 1
    endloop

    set udg_creeplvl = 1
    set i = 0
    loop
        exitwhen (i > 20)
        set udg_integer[i] = 0
        set i = i + 1
    endloop

    set i = 0
    loop
        exitwhen (i > 6)
        set udg_Knight_Bonus[i] = 0
        set i = i + 1
    endloop

    set i = 0
    loop
        exitwhen (i > 3)
        set udg_Heronumber[i] = 0
        set i = i + 1
    endloop

    set udg_Termal_Eruption_Add_Damage = 0
    set i = 0
    loop
        exitwhen (i > 25)
        set udg_CreepStrings[i] = ""
        set i = i + 1
    endloop

endfunction

//***************************************************************************
//*
//*  Sounds
//*
//***************************************************************************

function InitSounds takes nothing returns nothing
    set gg_snd_HarpyDeath = CreateSound( "Units\\Creeps\\Harpy\\HarpyDeath.wav", false, true, true, 10, 10, "DefaultEAXON" )
    call SetSoundParamsFromLabel( gg_snd_HarpyDeath, "HarpyDeath" )
    call SetSoundDuration( gg_snd_HarpyDeath, 2533 )
    call SetSoundChannel( gg_snd_HarpyDeath, 0 )
    call SetSoundVolume( gg_snd_HarpyDeath, 50 )
    call SetSoundDistances( gg_snd_HarpyDeath, 600.0, 2000.0 )
    call SetSoundDistanceCutoff( gg_snd_HarpyDeath, 1000.0 )
    set gg_snd_CreepAggroWhat1 = CreateSound( "Sound\\Interface\\CreepAggroWhat1.wav", false, false, false, 10, 10, "CombatSoundsEAX" )
    call SetSoundParamsFromLabel( gg_snd_CreepAggroWhat1, "CreepAggro" )
    call SetSoundDuration( gg_snd_CreepAggroWhat1, 1236 )
    set gg_snd_Rescue = CreateSound( "Sound\\Interface\\Rescue.wav", false, false, false, 10, 10, "" )
    call SetSoundParamsFromLabel( gg_snd_Rescue, "Rescue" )
    call SetSoundDuration( gg_snd_Rescue, 3796 )
    set gg_snd_Warning = CreateSound( "Sound\\Interface\\Warning.wav", false, false, false, 10, 10, "" )
    call SetSoundParamsFromLabel( gg_snd_Warning, "Warning" )
    call SetSoundDuration( gg_snd_Warning, 1904 )
    set gg_snd_Hint = CreateSound( "Sound\\Interface\\Hint.wav", false, false, false, 10, 10, "" )
    call SetSoundParamsFromLabel( gg_snd_Hint, "Hint" )
    call SetSoundDuration( gg_snd_Hint, 2006 )
    set gg_snd_GoodJob = CreateSound( "Sound\\Interface\\GoodJob.wav", false, false, false, 10, 10, "" )
    call SetSoundParamsFromLabel( gg_snd_GoodJob, "GoodJob" )
    call SetSoundDuration( gg_snd_GoodJob, 2548 )
    set gg_snd_Credits = CreateSound( "Sound\\Music\\mp3Music\\Credits.mp3", false, false, false, 10, 10, "DefaultEAXON" )
    call SetSoundParamsFromLabel( gg_snd_Credits, "CreditsMusic" )
    call SetSoundDuration( gg_snd_Credits, 83017 )
    call SetSoundPitch( gg_snd_Credits, 2.0 )
    set gg_snd_SecretFound = CreateSound( "Sound\\Interface\\SecretFound.wav", false, false, false, 10, 10, "" )
    call SetSoundParamsFromLabel( gg_snd_SecretFound, "SecretFound" )
    call SetSoundDuration( gg_snd_SecretFound, 2525 )
endfunction

//***************************************************************************
//*
//*  Unit Creation
//*
//***************************************************************************

//===========================================================================
function CreateBuildingsForPlayer0 takes nothing returns nothing
    local player p = Player(0)
    local unit u
    local integer unitID
    local trigger t
    local real life

    set u = CreateUnit( p, 'n002', 768.0, 384.0, 270.000 )
    set u = CreateUnit( p, 'n002', 320.0, 832.0, 270.000 )
    set u = CreateUnit( p, 'n004', 1440.0, 864.0, 270.000 )
    set u = CreateUnit( p, 'n009', 1248.0, 1440.0, 270.000 )
    set u = CreateUnit( p, 'n00U', 576.0, 1728.0, 270.000 )
    call SetUnitColor( u, ConvertPlayerColor(0) )
endfunction

//===========================================================================
function CreateUnitsForPlayer0 takes nothing returns nothing
    local player p = Player(0)
    local unit u
    local integer unitID
    local trigger t
    local real life

    set gg_unit_H000_0008 = CreateUnit( p, 'H000', 954.2, 920.7, 223.987 )
endfunction

//===========================================================================
function CreateUnitsForPlayer1 takes nothing returns nothing
    local player p = Player(1)
    local unit u
    local integer unitID
    local trigger t
    local real life

    set u = CreateUnit( p, 'H002', 492.4, 541.2, 169.430 )
    call SetHeroLevel( u, 5, false )
    call SelectHeroSkill( u, 'A009' )
    call IssueImmediateOrder( u, "" )
    call SelectHeroSkill( u, 'A003' )
    call IssueImmediateOrder( u, "" )
    call SelectHeroSkill( u, 'A001' )
    call SelectHeroSkill( u, 'A001' )
    call SelectHeroSkill( u, 'A001' )
    call IssueImmediateOrder( u, "" )
endfunction

//===========================================================================
function CreateBuildingsForPlayer11 takes nothing returns nothing
    local player p = Player(11)
    local unit u
    local integer unitID
    local trigger t
    local real life

    set u = CreateUnit( p, 'n007', -2112.0, 1984.0, 270.000 )
    set u = CreateUnit( p, 'n007', -2496.0, 1600.0, 270.000 )
    set u = CreateUnit( p, 'n007', -2368.0, -1920.0, 270.000 )
    set u = CreateUnit( p, 'n007', -1984.0, -2304.0, 270.000 )
    set u = CreateUnit( p, 'n007', 2048.0, -2496.0, 270.000 )
    set u = CreateUnit( p, 'n007', 2432.0, -2048.0, 270.000 )
    set gg_unit_n00H_0023 = CreateUnit( p, 'n00H', 3008.0, -3008.0, 270.000 )
    set gg_unit_n00H_0025 = CreateUnit( p, 'n00H', -3008.0, -3008.0, 270.000 )
    set gg_unit_n00H_0026 = CreateUnit( p, 'n00H', -3008.0, 2496.0, 270.000 )
endfunction

//===========================================================================
function CreateUnitsForPlayer11 takes nothing returns nothing
    local player p = Player(11)
    local unit u
    local integer unitID
    local trigger t
    local real life

    set u = CreateUnit( p, 'n005', -362.0, 170.0, 53.956 )
    set u = CreateUnit( p, 'n005', -555.3, 142.5, 259.307 )
    set u = CreateUnit( p, 'n005', -634.0, 129.7, 177.226 )
    set u = CreateUnit( p, 'n005', -654.9, 81.5, 193.288 )
    set u = CreateUnit( p, 'n005', -644.0, 44.7, 77.654 )
    set u = CreateUnit( p, 'n005', -564.4, 3.0, 245.080 )
    set u = CreateUnit( p, 'n005', -487.8, 0.7, 168.480 )
    set u = CreateUnit( p, 'n005', -424.9, 25.4, 318.580 )
    set u = CreateUnit( p, 'n005', -395.9, 72.1, 335.225 )
    set u = CreateUnit( p, 'n005', -372.3, 124.3, 78.862 )
    set u = CreateUnit( p, 'n005', -436.0, 164.0, 298.815 )
    set u = CreateUnit( p, 'n005', -467.7, 101.4, 307.528 )
    set u = CreateUnit( p, 'n00A', 322.9, -347.8, 209.208 )
    set u = CreateUnit( p, 'n00A', 357.2, -501.0, 263.647 )
    set u = CreateUnit( p, 'n00A', 355.3, -589.3, 92.233 )
    set u = CreateUnit( p, 'n00A', 317.9, -638.1, 53.868 )
    set u = CreateUnit( p, 'n00A', 134.0, -686.6, 288.092 )
    set u = CreateUnit( p, 'n00A', 34.0, -706.8, 306.319 )
    set u = CreateUnit( p, 'n00A', 12.8, -680.6, 100.638 )
    set u = CreateUnit( p, 'n00A', 27.6, -608.2, 23.171 )
    set u = CreateUnit( p, 'n00A', 90.9, -572.3, 195.574 )
    set u = CreateUnit( p, 'n00A', 237.7, -531.3, 135.092 )
    set u = CreateUnit( p, 'n00A', 283.0, -521.1, 129.467 )
    set u = CreateUnit( p, 'n00A', 338.2, -477.1, 288.521 )
    set u = CreateUnit( p, 'n00A', 351.0, -426.0, 127.643 )
    set u = CreateUnit( p, 'n00A', 256.4, -631.8, 106.746 )
    set u = CreateUnit( p, 'n00A', 223.4, -741.2, 128.830 )
    set u = CreateUnit( p, 'n00A', 178.6, -650.0, 83.751 )
    set u = CreateUnit( p, 'n00A', 207.1, -574.8, 209.922 )
    set u = CreateUnit( p, 'n00A', 230.7, -599.4, 304.243 )
    set u = CreateUnit( p, 'n00A', 246.6, -712.2, 116.547 )
    set u = CreateUnit( p, 'n00A', 262.9, -761.0, 199.836 )
    set u = CreateUnit( p, 'n00A', 310.3, -730.6, 111.548 )
    set u = CreateUnit( p, 'n00A', 379.3, -687.3, 261.120 )
    set u = CreateUnit( p, 'n00A', 156.3, -764.9, 38.948 )
    set u = CreateUnit( p, 'n00A', 124.4, -757.6, 301.144 )
    set u = CreateUnit( p, 'n00A', 147.9, -659.0, 261.263 )
    set u = CreateUnit( p, 'n00A', 181.5, -618.7, 286.268 )
endfunction

//===========================================================================
function CreateNeutralPassiveBuildings takes nothing returns nothing
    local player p = Player(PLAYER_NEUTRAL_PASSIVE)
    local unit u
    local integer unitID
    local trigger t
    local real life

    set gg_unit_n000_0000 = CreateUnit( p, 'n000', 3008.0, 2688.0, 270.000 )
    call SetUnitColor( gg_unit_n000_0000, ConvertPlayerColor(0) )
    set gg_unit_n001_0021 = CreateUnit( p, 'n001', 1664.0, 1600.0, 270.000 )
    call SetUnitColor( gg_unit_n001_0021, ConvertPlayerColor(0) )
    set gg_unit_n00G_0022 = CreateUnit( p, 'n00G', 1216.0, 1792.0, 270.000 )
    call SetUnitColor( gg_unit_n00G_0022, ConvertPlayerColor(0) )
    set gg_unit_n00L_0027 = CreateUnit( p, 'n00L', 1472.0, 1792.0, 270.000 )
    call SetUnitColor( gg_unit_n00L_0027, ConvertPlayerColor(0) )
endfunction

//===========================================================================
function CreatePlayerBuildings takes nothing returns nothing
    call CreateBuildingsForPlayer0(  )
    call CreateBuildingsForPlayer11(  )
endfunction

//===========================================================================
function CreatePlayerUnits takes nothing returns nothing
    call CreateUnitsForPlayer0(  )
    call CreateUnitsForPlayer1(  )
    call CreateUnitsForPlayer11(  )
endfunction

//===========================================================================
function CreateAllUnits takes nothing returns nothing
    call CreateNeutralPassiveBuildings(  )
    call CreatePlayerBuildings(  )
    call CreatePlayerUnits(  )
endfunction

//***************************************************************************
//*
//*  Regions
//*
//***************************************************************************

function CreateRegions takes nothing returns nothing
    local weathereffect we

    set gg_rct_Region_000 = Rect( 2656.0, 2400.0, 2848.0, 2592.0 )
    set gg_rct_Hero_spawn = Rect( 608.0, 640.0, 736.0, 768.0 )
    set gg_rct_Mid = Rect( -352.0, -352.0, -96.0, -96.0 )
    set gg_rct_Spawn_left_bot = Rect( -3200.0, -3200.0, -3072.0, -3072.0 )
    set gg_rct_Spawn_left_up = Rect( -3200.0, 2560.0, -3072.0, 2688.0 )
    set gg_rct_Spawn_Right_bot = Rect( 3072.0, -3200.0, 3200.0, -3072.0 )
    set gg_rct_Ally_spawn = Rect( 1376.0, 672.0, 1504.0, 800.0 )
    set gg_rct_Start = Rect( 2464.0, 2304.0, 3264.0, 2976.0 )
    set gg_rct_Ping_1 = Rect( -1696.0, 1152.0, -1632.0, 1216.0 )
    set gg_rct_Ping_2 = Rect( -1600.0, -1600.0, -1536.0, -1536.0 )
    set gg_rct_Ping_3 = Rect( 1376.0, -1472.0, 1440.0, -1408.0 )
endfunction

//***************************************************************************
//*
//*  Triggers
//*
//***************************************************************************

//===========================================================================
// Trigger: GlobalInit
//===========================================================================
//TESH.scrollpos=24
//TESH.alwaysfold=0
package GlobaleInit
    
    import Constants
    import TimerUtils
    import PlayerData
    import ModeChoosing
    import HeroChoosing
    import QueenLevelUp
    import BossKill
    import Board
    import RecipeData
    import Items
    import HeroRevive
    import SpawnSystem
    import WarriorSet
    import TowerSystem
    import Gold
    import Quests
    import FallenSoldier
    import Deathstop
    import Deadlife
    import DeathAura
    import AquaBurst
    import TermalEruption
    //import ExHydratia
    
    function initAll( )
        initConstants( )
        initPlayerData( )
        initBoard( )
        initModeChoosing( )
        initHeroChoosing( )
        initQueenLevelUp( )
        initBossKill( )
        initRecipeData( )
        initItems( )
        initHeroRevive( )
        initSpawnSystem( )
        initWarriorSet( )
        initTowerSystem( )
        initGold( )
        initQuests( )
        initFallenSoldier( )
        initDeathstop( )
        initDeadlife( )
        initDeathAura( )
        initAquaBurst( )
        initTermalEruption( )
        //initExHydratia( )
        CreateTextTagUnitBJ( "Misc Shop", gg_unit_n001_0021, 0, 10, 100, 100, 100, 0 )
        CreateTextTagUnitBJ( "Armory", gg_unit_n00G_0022, 0, 10, 100, 100, 100, 0 )
        CreateTextTagUnitBJ( "Blacksmith", gg_unit_n00L_0027, 0, 10, 100, 100, 100, 0 )
        DestroyTimer( GetExpiredTimer( ) )
    
    init
        timer t = CreateTimer( )
        t.start( 0.01, function initAll )
    
endpackage //===========================================================================
// Trigger: Constants
//===========================================================================
//TESH.scrollpos=15
//TESH.alwaysfold=0
package Constants
        
    public constant string MAP_CREATOR = "Frotty"
    public constant string MAP_VERSION = "05q"
    
    public string array colorcode 
    public int array HERO_ID
    public constant int HERO_COUNT = 5
    public string array mBPic
    
    function setUpColorCodes()
        colorcode[ 0 ] = "|cffFF0202" // rot
        colorcode[ 1 ] = "|cff0041FF" // blau
        colorcode[ 2 ] = "|cff1BE6B8" // teal
        colorcode[ 3 ] = "|cff530080" // lila
        colorcode[ 4 ] = "|cffFFCC00" // gelb
        colorcode[ 5 ] = "|cffFE890D" // orange
        colorcode[ 6 ] = "|cff1FBF00" // gruen
        colorcode[ 7 ] = "|cffE55AAF" // pink
        colorcode[ 8 ] = "|cff949596" // grau
        colorcode[ 9 ] = "|cff7DBEF1" // hellblau
        colorcode[ 10 ] = "|cff0F6145" // dunkelgrün
    
    function initHerostuff()
        mBPic[ 1 ] = "ReplaceableTextures\\CommandButtons\\BTNHeroAvatarOfFlame.blp"
        mBPic[ 2 ] = "ReplaceableTextures\\CommandButtons\\BTNSeaElemental.blp"
        mBPic[ 3 ] = "ReplaceableTextures\\CommandButtons\\BTNBansheeRanger.blp" 
        mBPic[ 4 ] = "ReplaceableTextures\\CommandButtons\\BTNSpellBreaker.blp"
        mBPic[ 5 ] = "ReplaceableTextures\\CommandButtons\\BTNTichondrius.blp"
        HERO_ID[ 1 ] = 'H001'
        HERO_ID[ 2 ] = 'H002'
        HERO_ID[ 3 ] = 'H003'
        HERO_ID[ 4 ] = 'H006'
        HERO_ID[ 5 ] = 'H004'
    
    
    public function initConstants()
        setUpColorCodes()
        initHerostuff()
        
endpackage //===========================================================================
// Trigger: PlayerData
//===========================================================================
//TESH.scrollpos=66
//TESH.alwaysfold=0
package PlayerData
    
    import Constants
    import Board
    import HeroRevive
    
    public int              playerCount = 0
    public SPlayer array    players
    public SPlayer array    sortedPlayers
    
    trigger                 leaveTrigger
    
    public constant player ENEMY = Player( 11 )
    
    constant int    SELECTOR_ID = 'slct'
    constant real   SELECTOR_X  = 2735.
    constant real   SELECTOR_Y  = 2445.
    
    class SPlayer
        player p
        int id
        int sortedId
        unit hero
        unit selector
        
        construct( player p, int id, int sid )
            this.p = p
            this.id = id
            sortedId = sid
            selector = CreateUnit( p, SELECTOR_ID, SELECTOR_X, SELECTOR_Y, 0. )

            
            if GetLocalPlayer() == p
                SetCameraTargetController( gg_unit_n000_0000, 0., 0., FALSE)
                
            
            TriggerRegisterPlayerEvent( leaveTrigger, p, EVENT_PLAYER_LEAVE )
            TriggerRegisterPlayerChatEvent( leaveTrigger, p, "-leave", TRUE )
                
            
        function setHero( unit hero, real x, real y)
            this.hero = hero
            SetUnitX( hero, x )
            SetUnitY( hero, y )
            
            if GetLocalPlayer( ) == p
                ClearSelection( )
                SelectUnit( hero, TRUE )
                PanCameraToTimed( x, y, 0.)
            
            RemoveUnit( selector )
            
            string path = ""
            for int i = 1 to HERO_COUNT
                if GetUnitTypeId( hero ) == HERO_ID[ i ]
                    path = mBPic[ i ]
                    break
                    
            playerBoard.setItemIcon( sortedId + 1, 0, path )
            
            addHeroToReviveSystem( hero )
            
    function playerLeave( )
        player p = GetTriggerPlayer()
        
        for int i = 0 to playerCount - 1
            if sortedPlayers[ i ].p == p
                playerBoard.setItemText( i + 1, 0, "|cff8C8C8C" + GetPlayerName( p ) + "|r" )
                playerBoard.setItemIcon( i + 1, 0, "ReplaceableTextures\\CommandButtons\\BTNCancel.blp" )
                RemoveUnit( sortedPlayers[ i ].hero )
                DisplayTextToForce( GetPlayersAll(), colorcode[ GetPlayerId( p ) ] + GetPlayerName( p ) + " |cffFFCC00has left the game...|r" )
                for int x = i to playerCount - 2
                    sortedPlayers[ i ] = sortedPlayers[ i + 1 ]
                destroy sortedPlayers[ playerCount - 1 ]
                destroy players[ GetPlayerId( p ) ]
                playerCount--
                return
    
    function selectHeroTavern( )
        ClearSelection( )
        SelectUnit( gg_unit_n000_0000, TRUE )
        DestroyTrigger( GetTriggeringTrigger( ) )
    
    public function initPlayerData( )
        leaveTrigger = CreateTrigger( )
        leaveTrigger.addAction( function playerLeave )
        
        for int i = 1 to 5
            if GetPlayerSlotState( Player( i ) ) == PLAYER_SLOT_STATE_PLAYING and GetPlayerController( Player( i ) ) == MAP_CONTROL_USER
               players[ i ]                 = new SPlayer( Player( i ), i, playerCount )
               sortedPlayers[ playerCount ] = players[ i ]
               playerCount++
               
        trigger t = CreateTrigger( )
        TriggerRegisterTimerEvent( t, 0.2, FALSE )
        t.addAction( function selectHeroTavern )

endpackage //===========================================================================
// Trigger: Board
//===========================================================================
//TESH.scrollpos=23
//TESH.alwaysfold=0
package Board
    
    import Constants
    import TimerUtils
    import PlayerData
    
    public Board playerBoard
    
    class Board
        multiboard  mb
        int         columnCount
        int         rowCount

        int         atPos           = 0
        
        construct( int rows, int columns, string title )
            mb = CreateMultiboard( )
            
            columnCount = columns
            rowCount = rows
            mb.setColumnCount( columnCount )
            mb.setRowCount( rowCount )
            
            mb.setTitle(title)
            
            for int i = 1 to columns
                for int i2 = 0 to rows
                    MultiboardSetItemStyle( MultiboardGetItem( mb, i2, i ), TRUE, FALSE )
                    MultiboardSetItemWidth( MultiboardGetItem( mb, i2, 0 ), .07 )
                    MultiboardSetItemWidth( MultiboardGetItem( mb, i2, 1 ), .06 )
                    MultiboardSetItemWidth( MultiboardGetItem( mb, i2, 2 ), .06 )
                    MultiboardSetItemWidth( MultiboardGetItem( mb, i2, 3 ), .03 )
            
            MultiboardSetItemIcon( MultiboardGetItem( mb, 0, 0 ), "ReplaceableTextures\\CommandButtons\\BTNSelectHeroOn.blp" )
            MultiboardSetItemValue( MultiboardGetItem( mb, 0, 0 ), "Player" )
            MultiboardSetItemValue( MultiboardGetItem( mb, 0, 1 ), "Dmg Output" )
            MultiboardSetItemValue( MultiboardGetItem( mb, 0, 2 ), "Dmg Intake" )
            MultiboardSetItemValue( MultiboardGetItem( mb, 0, 3 ), "Gold" )
            
            mb.display( TRUE )
            print("done")
            

        function setItemText( int row, int column, string text )
            MultiboardSetItemValue( MultiboardGetItem( mb, row, column ), text )
            
        function setItemIcon( int row, int column, string path )
            MultiboardSetItemIcon( MultiboardGetItem( mb, row, column ), path )
    
    public function initBoard() 
        playerBoard = new Board( playerCount + 1, 4, "Sunken Defense " + MAP_VERSION + " - [00:00]" )
        for int i = 0 to playerCount-1
            playerBoard.setItemText( i+1, 0, colorcode[sortedPlayers[i].id] + GetPlayerName(sortedPlayers[i].p) )
            print("y" + playerCount.toString())
    

endpackage //===========================================================================
// Trigger: Quests
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
package Quests
    
    public function initQuests( )
        quest readMe = CreateQuest( )
        QuestSetTitle( readMe, "Alpha Readme" )
        QuestSetDescription( readMe, "At first: Thx for testing!\nThis is the Alpha Version of the Map Sunken Hero Defense made by Frotty." )
        QuestSetIconPath( readMe, "ReplaceableTextures\\CommandButtons\\BTNSelectHeroOn.blp" )
        QuestSetRequired( readMe, TRUE )
        QuestSetDiscovered( readMe, TRUE )
        QuestSetCompleted( readMe, FALSE )
        
        quest changelog = CreateQuest( )
        QuestSetTitle( changelog, "Changelog" )
        QuestSetDescription( changelog, "V 01 - 03c : Development started, 2 Heros, 4 Items, 3 Waves, fix found bugs\nV 03d : 3rd Hero added, new wave, new waveskills, few terrain changes, revive bug fix\nV 03e : Hero Spell Pos fixed, tooltips fixed, spawnbug fixed\nV 03f : nerfed some abilitys, improved the spawning grounds, item stacksystem added, 2 new items (recipe system), minor fixes\nV 03g : fixed another spawn bug(yeah..), new boss and new caster waves, terrain changed to more visibility, minor changes on spells\nV 03h : fixed a critical revive bug, fixed creeps, minor bugfixing\nV 03i : Added Previewpic (alpha), New Hero, new items, much other minor stuff.\nV 03k : Fixed Spells, fixed tooltips, fixed hotkeys, Game ends now after 30 secs\nV 03-05f: New Hero, Fixed and balanced Spells, New Spawn balance, Terrain Changes, Lanes balanced, new Items, New System and all the other stuff!\nC 05g: Added Tower Rebuild System" )
        QuestSetIconPath( changelog, "ReplaceableTextures\\CommandButtons\\BTNStaffOfNegation.blp" )
        QuestSetRequired( changelog, TRUE )
        QuestSetDiscovered( changelog, TRUE )
        QuestSetCompleted( changelog, FALSE )
        
        quest credits = CreateQuest( )
        QuestSetTitle( credits, "Credits" )
        QuestSetDescription( credits, "So yes, this is a small project, and i dont want to do everything alone.\nSO I imported many stuff, here are the credits:\n- -BerZeKeR-\n- Paladon\n- BlackRose\n- krisserz\n- Kricz\n- Vexorian\n- Rising_Dust\n- Flame_Phoenix\n- Azlier\n- Anitarf\n- bananaHUNT" )
        QuestSetIconPath( credits, "ReplaceableTextures\\CommandButtons\\BTNStaffOfSanctuary.blp" )
        QuestSetRequired( credits, TRUE )
        QuestSetDiscovered( credits, TRUE )
        QuestSetCompleted( credits, FALSE )
        
        quest forNoobs = CreateQuest( )
        QuestSetTitle( forNoobs, "Whats this?" )
        QuestSetDescription( forNoobs, "Okay now the game started, propably with me as host, and you dont know anything!\nHere is a short introduction:\n- This is a Hero Defense, which means, you got 1 Hero to defense the (in this case) Naga Queen from incoming Creeps.\n- Creeps are coming from 3 lanes, left, bottom and right.\n- You get a Message when a special wave is coming from any side\n- Regenerate life and Mana at fountain behind the Naga Queen, you can also buy items there\n- If you die, you revive after a short period which is calculated like that: ('Herolvl' * 2 + 10) you dont loose any items\n- and now play! slay the monsters to get gold and exp!" )
        QuestSetIconPath( forNoobs, "ReplaceableTextures\\CommandButtons\\BTNSpellBookBLS.blp" )
        QuestSetRequired( forNoobs, FALSE )
        QuestSetDiscovered( forNoobs, TRUE )
        QuestSetCompleted( forNoobs, FALSE )
    
endpackage //===========================================================================
// Trigger: QueenLevelUp
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
package QueenLevelUp
    
    trigger trig
    
    function onLevelUp( )
        int lvl = GetHeroLevel( gg_unit_H000_0008 )
        if      lvl == 3
            UnitAddAbility( gg_unit_H000_0008, 'A01P' )
            SetUnitAbilityLevel( gg_unit_H000_0008, 'A01P', 1 )
        else if lvl == 6
            SetUnitAbilityLevel( gg_unit_H000_0008, 'A01P', 2 )
        else if lvl == 9
            SetUnitAbilityLevel( gg_unit_H000_0008, 'A01P', 3 )
            trig.destr( )
    
    public function initQueenLevelUp( )
        trig = CreateTrigger( )
        TriggerRegisterUnitEvent( trig, gg_unit_H000_0008, EVENT_UNIT_HERO_LEVEL )
        trig.addAction( function onLevelUp )
    
endpackage //===========================================================================
// Trigger: PlayerCommands
//===========================================================================
//TESH.scrollpos=5
//TESH.alwaysfold=0
package PlayerCommands
    
    import PlayerData
    import ModeChoosing
    
    trigger trig
    
    function chatMessageHandler( )
        int     pID     = GetPlayerId( GetTriggerPlayer( ) )
        string  message = GetEventPlayerChatString( )
        string  command = message.substring( 1, message.length() )
        
        if      command == "clear"
            if GetLocalPlayer( ) == players[ pID ].p
                ClearTextMessages( )
        else if command == "mode"
            if GetLocalPlayer( ) == players[ pID ].p
                print( "Selected mode: " + MODE_COLOR_NAME[ difficulty ] + "|r" )
                print( " " )
                print( " " )
        else
            if GetLocalPlayer( ) == players[ pID ].p
                print( "[|cffee0000" + command + "|r] is a not supported command." )
    
    public function initPlayerCommands( )
        trig = CreateTrigger( )
        for int i = 0 to playerCount - 1
            TriggerRegisterPlayerChatEvent( trig, sortedPlayers[ i ].p, "-", FALSE )
        trig.addAction( function chatMessageHandler )
endpackage //===========================================================================
// Trigger: ModeChoosing
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
package ModeChoosing
    
    import TimerUtils
    import PlayerData
    import PlayerCommands
    
    public string  array   MODE_COLOR_NAME
    
    trigger     trig
    timer       tim
    timerdialog timD
    
    int     array   MODE_UNIT_ID
    string  array   MODE_NAME
    
    public int  difficulty  = -1
    
    function setMode( string mode ) returns boolean
        if      mode == MODE_NAME[ 1 ]
            difficulty = 1
        else if mode == MODE_NAME[ 2 ]
            difficulty = 2
        else if mode == MODE_NAME[ 4 ]
            difficulty = 4
        else if mode == MODE_NAME[ 8 ]
            difficulty = 8
        
        if difficulty == -1
            printError( "[|cffdd0000" + mode + "|r] is a not supported mode!" )
            printError( "Please choose from: " + MODE_COLOR_NAME[ 1 ] + "|r, " + MODE_COLOR_NAME[ 2 ] + "|r, " + MODE_COLOR_NAME[ 4 ] + "|r or " + MODE_COLOR_NAME[ 8 ] + "|r !" )
            return FALSE
        else
            return TRUE
            
    function enforceMode( )
        if MODE_UNIT_ID[ difficulty ] != 'e001'
            print( "Mode unit created." )
            CreateUnit( ENEMY, MODE_UNIT_ID[ difficulty ], 0., 0., 0.)
        for int i = 0 to 5
            SetPlayerState( players[ i ].p, PLAYER_STATE_RESOURCE_GOLD, R2I(160 / difficulty) )
        print( "Mode set to: " + MODE_COLOR_NAME[ difficulty ] + "|r" )
        DestroyTimer( tim )
        DestroyTimerDialog( timD )
        trig.destr( )
        initPlayerCommands( )      
        
    function modeChoose( )
        string checkMode = GetEventPlayerChatString( )
        if setMode( checkMode.substring( 1, checkMode.length( ) ) )
            enforceMode( )
    
    function autoModeChooser()
        if difficulty == -1
            difficulty = 2
            enforceMode( )
    
    public function initModeChoosing()
        trig = CreateTrigger( )
        TriggerRegisterPlayerChatEvent( trig, Player( 1 ), "-", FALSE )
        trig.addAction( function modeChoose )
        
        tim = CreateTimer( )
        timD = CreateTimerDialog( tim )
        TimerDialogSetTitle( timD, "Choose Mode:" )
        TimerDialogDisplay( timD, true )
        tim.start( 20., function autoModeChooser )
        
        MODE_NAME[ 1 ]          = "easy"
        MODE_NAME[ 2 ]          = "normal"
        MODE_NAME[ 4 ]          = "hard"
        MODE_NAME[ 8 ]          = "impossible"
        
        MODE_UNIT_ID[ 1 ]       = 'e004'
        MODE_UNIT_ID[ 2 ]       = 'e001'
        MODE_UNIT_ID[ 4 ]       = 'e005'
        MODE_UNIT_ID[ 8 ]       = 'e001'
        
        MODE_COLOR_NAME[ 1 ]    = "|cff04b404" + MODE_NAME[ 1 ]
        MODE_COLOR_NAME[ 2 ]    = "|cffffff00" + MODE_NAME[ 2 ]
        MODE_COLOR_NAME[ 4 ]    = "|cffb40404" + MODE_NAME[ 4 ]
        MODE_COLOR_NAME[ 8 ]    = "|cffb404ab" + MODE_NAME[ 8 ]
    
endpackage //===========================================================================
// Trigger: HeroChoosing
//===========================================================================
//TESH.scrollpos=6
//TESH.alwaysfold=0
package HeroChoosing
    
    import PlayerData
    import SpawnSystem
    
    trigger     t
    int playerCountSelected = 0
    
    constant real       X       = 533.
    constant real       Y       = 544.
    
    function chooseHero( )
        players[ GetPlayerId( GetOwningPlayer( GetSoldUnit( ) ) ) ].setHero( GetSoldUnit( ), X, Y )
        playerCountSelected++
        if playerCountSelected == playerCount
            initSpawnTimer( )
            t.destr( )
    
    public function initHeroChoosing()
        t = CreateTrigger( )
        TriggerRegisterUnitEvent( t, gg_unit_n000_0000, EVENT_UNIT_SELL )
        t.addAction( function chooseHero )
        print( "test3" )
        AddUnitToStock( gg_unit_n000_0000, 'H006', 2, 2 )
        AddUnitToStock( gg_unit_n000_0000, 'H003', 2, 2 )
        AddUnitToStock( gg_unit_n000_0000, 'H002', 2, 2 )
        AddUnitToStock( gg_unit_n000_0000, 'H001', 2, 2 )
        AddUnitToStock( gg_unit_n000_0000, 'H004', 2, 2 )
        print( "test4" )
    
endpackage //===========================================================================
// Trigger: HeroRevive
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
package HeroRevive
    
    import PlayerData
    import TimerUtils
    
    constant real       HERO_REVIVE_X   = 1440.
    constant real       HERO_REVIVE_Y   = 736.
    
    real                reviveTime      = 10.
    trigger             heroDiesTrig
    
    timerdialog array   TIMER_DIALOG
    
    function heroRevive( )
        timer   t       = GetExpiredTimer( )
        int     data    = t.getData( )
        
        t.release( )
        DestroyTimerDialog( TIMER_DIALOG[ data ] )
        
        ReviveHero( players[ data ].hero, HERO_REVIVE_X, HERO_REVIVE_Y, TRUE )
        if GetLocalPlayer( ) == Player( data )
            PanCameraToTimed( HERO_REVIVE_X, HERO_REVIVE_Y, 0. )
            ClearSelection( )
            SelectUnit( players[ data ].hero, TRUE )
    
    function heroDies( )
        player      p   = GetOwningPlayer( GetDyingUnit( ) )
        int         pID = GetPlayerId( p )
        timer       t   = getTimer( )
        
        TIMER_DIALOG[ pID ] = CreateTimerDialog( t )
        
        TimerDialogSetTitle( TIMER_DIALOG[ pID ], GetPlayerName( p ) )
        TimerDialogDisplay( TIMER_DIALOG[ pID ], TRUE )
        t.setData( GetPlayerId( p ) )
        t.start( GetHeroLevel( GetDyingUnit( ) ) * 2 + reviveTime, function heroRevive )
    
    public function addHeroToReviveSystem( unit hero )
        TriggerRegisterUnitEvent( heroDiesTrig, hero, EVENT_UNIT_DEATH )
    
    public function initHeroRevive( )
        heroDiesTrig = CreateTrigger( )
        heroDiesTrig.addAction( function heroDies )
    
endpackage //===========================================================================
// Trigger: RecipeData
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
package RecipeData
    
    import Hashtable
    
    public int          recipeCount = 0
    public Recipe array recipes
    
    hashtable   RECIPE_ITEMS    = InitHashtable( )
    
    class Recipe
        int     ID
        int     itemDiffCount
        int     itemSlot
        int     recipeItemID
        int     recipeComplete
        
        construct( int recipeItemID )
            ID = recipeCount
            this.recipeItemID = recipeItemID
            itemDiffCount = 0
        
        /* Adds an item to the recipe */
        function addItem( int itemID )
            RECIPE_ITEMS.saveInt( ID, itemID, itemDiffCount + 1 )
            itemDiffCount++
        
        /* Checks for recipe completeness */
        function check( unit hero, int itemID ) returns boolean
            // Initialization
            itemSlot = 0
            recipeComplete = 0
            for int initIndex = 1 to itemDiffCount
                RECIPE_ITEMS.saveInt( ID, initIndex, 1 )
            
            // If there is no more space in your hero's inventory, the last picked up item is checked
            if itemID != 0
                if RECIPE_ITEMS.loadInt( ID, itemID ) == 1
                    recipeComplete++
            
            // Checks if your hero has all required items
            for int slotIndex = 1 to 6
                item indexItem = UnitItemInSlot( hero, slotIndex - 1 )
                if indexItem != null
                    if RECIPE_ITEMS.loadInt( ID, RECIPE_ITEMS.loadInt( ID, GetItemTypeId( indexItem ) ) ) == 1
                        // Prevents double counting of items
                        RECIPE_ITEMS.saveInt( ID, RECIPE_ITEMS.loadInt( ID, GetItemTypeId( indexItem ) ), 2 )
                        recipeComplete++
                        if      slotIndex == 1
                            itemSlot += 1
                        else if slotIndex == 2
                            itemSlot += 10
                        else if slotIndex == 3
                            itemSlot += 100
                        else if slotIndex == 4
                            itemSlot += 1000
                        else if slotIndex == 5
                            itemSlot += 10000
                        else if slotIndex == 6
                            itemSlot += 100000
                        if recipeComplete == itemDiffCount
                            int counter = 1000000
                            for int i = 5 downto 0
                                counter = counter div 10
                                if  itemSlot >= counter
                                    bj_lastRemovedItem = UnitItemInSlot( hero, i )
                                    RemoveItem( UnitItemInSlot( hero, i ) )
                                    itemSlot -= counter
                            
                            // Debug, should be removed after testing
                            if itemSlot == 0
                                print( "Succesfully removed all recipe items." )
                            else
                                print( "Fail: " + I2S( itemSlot ) )
                        
                            UnitAddItemById( hero, recipeItemID )
                            return TRUE
            return FALSE
    
    function createRecipe( int recipeItemID )
        recipes[ recipeCount ] = new Recipe( recipeItemID )
        recipeCount++
    
    function addItemToLastRecipe( int itemID )
        int index = recipeCount - 1
        recipes[ index ].addItem( itemID )
    
    public function initRecipeData( )
    // -- Items for the Armor Recipe -- //
        createRecipe( 'I013' )
        addItemToLastRecipe( 'I005' )
        addItemToLastRecipe( 'I002' )
        addItemToLastRecipe( 'I004' )
        
    // -- Items for the Armored Boots  Recipe -- //
        createRecipe( 'I00O' )
        addItemToLastRecipe( 'I007' )
        addItemToLastRecipe( 'I003' )
        
    // -- Items for the Staff and Robe Recipe -- //
        createRecipe( 'I017' )
        addItemToLastRecipe( 'I00F' )
        addItemToLastRecipe( 'I00D' )
        addItemToLastRecipe( 'I00E' )
        
    // -- Items for the mystify Ring Recipe -- //
        createRecipe( 'I010' )
        addItemToLastRecipe( 'I00H' )
        addItemToLastRecipe( 'I00G' )
        
    // -- Items for the Mage Set Recipe -- //
        createRecipe( 'I015' )
        addItemToLastRecipe( 'I00K' )
        addItemToLastRecipe( 'I00J' )
        addItemToLastRecipe( 'I00I' )
        
    // -- Items for the Warrior Set Recipe -- //
        createRecipe( 'I018' )
        addItemToLastRecipe( 'I00B' )
        addItemToLastRecipe( 'I006' )
        addItemToLastRecipe( 'I008' )
endpackage //===========================================================================
// Trigger: Items
//===========================================================================
//TESH.scrollpos=36
//TESH.alwaysfold=0
package Items
    
    import PlayerData
    import RecipeData
    import Hashtable
    
    hashtable   REAL_2_FAKE_ITEM    = InitHashtable( )
    hashtable   FAKE_2_REAL_ITEM    = InitHashtable( )
    
    trigger dropTrig
    
    function onDrop( )
        var droppedItem     = GetManipulatedItem( )
        var droppedItemID   = GetItemTypeId( droppedItem )
        var u               = GetManipulatingUnit( )
        
        if REAL_2_FAKE_ITEM.hasInt( 0, GetItemTypeId( droppedItem ) ) and droppedItemID != GetItemTypeId( bj_lastRemovedItem )
            if droppedItemID == 'I00A' or droppedItemID == 'I001' or droppedItemID == 'I000'
                print( "Dropped chargable item" )
                int charges = GetItemCharges( droppedItem )
                if charges == 0
                    bj_lastRemovedItem = droppedItem
                    RemoveItem( droppedItem )
                    return
                else
                    bj_lastRemovedItem = droppedItem
                    RemoveItem( droppedItem )
                    SetItemCharges( CreateItem( REAL_2_FAKE_ITEM.loadInt( 0, droppedItemID ), GetUnitX( u ), GetUnitY( u ) ), charges )
                    return
            else
                bj_lastRemovedItem = droppedItem
                RemoveItem( droppedItem )
                CreateItem( REAL_2_FAKE_ITEM.loadInt( 0, droppedItemID ), GetUnitX( u ), GetUnitY( u ) )
                return
        bj_lastRemovedItem = null
    
    function isInvFull( unit hero ) returns boolean
        for int x = 0 to 5
            if UnitItemInSlot( hero, x ) == null
                return FALSE
        return TRUE
    
    function hasItem( unit hero, int itemID ) returns int
        for int x = 0 to 5
            if GetItemTypeId ( UnitItemInSlot( hero, x ) ) == itemID
                return x
        return -1
    
    function onPickUp( )
        item    pickUpItem      = GetManipulatedItem( )
        int     pickUpItemID    = GetItemTypeId( pickUpItem )
        unit    u               = GetManipulatingUnit( )
        
        if FAKE_2_REAL_ITEM.hasInt( 0, pickUpItemID )
            SetItemVisible( pickUpItem, false )
            
            if pickUpItemID == 'I00V' or pickUpItemID == 'I011' or pickUpItemID == 'I012'
                int test = hasItem( u, FAKE_2_REAL_ITEM.loadInt( 0, pickUpItemID ) )
                if test != -1
                    print( "Add charges." )
                    SetItemCharges( UnitItemInSlot( u, test ), GetItemCharges( UnitItemInSlot( u, test ) ) + GetItemCharges( pickUpItem ) )
                else
                    print( "Add item." )
                    SetItemCharges( UnitAddItemById( u, FAKE_2_REAL_ITEM.loadInt( 0, pickUpItemID ) ), GetItemCharges( pickUpItem ) )
                return
            
            if isInvFull( u )
                for int x = 0 to recipeCount-1
                    if recipes[ x ].check( u, FAKE_2_REAL_ITEM.loadInt( 0, pickUpItemID ) )
                        pickUpItemID = 0
                        break
                if pickUpItemID != 0
                    CreateItem( pickUpItemID, GetUnitX( u ), GetUnitY( u ) )
            else
                UnitAddItemById( u, FAKE_2_REAL_ITEM.loadInt( 0, pickUpItemID ) )
                for int i = 0 to recipeCount-1
                    if recipes[ i ].check( u, 0 )
                        break
    
    public function initItems( )
        dropTrig    = CreateTrigger( )
        trigger pickUpTrig  = CreateTrigger( )
        
        for int i = 0 to playerCount - 1
            TriggerRegisterPlayerUnitEvent( dropTrig, sortedPlayers[ i ].p, EVENT_PLAYER_UNIT_DROP_ITEM, null )
            TriggerRegisterPlayerUnitEvent( pickUpTrig, sortedPlayers[ i ].p, EVENT_PLAYER_UNIT_PICKUP_ITEM, null )
        
        dropTrig.addAction( function onDrop )
        pickUpTrig.addAction( function onPickUp )
        
        REAL_2_FAKE_ITEM.saveInt( 0, 'I008', 'I00O' )   // Armored Boots
        REAL_2_FAKE_ITEM.saveInt( 0, 'I003', 'I00P' )   // Boots
        REAL_2_FAKE_ITEM.saveInt( 0, 'I00D', 'I00Q' )   // Elder Staff
        REAL_2_FAKE_ITEM.saveInt( 0, 'I00M', 'I00R' )   // Golden talisman
        REAL_2_FAKE_ITEM.saveInt( 0, 'I009', 'I00S' )   // Hasty Gloves
        REAL_2_FAKE_ITEM.saveInt( 0, 'I00G', 'I00T' )   // Mystical Ring
        REAL_2_FAKE_ITEM.saveInt( 0, 'I005', 'I00U' )   // Recipe: Armor
        REAL_2_FAKE_ITEM.saveInt( 0, 'I007', 'I00N' )   // Recipe: Armored Boots
        REAL_2_FAKE_ITEM.saveInt( 0, 'I00F', 'I00W' )   // Recipe: Staff and Robe
        REAL_2_FAKE_ITEM.saveInt( 0, 'I00H', 'I00X' )   // Recipe: mystify Ring
        REAL_2_FAKE_ITEM.saveInt( 0, 'I00K', 'I00Y' )   // Recipe: Mage Set
        REAL_2_FAKE_ITEM.saveInt( 0, 'I00B', 'I00Z' )   // Recipe: Warrior Set
        REAL_2_FAKE_ITEM.saveInt( 0, 'I00I', 'I010' )   // Ring of the Mages
        REAL_2_FAKE_ITEM.saveInt( 0, 'I002', 'I019' )   // Short Sword
        REAL_2_FAKE_ITEM.saveInt( 0, 'I00A', 'I00V' )   // Healing Wards
        REAL_2_FAKE_ITEM.saveInt( 0, 'I000', 'I011' )   // Heal Potions
        REAL_2_FAKE_ITEM.saveInt( 0, 'I001', 'I012' )   // Mana Potions
        REAL_2_FAKE_ITEM.saveInt( 0, 'I006', 'I013' )   // Armor with Sword
        REAL_2_FAKE_ITEM.saveInt( 0, 'I00E', 'I014' )   // Elder Robe
        REAL_2_FAKE_ITEM.saveInt( 0, 'I00L', 'I015' )   // Mage Set
        REAL_2_FAKE_ITEM.saveInt( 0, 'I004', 'I016' )   // Shield
        REAL_2_FAKE_ITEM.saveInt( 0, 'I00J', 'I017' )   // Staff and Robe
        REAL_2_FAKE_ITEM.saveInt( 0, 'I00C', 'I018' )   // Warrior Set
        
        FAKE_2_REAL_ITEM.saveInt( 0, 'I00O', 'I008' )   // Armored Boots
        FAKE_2_REAL_ITEM.saveInt( 0, 'I00P', 'I003' )   // Boots
        FAKE_2_REAL_ITEM.saveInt( 0, 'I00Q', 'I00D' )   // Elder Staff
        FAKE_2_REAL_ITEM.saveInt( 0, 'I00R', 'I00M' )   // Golden talisman
        FAKE_2_REAL_ITEM.saveInt( 0, 'I00S', 'I009' )   // Hasty Gloves
        FAKE_2_REAL_ITEM.saveInt( 0, 'I00T', 'I00G' )   // Mystical Ring
        FAKE_2_REAL_ITEM.saveInt( 0, 'I00U', 'I005' )   // Recipe: Armor
        FAKE_2_REAL_ITEM.saveInt( 0, 'I00N', 'I007' )   // Recipe: Armored Boots
        FAKE_2_REAL_ITEM.saveInt( 0, 'I00W', 'I00F' )   // Recipe: Staff and Robe
        FAKE_2_REAL_ITEM.saveInt( 0, 'I00X', 'I00H' )   // Recipe: mystify Ring
        FAKE_2_REAL_ITEM.saveInt( 0, 'I00Y', 'I00K' )   // Recipe: Mage Set
        FAKE_2_REAL_ITEM.saveInt( 0, 'I00Z', 'I00B' )   // Recipe: Warrior Set
        FAKE_2_REAL_ITEM.saveInt( 0, 'I010', 'I00I' )   // Ring of the Mages
        FAKE_2_REAL_ITEM.saveInt( 0, 'I019', 'I002' )   // Short Sword
        FAKE_2_REAL_ITEM.saveInt( 0, 'I00V', 'I00A' )   // Healing Wards
        FAKE_2_REAL_ITEM.saveInt( 0, 'I011', 'I000' )   // Heal Potions
        FAKE_2_REAL_ITEM.saveInt( 0, 'I012', 'I001' )   // Mana Potions
        FAKE_2_REAL_ITEM.saveInt( 0, 'I013', 'I006' )   // Armor with Sword
        FAKE_2_REAL_ITEM.saveInt( 0, 'I014', 'I00E' )   // Elder Robe
        FAKE_2_REAL_ITEM.saveInt( 0, 'I015', 'I00L' )   // Mage Set
        FAKE_2_REAL_ITEM.saveInt( 0, 'I016', 'I004' )   // Shield
        FAKE_2_REAL_ITEM.saveInt( 0, 'I017', 'I00J' )   // Staff and Robe
        FAKE_2_REAL_ITEM.saveInt( 0, 'I018', 'I00C' )   // Warrior Set
        
endpackage //===========================================================================
// Trigger: WarriorSet
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
package WarriorSet
    
    import PlayerData
    
    function addEffect( )
        unit u = GetManipulatingUnit( )
        if isWarriorSet( GetItemTypeId( GetManipulatedItem( ) ) )
            UnitAddAbility( u, 'AIa6' )
            UnitAddAbility( u, 'AIs3' )
            UnitAddAbility( u, 'A00Y' )
    
    function removeEffect( )
        unit u = GetManipulatingUnit( )
        if isWarriorSet( GetItemTypeId( GetManipulatedItem( ) ) )
            UnitRemoveAbility( u, 'AIa6' )
            UnitRemoveAbility( u, 'AIs3' )
            UnitRemoveAbility( u, 'A00Y' )
    
    function isWarriorSet( int itemID ) returns boolean
        return itemID == 'I00C'
    
    public function initWarriorSet( )
        trigger trig1 = CreateTrigger( )
        for int a = 0 to playerCount - 1
            TriggerRegisterPlayerUnitEvent( trig1, sortedPlayers[ a ].p, EVENT_PLAYER_UNIT_PICKUP_ITEM, null )
        trig1.addAction( function addEffect )
        
        trigger trig2 = CreateTrigger( )
        for int b = 0 to playerCount - 1
            TriggerRegisterPlayerUnitEvent( trig2, sortedPlayers[ b ].p, EVENT_PLAYER_UNIT_DROP_ITEM, null )
        trig2.addAction( function removeEffect )
    
endpackage //===========================================================================
// Trigger: SpawnSystem
//===========================================================================
//TESH.scrollpos=165
//TESH.alwaysfold=0
package SpawnSystem
    
    import PlayerData
    import TimerUtils
    
    int             roundNumber = 1
    
    unit    array   SPAWN_BUILDING
    boolean array   isSpawnBuildingDestroyed
    real    array   PING
    real    array   ENEMY_SPAWN
    int     array   BOSS_ID
    int     array   MELEE_ID
    int     array   RANGED_ID
    int     array   CASTER_ID
    string  array   CREEP_STRING
    
    constant real   midX            = -224.
    constant real   midY            = -224.
    constant int    SIREN_ID        = 'n006'
    constant real   SIREN_START_X   = 1440.
    constant real   SIREN_START_Y   =  736.
    
    function spawnSirens( )
        for int i = 1 to 3
            IssuePointOrder( CreateUnit( Player( 0 ), SIREN_ID, SIREN_START_X, SIREN_START_Y, 0. ), "attack", ENEMY_SPAWN[ i ], ENEMY_SPAWN[ i + 3 ] )
    
    function normalSpawn( )
        for int i = 1 to playerCount
            for int a = 1 to 3
                if not isSpawnBuildingDestroyed[ a ]
                    IssuePointOrder( CreateUnit( ENEMY, MELEE_ID[ roundNumber ], ENEMY_SPAWN[ a ], ENEMY_SPAWN[ a + 3 ], 0. ), "attack", midX, midY )
                    IssuePointOrder( CreateUnit( ENEMY, RANGED_ID[ roundNumber ], ENEMY_SPAWN[ a ], ENEMY_SPAWN[ a + 3 ], 0. ), "attack", midX, midY )
                TriggerSleepAction( 0.02 )
    
    function spezialSpawn( )
        int i = GetRandomInt( 1, 3 )
        unit u
        
        StartSound( gg_snd_CreepAggroWhat1 )
        
        if      i == 1 
            i = GetRandomInt( 1, 3 )
            PingMinimap( PING[ i ], PING[ i + 3 ], 5. )
            
            if      i == 1
                print( "|cffFF0202Attention: |cffFFCC00A Boss is coming from Left!" )
                u = CreateUnit( ENEMY, BOSS_ID[ roundNumber ], ENEMY_SPAWN[ i ], ENEMY_SPAWN[ i + 3 ], 0 )
                SetUnitState( u, UNIT_STATE_LIFE, GetUnitState( u, UNIT_STATE_MAX_LIFE ) * 0.2 * playerCount )
                IssuePointOrder( u, "attack", midX, midY )
            else if i == 2
                print( "|cffFF0202Attention: |cffFFCC00A Boss is coming from Bottom!" )
                u = CreateUnit( ENEMY, BOSS_ID[ roundNumber ], ENEMY_SPAWN[ i ], ENEMY_SPAWN[ i + 3 ], 0 )
                SetUnitState( u, UNIT_STATE_LIFE, GetUnitState( u, UNIT_STATE_MAX_LIFE ) * 0.2 * playerCount )
                IssuePointOrder( u, "attack", midX, midY )
            else if i == 3
                print( "|cffFF0202Attention: |cffFFCC00A Boss is coming from Right!" )
                u = CreateUnit( ENEMY, BOSS_ID[ roundNumber ], ENEMY_SPAWN[ i ], ENEMY_SPAWN[ i + 3 ], 0 )
                SetUnitState( u, UNIT_STATE_LIFE, GetUnitState( u, UNIT_STATE_MAX_LIFE ) * 0.2 * playerCount )
                IssuePointOrder( u, "attack", midX, midY )
        else if i == 2
            i = GetRandomInt( 1, 3 )
            PingMinimap( PING[ i ], PING[ i + 3 ], 5. )
            
            if      i == 1
                print( "|cffFF0202Attention: |cffFFCC00A Casterwave is coming from Left!" )
                for int a = 1 to playerCount
                    IssuePointOrder( CreateUnit( ENEMY, CASTER_ID[ roundNumber ], ENEMY_SPAWN[ i ], ENEMY_SPAWN[ i + 3 ], 0. ), "attack", midX, midY )
            else if i == 2
                print( "|cffFF0202Attention: |cffFFCC00A Casterwave is coming from Bottom!" )
                for int a = 1 to playerCount
                    IssuePointOrder( CreateUnit( ENEMY, CASTER_ID[ roundNumber ], ENEMY_SPAWN[ i ], ENEMY_SPAWN[ i + 3 ], 0. ), "attack", midX, midY )
            else if i == 3
                print( "|cffFF0202Attention: |cffFFCC00A Casterwave is coming from Right!" )
                for int a = 1 to playerCount
                    IssuePointOrder( CreateUnit( ENEMY, CASTER_ID[ roundNumber ], ENEMY_SPAWN[ i ], ENEMY_SPAWN[ i + 3 ], 0. ), "attack", midX, midY )
        else if i == 3
            i = GetRandomInt( 1, 3 )
            PingMinimap( PING[ i ], PING[ i + 3 ], 5. )
            
            if      i == 1
                print( "|cffFF0202Attention: |cffFFCC00Murguls try to rush from Left!" )
                for int a = 1 to playerCount * 2
                    IssuePointOrder( CreateUnit( ENEMY, MELEE_ID[ roundNumber ], ENEMY_SPAWN[ i ], ENEMY_SPAWN[ i + 3 ], 0 ), "attack", midX, midY )
                    TriggerSleepAction( 0.02 )
            else if i == 2
                print( "|cffFF0202Attention: |cffFFCC00Murguls try to rush from Bottom!" )
                for int a = 1 to playerCount * 2
                    IssuePointOrder( CreateUnit( ENEMY, MELEE_ID[ roundNumber ], ENEMY_SPAWN[ i ], ENEMY_SPAWN[ i + 3 ], 0 ), "attack", midX, midY )
                    TriggerSleepAction( 0.02 )
            else if i == 3
                print( "|cffFF0202Attention: |cffFFCC00Murguls try to rush from Right!" )
                for int a = 1 to playerCount * 2
                    IssuePointOrder( CreateUnit( ENEMY, MELEE_ID[ roundNumber ], ENEMY_SPAWN[ i ], ENEMY_SPAWN[ i + 3 ], 0 ), "attack", midX, midY )
                    TriggerSleepAction( 0.02 )
    
    function upgrade( )
        roundNumber++
        
        print( "|cffFF0202Murguls upgraded their forces!|r" )
        print( CREEP_STRING[ roundNumber ] )
        
        spezialSpawn( )
    
    public function initSpawnTimer( )
        trigger trig1 = CreateTrigger( )
        TriggerRegisterTimerEvent( trig1, 27.5, TRUE )
        trig1.addAction( function normalSpawn )
        
        trigger trig2 = CreateTrigger( )
        TriggerRegisterTimerEvent( trig2, 55., TRUE )
        trig2.addAction( function spezialSpawn )
        
        trigger trig3 = CreateTrigger( )
        TriggerRegisterTimerEvent( trig3, 120., TRUE )
        trig3.addAction( function upgrade )
        
        trigger trig4 = CreateTrigger( )
        TriggerRegisterTimerEvent( trig4, 15.00, TRUE )
        trig4.addAction( function spawnSirens )
    
    function newMovementTarget( )
        unit    u = GetTriggerUnit( )
        IssuePointOrder( u, "attack", GetUnitX( gg_unit_H000_0008 ), GetUnitY( gg_unit_H000_0008 ) )
    
    function isUnitOwnerEnemy( ) returns boolean
        return GetOwningPlayer( GetFilterUnit( ) ) == ENEMY
    
    function victory( )
        for int i = 0 to playerCount - 1
            RemovePlayer( sortedPlayers[ i ].p, PLAYER_GAME_RESULT_VICTORY )
            EndGame( TRUE )
    
    function defead( )
        for int i = 0 to playerCount - 1
            RemovePlayer( sortedPlayers[ i ].p, PLAYER_GAME_RESULT_DEFEAT )
            EndGame( TRUE )
        
    function pause( )
        PauseUnit( GetEnumUnit( ), TRUE )
    
    function onEnd( )
        unit u = GetDyingUnit( )
        group g
        timer t
        for int i = 1 to 3
            if u == SPAWN_BUILDING[ i ]
                isSpawnBuildingDestroyed[ i ] = TRUE
                break
        
        if      isSpawnBuildingDestroyed[ 1 ] and isSpawnBuildingDestroyed[ 2 ] and isSpawnBuildingDestroyed[ 3 ]
            g = CreateGroup( )
            GroupEnumUnitsInRange( g, 0., 0., 4000., null )
            ForGroup( g, function pause )
            t = getTimer( )
            t.start( 10., function victory )
            DisableTrigger( GetTriggeringTrigger() )
            print( "Gratz you won" )
            print( "Game ends in 10 seconds." )
            print( "-== Created with Wurstscript ==-" )
        else if GetUnitState( gg_unit_H000_0008, UNIT_STATE_LIFE ) <= 0
            g = CreateGroup( )
            GroupEnumUnitsInRange( g, 0., 0., 4000., null )
            ForGroup( g, function pause )
            t = getTimer( )
            t.start( 10., function defead )
            DisableTrigger( GetTriggeringTrigger() )
            print( "Haha noobs!" )
            print( "Game ends in 10 seconds." )
            print( "-== Created with Wurstscript ==-" )
    
    public function initSpawnSystem( )
        trigger trig1 = CreateTrigger( )
        TriggerRegisterUnitInRange( trig1, CreateUnit( ENEMY, 'e001', midX, midY, 0. ), 222., Filter( function isUnitOwnerEnemy ) )
        trig1.addAction( function newMovementTarget )
        
        PING[ 1 ]       = -1664.
        PING[ 4 ]       =  1184.
        PING[ 2 ]       = -1568.
        PING[ 5 ]       = -1568.
        PING[ 3 ]       =  1408.
        PING[ 6 ]       = -1440.
        
        ENEMY_SPAWN[ 1 ]      = -3120.
        ENEMY_SPAWN[ 4 ]      =  2610.
        ENEMY_SPAWN[ 2 ]      = -3120.
        ENEMY_SPAWN[ 5 ]      = -3120.
        ENEMY_SPAWN[ 3 ]      =  3120.
        ENEMY_SPAWN[ 6 ]      = -3120.
        
        SPAWN_BUILDING[ 1 ] = gg_unit_n00H_0026
        SPAWN_BUILDING[ 2 ] = gg_unit_n00H_0025
        SPAWN_BUILDING[ 3 ] = gg_unit_n00H_0023
        
        BOSS_ID[ 1 ]    = 'n00F'
        BOSS_ID[ 2 ]    = 'n00F'
        BOSS_ID[ 3 ]    = 'n00M'
        BOSS_ID[ 4 ]    = 'n00M'
        BOSS_ID[ 5 ]    = 'n00R'
        BOSS_ID[ 6 ]    = 'n00R'
        
        MELEE_ID[ 1 ]   = 'n005'
        MELEE_ID[ 2 ]   = 'n00A'
        MELEE_ID[ 3 ]   = 'n00D'
        MELEE_ID[ 4 ]   = 'n00J'
        MELEE_ID[ 5 ]   = 'n00O'
        MELEE_ID[ 6 ]   = 'n00S'
        MELEE_ID[ 7 ]   = 'n00X'
        
        RANGED_ID[ 1 ]  = 'n008'
        RANGED_ID[ 2 ]  = 'n00B'
        RANGED_ID[ 3 ]  = 'n00I'
        RANGED_ID[ 4 ]  = 'n00K'
        RANGED_ID[ 5 ]  = 'n00P'
        RANGED_ID[ 6 ]  = 'n00T'
        RANGED_ID[ 7 ]  = 'n00Y'
        
        CASTER_ID[ 1 ]  = 'n00C'
        CASTER_ID[ 2 ]  = 'n00C'
        CASTER_ID[ 3 ]  = 'n00N'
        CASTER_ID[ 4 ]  = 'n00N'
        CASTER_ID[ 5 ]  = 'n00Q'
        CASTER_ID[ 6 ]  = 'n00Q'
        
        CREEP_STRING[ 2 ] = "|cff08A5E6Freakin Murgul |cffFFCC00(Crtitical Strike), |cff08A5E6Freaking Revenant |cffFFCC00(Multishot)"
        CREEP_STRING[ 3 ] = "|cff08A5E6Nighty Nightcrawler |cffFFCC00(Spawn Minion), |cff08A5E6Terry Turtle |cffFFCC00(Mana Leech)"
        CREEP_STRING[ 4 ] = "|cff08A5E6Poor Poolweller |cffFFCC00(Cleaving Attack), |cff08A5E6Spiddly Spidercrab |cffFFCC00(Fast Attack)"
        CREEP_STRING[ 5 ] = "|cff08A5E6Big Bear, |cff08A5E6Flaming Fire Sorcerer"
        CREEP_STRING[ 6 ] = "|cff08A5E6Big Spider, |cff08A5E6Lighted Lightining Lizard"
        CREEP_STRING[ 7 ] = "|cff08A5E6Skibby Skorpion, |cff08A5E6Seeing Seer"
        
        isSpawnBuildingDestroyed[ 1 ] = FALSE
        isSpawnBuildingDestroyed[ 2 ] = FALSE
        isSpawnBuildingDestroyed[ 3 ] = FALSE
        
        trigger trig = CreateTrigger( )
        TriggerRegisterUnitEvent( trig, gg_unit_n00H_0026, EVENT_UNIT_DEATH )
        TriggerRegisterUnitEvent( trig, gg_unit_n00H_0025, EVENT_UNIT_DEATH )
        TriggerRegisterUnitEvent( trig, gg_unit_n00H_0023, EVENT_UNIT_DEATH )
        TriggerRegisterUnitEvent( trig, gg_unit_H000_0008, EVENT_UNIT_DEATH )
        trig.addAction( function onEnd )
        
endpackage //===========================================================================
// Trigger: BossKill
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
package BossKill
    
    import PlayerData
    
    int array BOSS_UNIT_ID
    
    constant int BOSS_COUNT = 3
    
    function onBossKill( )
        int uID = GetUnitTypeId( GetTriggerUnit( ) )
        
        for int i = 1 to BOSS_COUNT
            if uID == BOSS_UNIT_ID[ i ]
                print( "Boss kill! Every player earns " + I2S( 50 * i ) + " gold!" )
                for int s = 0 to playerCount - 1
                    SetPlayerState( sortedPlayers[ s ].p, PLAYER_STATE_RESOURCE_GOLD, GetPlayerState( sortedPlayers[ s ].p, PLAYER_STATE_RESOURCE_GOLD ) + 50 * i )
                return
    
    public function initBossKill( )
        trigger trig = CreateTrigger( )
        TriggerRegisterPlayerUnitEvent( trig, ENEMY, EVENT_PLAYER_UNIT_DEATH, null )
        trig.addAction( function onBossKill )
        
        BOSS_UNIT_ID[ 1 ] = 'n00F'
        BOSS_UNIT_ID[ 2 ] = 'n00M'
        BOSS_UNIT_ID[ 3 ] = 'n00R'
    
endpackage 
//===========================================================================
// Trigger: TowerSystem
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
package TowerSystem
    
    import TimerUtils
    
    constant int    UNIT_ID         = 'h008'
    constant real   REBUILD_TIME    = 10.
    
    real    array   POS
    int     array   TOWER_ID
    unit    array   TOWER
    unit    array   WISP
    string  array   POS_STRING
    
    trigger array   refresh
    
    function createWisp( int pos )
        DisplayTextToForce( GetPlayersAll(), "|cffFFB521The Naga Queen tries to rebuild the|r |cffC5DE3A" + POS_STRING[ pos ] +  "|r |cffFFB521Tower! Protect the|r |cffC5E63ABuilder Wisp|cffFFB521!" )
        StartSound( gg_snd_SecretFound )
        WISP[ pos ] = CreateUnit( Player( 0 ), UNIT_ID, 800., 800., 0. )
        IssueBuildOrderById( WISP[ pos ], TOWER_ID[ pos ], POS[ pos ], POS[ pos + 3 ] )
        print( "Enabeled " + I2S( pos ) )
        EnableTrigger( refresh[ pos ] )
    
    function refreshOrder( )
        trigger trig = GetTriggeringTrigger( )
        
        for int i = 1 to 3
            if trig == refresh[ i ]
                    IssueBuildOrderById( WISP[ i ], TOWER_ID[ i ], POS[ i ], POS[ i + 3 ] )
                    return
    
    function startRebuild( )
        timer   t   = GetExpiredTimer( )
        
        createWisp( t.getData( ) )
        
        t.release( )
    
    function cancelledTower( )
        int towerID = GetUnitTypeId( GetCancelledStructure( ) )
        
        for int i = 1 to 3
            if towerID == TOWER_ID[ i ]
                print( "Enabeled " + I2S( i ) )
                EnableTrigger( refresh[ i ] )
        
    function finishedTower( )
        unit u = GetConstructedStructure( )
        
        for int i = 1 to 3
            if u  == TOWER[ i ]
                print( "Rebuild the " + POS_STRING[ i ] + " Tower." )
                RemoveUnit( WISP[ i ] )
                WISP[ i ] = null
                UnitAddAbility( TOWER[ i ], 'A01O' )
                UnitAddAbility( TOWER[ i ], 'A00P' )
                SetUnitAbilityLevel( TOWER[ i ], 'A01O', 10 )
                return
    
    function startedTower( )
        unit u = GetTriggerUnit( )
        
        for int i = 1 to 3
            if GetUnitTypeId( u ) == TOWER_ID[ i ]
                print( "Start building the " +  POS_STRING[ i ] + " Tower." )
                print( "Disabeled " + I2S( i ) )
                DisableTrigger( refresh[ i ] )
                TOWER[ i ] = u
                return
    
    function initRebuild( )
        unit u = GetDyingUnit( )
        timer t
        for int i = 1 to 3
            if      u == WISP[ i ]
                print( "Disabeled " + I2S( i ) )
                DisableTrigger( refresh[ i ] )
                RemoveUnit( WISP[ i ] )
                WISP[ i ] = null
                print( "The " + POS_STRING[ i ] + " Wisp got killed." )
                t = getTimer( )
                t.setData( i )
                t.start( REBUILD_TIME, function startRebuild )
                return
            else if u == TOWER[ i ] and WISP[ i ] == null
                print( "The " + POS_STRING[ i ] + " Tower got destroyed." )
                t = getTimer( )
                t.setData( i )
                t.start( REBUILD_TIME, function startRebuild )
                return

    function removeBuff( )
        unit u = GetTriggerUnit( )
        
        if GetUnitTypeId( u ) == 'h008'
            UnitRemoveAbility( u, 'A01M' )
    
    public function initTowerSystem( )
        TOWER_ID[ 1 ]   = 'n003'
        TOWER_ID[ 2 ]   = 'n00V'
        TOWER_ID[ 3 ]   = 'n00W'
        
        POS[ 1 ]        =  -650.
        POS[ 4 ]        =   440.
        POS[ 2 ]        = -1037.
        POS[ 5 ]        =  -667.
        POS[ 3 ]        =   580.
        POS[ 6 ]        =  -960.
        
        POS_STRING[ 1 ] = "left"
        POS_STRING[ 2 ] = "bottom"
        POS_STRING[ 3 ] = "right"
        
        for int a = 1 to 3
            TOWER[ a ] = CreateUnit( Player( 0 ), TOWER_ID[ a ], POS[ a ], POS[ a + 3 ], 270. )
            refresh[ a ] = CreateTrigger( )
            TriggerRegisterTimerEvent( refresh[ a ], 5., TRUE )
            refresh[ a ].addAction( function refreshOrder )
            DisableTrigger( refresh[ a ] )
            
        trigger trig1 = CreateTrigger()
        TriggerRegisterPlayerUnitEvent( trig1, Player( 0 ), EVENT_PLAYER_UNIT_DEATH, null )
        trig1.addAction( function initRebuild )
        
        trigger trig2 = CreateTrigger()
        TriggerRegisterPlayerUnitEvent( trig2, Player( 0 ), EVENT_PLAYER_UNIT_CONSTRUCT_CANCEL, null )
        trig2.addAction( function cancelledTower )
        
        trigger trig3 = CreateTrigger()
        TriggerRegisterPlayerUnitEvent( trig3, Player( 0 ), EVENT_PLAYER_UNIT_CONSTRUCT_START, null )
        trig3.addAction( function startedTower )
        
        trigger trig4 = CreateTrigger()
        TriggerRegisterPlayerUnitEvent( trig4, Player( 0 ), EVENT_PLAYER_UNIT_CONSTRUCT_FINISH, null )
        trig4.addAction( function finishedTower )
        
        trigger trig5 = CreateTrigger()
        TriggerRegisterPlayerUnitEvent( trig5, Player( 0 ), EVENT_PLAYER_UNIT_DEATH, null )
        trig5.addAction( function removeBuff )
        
endpackage 
//===========================================================================
// Trigger: Gold
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
package Gold
    
    import PlayerData
    
    function addGold( )
        for int i = 0 to playerCount - 1
            SetPlayerState( sortedPlayers[ i ].p, PLAYER_STATE_RESOURCE_GOLD, GetPlayerState( sortedPlayers[ i ].p, PLAYER_STATE_RESOURCE_GOLD ) + 1 )

    public function initGold( )
        trigger trig1 = CreateTrigger()
        TriggerRegisterTimerEvent( trig1, 2., TRUE )
        trig1.addAction( function addGold )
        
        SetPlayerState( ENEMY, PLAYER_STATE_GIVES_BOUNTY, 1 )

endpackage //===========================================================================
// Trigger: FallenSoldier
//===========================================================================
//TESH.scrollpos=44
//TESH.alwaysfold=0
package FallenSoldier
    
    import PlayerData
    import AbortSpell
    import PreloadHandler
    
    constant int    SPELL_ID            = 'A110'                                                            // Spell ID
    constant int    UNIT_ID             = 'e002'                                                            // Spawning Unit
    constant real   RANGE               = 375                                                               // Range
    constant string ANIMATION_STRING    = "Abilities\\Spells\\Undead\\AnimateDead\\AnimateDeadTarget.mdl"   // Effect
    constant string ANIMATION_STRING2   = "Abilities\\Spells\\Human\\Avatar\\AvatarCaster.mdl"
    
    /* Unit == Dead and Owningplayer == Player_ID */
    function filter( ) returns boolean
        return GetWidgetLife( GetFilterUnit() ) < .405 and not IsUnitType( GetFilterUnit(), UNIT_TYPE_STRUCTURE )
    
    function groupAction( )
        unit u = GetEnumUnit( )
        bj_groupCountUnits++
        AddSpecialEffect( ANIMATION_STRING, GetUnitX( u ), GetUnitY( u ) )
        RemoveUnit( u )
    
    /* Picks "corpses" unit in range "RANGE", and spawns "corpses" "UNIT_ID" */
    function action( )
        var caster  = GetSpellAbilityUnit( )    // Caster
        var g       = CreateGroup( )            // Group of Pickt Units
        var corpses = GetUnitAbilityLevel( caster, SPELL_ID ) * GetUnitAbilityLevel( caster, SPELL_ID ) + 1 // Amount of spawned Units
        
        GroupEnumUnitsInRange( g, GetUnitX( caster ), GetUnitY( caster ), RANGE, Condition( function filter ) )
        
        bj_groupCountUnits = 0
        
        ForGroup( g, function groupAction )
        
        var b = bj_groupCountUnits
        
        if b == 0
            abortSpell( caster, "You need at least 1 nearby corpse", "G")
        else
            if b > corpses
                b = corpses
            var c = CreateUnit( GetOwningPlayer( caster ), UNIT_ID, GetUnitX( caster ), GetUnitY( caster ), 0 )
            SetUnitScale( c, b * 0.25, b * 0.25, b * 0.25 )
            SetUnitAnimation( c, "birth" )
            AddSpecialEffect( ANIMATION_STRING2, GetUnitX( c ), GetUnitY( c ) ) // Effect and Effectposition
            SetUnitState( c, UNIT_STATE_LIFE, 200. * b + 300. )
            UnitApplyTimedLife( c, 'BTLF', 90 ) 
            UnitAddAbility( c, 'A01O' )
            SetUnitAbilityLevel( c, 'A01O', 15 * GetUnitAbilityLevel( caster, SPELL_ID ) )
            
        GroupClear( g )
        DestroyGroup( g )
    
    function condition( ) returns boolean
        return GetSpellAbilityId() == SPELL_ID
    
    public function initFallenSoldier( )
        trigger trig = CreateTrigger( )
        
        for int i = 0 to playerCount - 1
            TriggerRegisterPlayerUnitEvent( trig, sortedPlayers[ i ].p, EVENT_PLAYER_UNIT_SPELL_EFFECT, null )
        trig.addCondition( Condition( function condition) )
        trig.addAction( function action )
        
        
    init
        preloadAbility('A01O')
        preloadAbility('A00P')

endpackage //===========================================================================
// Trigger: Deathstop
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
package Deathstop
    
    import PlayerData
    
    constant int    SPELL_ID            = 'A111'
    constant string ANIMATION_STRING    = "Units\\NightElf\\Wisp\\WispExplode.mdl"
    constant real   RADIUS              = 300.
    
    function filter( ) returns boolean
        return GetWidgetLife( GetFilterUnit( ) ) > .405 and not IsUnitType( GetFilterUnit( ), UNIT_TYPE_STRUCTURE ) and GetOwningPlayer( GetFilterUnit( ) ) == ENEMY
    
    function action( )
        var caster      = GetSpellAbilityUnit( )
        var g           = CreateGroup( )
        var hitpoints   = 175. * GetUnitAbilityLevel( caster, SPELL_ID ) * ( GetUnitAbilityLevel( caster, SPELL_ID ) - 1) + 100.
        
        GroupEnumUnitsInRange( g, GetUnitX( caster ), GetUnitY( caster ), RADIUS, Condition( function filter ) )
        
        for unit u in g
            AddSpecialEffect( ANIMATION_STRING, GetUnitX( u ), GetUnitY( u ) )
            UnitDamageTarget( caster, u, hitpoints, FALSE, FALSE, ATTACK_TYPE_NORMAL, DAMAGE_TYPE_UNKNOWN, WEAPON_TYPE_WHOKNOWS ) 
        
        GroupClear( g )
        DestroyGroup( g )
    
    function condition( ) returns boolean
        return GetSpellAbilityId( ) == SPELL_ID
    
    public function initDeathstop( )
        trigger trig = CreateTrigger()
        for int i = 0 to playerCount - 1
            TriggerRegisterPlayerUnitEvent( trig, sortedPlayers[ i ].p, EVENT_PLAYER_UNIT_SPELL_EFFECT, null )
        trig.addCondition( Condition( function condition ) )
        trig.addAction( function action )

endpackage //===========================================================================
// Trigger: Deadlife
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
package Deadlife
    
    import PlayerData
    import AbortSpell
    
    constant integer SPELL_ID = 'A112'
    constant string ANIMATION_STRING = "Abilities\\Spells\\Undead\\DarkRitual\\DarkRitualTarget.mdl"
    
    function filter( ) returns boolean
        return GetWidgetLife( GetFilterUnit() ) < .405 and not IsUnitType( GetFilterUnit( ), UNIT_TYPE_STRUCTURE )
    
    function action( )
        var caster = GetSpellAbilityUnit()
        var g = CreateGroup()
        var hitpoints = 200. * GetUnitAbilityLevel( caster, SPELL_ID ) + 100.
        
        GroupEnumUnitsInRange( g, GetUnitX( caster ), GetUnitY( caster ), 512., Condition( function filter ) )
        
        var u = FirstOfGroup( g )
        if u == null
            abortSpell( caster, "You need at least 1 nearby corpse", "G")
        else
            AddSpecialEffect( ANIMATION_STRING, GetUnitX( u ), GetUnitY( u ) )
            SetUnitState( caster, UNIT_STATE_LIFE, GetUnitState( caster, UNIT_STATE_LIFE ) + hitpoints )
            RemoveUnit( u )
        
        GroupClear( g )
        DestroyGroup( g )
    
    function condition( ) returns boolean
        return GetSpellAbilityId( ) == SPELL_ID
    
    public function initDeadlife( )
        trigger trig = CreateTrigger()
        
        for int i = 0 to playerCount - 1
            TriggerRegisterPlayerUnitEvent( trig, sortedPlayers[ i ].p, EVENT_PLAYER_UNIT_SPELL_EFFECT, null )
        trig.addCondition( Condition( function condition ) )
        trig.addAction( function action )
    
endpackage //===========================================================================
// Trigger: Death Aura
//===========================================================================
//TESH.scrollpos=12
//TESH.alwaysfold=0
package DeathAura
    
    import PlayerData
    
    constant int    SPELL_ID    = 'A01J'    // Spell ID
    constant int    UNIT_ID     = 'e003'    // Spawning Unit
    constant int    HERO_ID1    = 'H004'
    constant int    HERO_ID2    = 'U000'
    constant real   RANGE       = 425.      // Range
    constant string ANIMATION_STRING = "Abilities\\Spells\\Undead\\RaiseSkeletonWarrior\\RaiseSkeleton.mdl" // Effect
    
    function filter( ) returns boolean
        return true
    
    // Picks "corpses" unit in range "RANGE", and spawns "corpses" "UNIT_ID"
    function action( )
        var victim  = GetTriggerUnit()
        var g       = CreateGroup() // Group of Pickt Units

        
        GroupEnumUnitsInRange( g, GetUnitX( victim ), GetUnitY( victim ), RANGE, Condition( function filter ) )
        
        for unit u from g
            if GetUnitTypeId( u ) == HERO_ID1 or GetUnitTypeId( u ) == HERO_ID2 and GetUnitAbilityLevel( u, SPELL_ID) > 0
                var i = GetRandomInt( 0, 100 )
                if i > 100 - GetUnitAbilityLevel( u, SPELL_ID ) * 10                                                    // 10/20/30 % chance
                    var c = CreateUnit( GetOwningPlayer( u ), UNIT_ID, GetUnitX( victim ), GetUnitY( victim ), 0 )
                    SetUnitAnimation( c, "birth" )
                    SetUnitState( c, UNIT_STATE_LIFE, 400. * GetUnitAbilityLevel( u, SPELL_ID ) )
                    AddSpecialEffect( ANIMATION_STRING, GetUnitX( c ), GetUnitY( c ) )                                  // Effect and Effectposition
                    UnitApplyTimedLife( c, 'BTLF', 70 )
                    SetUnitAbilityLevel( c, 'A01O', 6 * GetUnitAbilityLevel( u, SPELL_ID ) )
                break
            GroupRemoveUnit( g, u )
        
        GroupClear( g )
        DestroyGroup( g )
    
    public function initDeathAura( )
        trigger trig = CreateTrigger()
        TriggerRegisterPlayerUnitEvent( trig, ENEMY, EVENT_PLAYER_UNIT_DEATH, null )
        TriggerRegisterPlayerUnitEvent( trig, Player( 0 ), EVENT_PLAYER_UNIT_DEATH, null )
        trig.addAction( function action )

endpackage //===========================================================================
// Trigger: AquaBurst
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
package AquaBurst
    
    import PlayerData
    
    constant real RANGE                 = 175.
    constant real DMG                   = 125.
    constant real BONUS                 = 210.
    constant int  SPELL_ID              = 'A009'
    
    constant string ANIMATION_STRING_1  = "Abilities\\Spells\\Other\\CrushingWave\\CrushingWaveDamage.mdl"
    constant string ANIMATION_STRING_2  = "Objects\\Spawnmodels\\Naga\\NagaDeath\\NagaDeath.mdl"
    
    function filter( ) returns boolean
        return GetWidgetLife( GetFilterUnit( ) ) > .405 and not IsUnitType( GetFilterUnit( ), UNIT_TYPE_STRUCTURE ) and GetOwningPlayer( GetFilterUnit( ) ) == ENEMY

    function action( )
        var caster  = GetTriggerUnit( )
        var g       = CreateGroup( )
        var x       = GetSpellTargetX( )
        var y       = GetSpellTargetY( )
        var dmg     = DMG * GetUnitAbilityLevel( caster, GetSpellAbilityId( ) ) + BONUS
        
        GroupEnumUnitsInRange( g, x, y, RANGE, Condition( function filter ) )
        
        for unit u from g
            DestroyEffect( AddSpecialEffectTarget( ANIMATION_STRING_1, u, "origin" ) )
            UnitDamageTarget( caster, u, dmg, FALSE, FALSE, ATTACK_TYPE_NORMAL, DAMAGE_TYPE_UNKNOWN, WEAPON_TYPE_WHOKNOWS )
            GroupRemoveUnit( g, u )
        
        PauseUnit( caster, TRUE )
        SetUnitX( caster, x )
        SetUnitY( caster, y )
        PauseUnit( caster, FALSE )
        
        SetUnitAnimation( caster, "birth" )
        
        DestroyEffect( AddSpecialEffectTarget( ANIMATION_STRING_2, caster, "origin" ) )
        
        GroupClear( g )
        DestroyGroup( g )
    
    function condition( ) returns boolean
        return GetSpellAbilityId() == SPELL_ID
    
    public function initAquaBurst( )
        trigger trig = CreateTrigger( )
        
        for int i = 0 to playerCount - 1
            TriggerRegisterPlayerUnitEvent( trig, sortedPlayers[ i ].p, EVENT_PLAYER_UNIT_SPELL_EFFECT, null )
        trig.addCondition( Condition( function condition ) )
        trig.addAction( function action )
    
endpackage //===========================================================================
// Trigger: TermalEruption
//===========================================================================
//TESH.scrollpos=19
//TESH.alwaysfold=0
package TermalEruption
    
    import PlayerData
    import DummyCaster
    
    constant real   RANGE               = 200.
    constant real   DMG                 =  90.
    constant real   BONUS               =   0.
    constant int    L_NUM               = 12
    constant int    DUMMY_SPELL         = 'A006'
    constant int    SPELL_ID            = 'A003'
    
    constant string ANIMATION_STRING_1  = "Abilities\\Spells\\Other\\CrushingWave\\CrushingWaveDamage.mdl"
    constant string ANIMATION_STRING_2  = "Objects\\Spawnmodels\\Naga\\NagaDeath\\NagaDeath.mdl"
    constant string ANIMATION_STRING_3  = "Objects\\Spawnmodels\\NightElf\\NECancelDeath\\NECancelDeath.mdl"
    
    function filter( ) returns boolean
        return GetWidgetLife( GetFilterUnit( ) ) > .405 and not IsUnitType( GetFilterUnit( ), UNIT_TYPE_STRUCTURE ) and GetOwningPlayer( GetFilterUnit( ) ) == ENEMY
    
    function action( )
        var caster  = GetTriggerUnit( )
        var g       = CreateGroup( )
        var owner   = GetOwningPlayer( caster )
        var x       = GetSpellTargetX( )
        var y       = GetSpellTargetY( )
        var lvl     = GetUnitAbilityLevel( caster, GetSpellAbilityId( ) )
        var dmg     = DMG * lvl + BONUS
        
        GroupEnumUnitsInRange( g, x, y, RANGE, Condition( function filter ) )
        
        DummyCaster dc = new DummyCaster( DUMMY_SPELL, "thunderclap", GetOwningPlayer( GetTriggerUnit( ) ), TRUE )
        dc.recycledelay = 0.05
        dc.castInPoint( GetSpellTargetX( ), GetSpellTargetY( ) )
        print("casted")
        
        for unit u from g
            DestroyEffect( AddSpecialEffectTarget( ANIMATION_STRING_1, u, "origin" ) )
            UnitDamageTarget( caster, u, dmg, FALSE, FALSE, ATTACK_TYPE_NORMAL, DAMAGE_TYPE_UNKNOWN, WEAPON_TYPE_WHOKNOWS )
            //GroupRemoveUnit( g, u )
        
        //DestroyEffect( AddSpecialEffect( ANIMATION_STRING_2, x, y) )
        //DestroyEffect( AddSpecialEffect( ANIMATION_STRING_3, x, y) )
        
        //GroupClear( g )
        //DestroyGroup( g )
    
    function condition( ) returns boolean
        return GetSpellAbilityId( ) == SPELL_ID
    
    public function initTermalEruption( )
        trigger trig = CreateTrigger( )
        
        for int i = 0 to playerCount
            TriggerRegisterPlayerUnitEvent( trig, sortedPlayers[ i ].p, EVENT_PLAYER_UNIT_SPELL_EFFECT, null )
        trig.addCondition( Condition( function condition ) )
        trig.addAction( function action )
    
endpackage //===========================================================================
// Trigger: autofly
//===========================================================================
//TESH.scrollpos=3
//TESH.alwaysfold=0
package AutoFly

    function actions() returns boolean
        if UnitAddAbility(GetFilterUnit(), 'Amrf')
            UnitRemoveAbility(GetFilterUnit(), 'Amrf')
        return false




    init
        region r = CreateRegion()
        rect re = GetWorldBounds()
        group g = CreateGroup()
        RegionAddRect(r, re)
        TriggerRegisterEnterRegion(CreateTrigger(), r, Filter(function actions))
        RemoveRect(re)
        re = null
        
        for int i = 15 downto 0
            GroupEnumUnitsOfPlayer(g, Player(i), Filter(function actions))

        DestroyGroup(g)
        g = null



endpackage //===========================================================================
// Trigger: SimError
//===========================================================================
//TESH.scrollpos=5
//TESH.alwaysfold=0
package SimError
//**************************************************************************************************
//*
//*  SimError
//*
//*     Mimic an interface error message
//*       call SimError(ForPlayer, msg)
//*         ForPlayer : The player to show the error
//*         msg       : The error
//*    
//*     To implement this function, copy this trigger and paste it in your map.
//* Unless of course you are actually reading the library from wc3c's scripts section, then just
//* paste the contents into some custom text trigger in your map.
//*
//**************************************************************************************************

//==================================================================================================
    sound error
//====================================================================================================

    public function simError( player forPlayer, string msg )
        var msg1 = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n|cffffcc00" + msg + "|r"
        if GetLocalPlayer() == forPlayer
            ClearTextMessages()
            DisplayTimedTextToPlayer( forPlayer, 0.52, 0.96, 2.00, msg1 )
            StartSound( error )

    init
        error = CreateSoundFromLabel( "InterfaceError", FALSE, FALSE, FALSE, 10, 10 )

endpackage //===========================================================================
// Trigger: LastOrder
//===========================================================================
//TESH.scrollpos=162
//TESH.alwaysfold=0
package LastOrder
    
    import UnitIndexingUtils
    //******************************************************************************
    //* BY: Rising_Dusk
    //* 
    //* This library has a lot of usefulness for when you want to interface with the
    //* last order a unit was given. This can be useful for simulating spell errors
    //* and where you'd want to give them back the order they had prior to the spell
    //* cast (whereas without this library, they'd just forget their orders).
    //* 
    //* There are some handy interfacing options for your use here --
    //*     function GetLastOrderId takes unit u returns integer
    //*     function GetLastOrderString takes unit u returns string
    //*     function GetLastOrderType takes unit u returns integer
    //*     function GetLastOrderX takes unit u returns real
    //*     function GetLastOrderY takes unit u returns real
    //*     function GetLastOrderTarget takes unit u returns widget
    //*     function AbortOrder takes unit u returns boolean
    //*
    //* There are also some order commands that can be useful --
    //*     function IssueLastOrder takes unit u returns boolean
    //*     function IssueSecondLastOrder takes unit u returns boolean
    //*     function IsLastOrderFinished takes unit u returns boolean
    //* 
    //* You can access any information you'd like about the orders for your own
    //* order handling needs.
    //* 
    
    //* Storage for last order
    integer array order
    integer array aType
    widget  array targ
    boolean array flag
    real    array x
    real    array y
    
    //* Storage for second last order
    integer array p_Order
    integer array p_Type
    widget  array p_Targ
    boolean array p_Flag
    real    array p_X
    real    array p_Y
    
    //* Order type variables
    public  constant integer       ORDER_TYPE_TARGET    = 1
    public  constant integer       ORDER_TYPE_POINT     = 2
    public  constant integer       ORDER_TYPE_IMMEDIATE = 3
    
    //* Trigger for the order catching
    trigger orderTrg    = CreateTrigger( )

//**********************************************************
    public function getLastOrderId( unit u ) returns int
        return order[ getUnitId( u ) ]
    
    public function getLastOrderString( unit u ) returns string
        return OrderId2String( order[ getUnitId( u ) ] )
    
    public function getLastOrderType( unit u ) returns int
        return aType[ getUnitId( u ) ]
    
    public function getLastOrderX( unit u ) returns real
        return x[ getUnitId( u ) ]
    
    public function getLastOrderY( unit u ) returns real
        return y[ getUnitId( u ) ]
    
    public function getLastOrderTarget( unit u ) returns widget
        return targ[ getUnitId( u ) ]
//**********************************************************
    function orderExclusions( unit u, int id ) returns boolean
        //* Excludes specific orders or unit types from registering with the system
        //* 
        //* 851972: stop
        //*         Stop is excluded from the system, but you can change it by
        //*         adding a check for it below. id == 851972
        //* 
        //* 851971: smart
        //* 851986: move
        //* 851983: attack
        //* 851984: attackground
        //* 851990: patrol
        //* 851993: holdposition
        //*         These are the UI orders that are passed to the system.
        //* 
        //* >= 852055, <= 852762
        //*         These are all spell IDs from defend to incineratearrowoff with
        //*         a bit of leeway at the ends for orders with no strings.
        //* 
        return id == 851971 or id == 851986 or id == 851983 or id == 851984 or id == 851990 or id == 851993 or (id >= 852055 and id <= 852762)

    function lastOrderFilter( unit u ) returns boolean
        //* Some criteria for whether or not a unit's last order should be given
        //* 
        //* INSTANT type orders are excluded because generally, reissuing an instant
        //* order doesn't make sense. You can remove that check below if you'd like,
        //* though.
        //* 
        //* The Type check is really just to ensure that no spell recursion can
        //* occur with IssueLastOrder. The problem with intercepting the spell cast
        //* event is that it happens after the order is 'caught' and registered to
        //* this system. Therefore, to just IssueLastOrder tells it to recast the
        //* spell! That's a problem, so we need a method to eliminate it.
        //* 
        var id = getUnitId( u )
        return u != null and GetWidgetLife( u ) > 0.405 and aType[ id ] != ORDER_TYPE_IMMEDIATE

    function secondLastOrderFilter( unit u ) returns boolean
        //* Same as above but with regard to the second last order issued
        var id = getUnitId( u )
        return u != null and GetWidgetLife( u ) > 0.405 and p_Type[ id ] != ORDER_TYPE_IMMEDIATE and p_Order[ id ] != order[ id ]
    
//**********************************************************

    function isLastOrderFinished( unit u ) returns boolean
        return ( GetUnitCurrentOrder( u ) == 0 and order[ getUnitId( u ) ] != 851972 ) or flag[ getUnitId( u ) ]

    public function issueLastOrder( unit u ) returns boolean
        var id = getUnitId( u )
        if lastOrderFilter( u ) and order[ id ] != 0 and not flag[ id ]
            if      aType[ id ] == ORDER_TYPE_TARGET
                return IssueTargetOrderById( u, order[ id ], targ[ id ] )
            else if aType[ id ] == ORDER_TYPE_POINT
                return IssuePointOrderById( u, order[ id ], x[ id ], y[ id ] )
            else if aType[ id ] == ORDER_TYPE_IMMEDIATE
                return IssueImmediateOrderById( u, order[ id ] )
        return FALSE

    public function issueSecondLastOrder( unit u ) returns boolean
        //* This function has to exist because of spell recursion
        var id  = getUnitId( u )
        if secondLastOrderFilter( u ) and p_Order[ id ] != 0 and not p_Flag[ id ]
            if      p_Type[ id ] == ORDER_TYPE_TARGET
                return IssueTargetOrderById( u, p_Order[ id ], p_Targ[ id ] )
            else if p_Type[ id ] == ORDER_TYPE_POINT
                return IssuePointOrderById( u, p_Order[ id ], p_X[ id ], p_Y[ id ] )
            else if p_Type[ id ] == ORDER_TYPE_IMMEDIATE
                return IssueImmediateOrderById( u, p_Order[ id ] )
        return FALSE
    
    public function abortOrder( unit u ) returns boolean
        boolean b = true
        if IsUnitPaused( u )
            return FALSE
        else
            PauseUnit( u, TRUE )
            IssueImmediateOrder( u, "stop" )
            PauseUnit( u, FALSE )
            return TRUE
    
//**********************************************************

    function conditions( ) returns boolean
        return orderExclusions( GetTriggerUnit( ), GetIssuedOrderId( ) )
    
    function actions( )
        var u   = GetTriggerUnit()
        var id  = getUnitId( u )
        
        //* Store second to last order to eliminate spell recursion
        p_Order[ id ]  = order[ id ]
        p_Targ[ id ]   = targ[ id ]
        p_Type[ id ]   = aType[ id ]
        p_Flag[ id ]   = flag[ id ]
        p_X[ id ]      = x[ id ]
        p_Y[ id ]      = y[ id ]
        
        flag[ id ]      = FALSE
        order[ id ]     = GetIssuedOrderId( )
        if      GetTriggerEventId( ) == EVENT_PLAYER_UNIT_ISSUED_TARGET_ORDER
            targ[ id ]  = GetOrderTarget()
            aType[ id ] = ORDER_TYPE_TARGET
            x[ id ]     = GetWidgetX( GetOrderTarget( ) )
            y[ id ]     = GetWidgetY( GetOrderTarget( ) )
        else if GetTriggerEventId( ) == EVENT_PLAYER_UNIT_ISSUED_POINT_ORDER
            targ[ id ]  = null
            aType[ id ] = ORDER_TYPE_POINT
            x[ id ]     = GetOrderPointX( )
            y[ id ]     = GetOrderPointY( )
        else if GetTriggerEventId( ) == EVENT_PLAYER_UNIT_ISSUED_ORDER
            targ[ id ]  = null
            aType[ id ] = ORDER_TYPE_IMMEDIATE
            x[ id ]     = GetUnitX( u )
            y[ id ]     = GetUnitY( u )
    
//**********************************************************

    function spellActions( )
        flag[ getUnitId( GetTriggerUnit( ) ) ] = true
    
//**********************************************************

    init
        orderTrg.addCondition( Condition( function conditions ) )
        orderTrg.addAction( function actions )
        TriggerRegisterAnyUnitEventBJ( orderTrg, EVENT_PLAYER_UNIT_ISSUED_TARGET_ORDER )
        TriggerRegisterAnyUnitEventBJ( orderTrg, EVENT_PLAYER_UNIT_ISSUED_POINT_ORDER )
        TriggerRegisterAnyUnitEventBJ( orderTrg, EVENT_PLAYER_UNIT_ISSUED_ORDER )
        
        trigger trg = CreateTrigger( )
        trg.addAction( function spellActions )
        TriggerRegisterAnyUnitEventBJ( trg, EVENT_PLAYER_UNIT_SPELL_EFFECT )
        
endpackage //===========================================================================
// Trigger: UnitUserData
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
package UnitIndexingUtils
    //******************************************************************************
    //* BY: Rising_Dusk
    //* 
    //* -: BLUE FLAVOR :-
    //* 
    //* This can be used to index units with a unique integer for use with arrays
    //* and things like that. This has a limit of 8191 indexes allocated at once in
    //* terms of actually being usable in arrays. It won't give you an error if you
    //* exceed 8191, but that is an unrealistic limit anyways.
    //* 
    //* The blue flavor uses a trigger that fires on death of a unit to release the
    //* indexes of units. This is useful for maps where ressurection is not an issue
    //* and doesn't require an O(n) search inside of a timer callback, making it
    //* potentially less taxing on the game.
    //* 
    //* To use, call GetUnitId on a unit to retrieve its unique integer id. This
    //* library allocates a unique index to a unit the instant it is created, which
    //* means you can call GetUnitId immediately after creating the unit with no
    //* worry.
    //* 
    //* Function Listing --
    //*     function GetUnitId takes unit u returns integer
    //*
    
    class Unitindex
        int ID
        construct( )
            ID = 0
    
    //Function to get the unit's unique integer id, inlines to getting its userdata
    public function getUnitId( unit u ) returns int
        return GetUnitUserData( u )
    
    //Filter for units to index 
    function unitFilter( ) returns boolean
        return TRUE
    
    //Filter for what units to remove indexes for on death
    function check( ) returns boolean
        return not IsUnitType( GetTriggerUnit( ), UNIT_TYPE_HERO )
    
    function clear( )
        var u = GetTriggerUnit( )
        destroy ( getUnitId( u ) castTo Unitindex )
        SetUnitUserData( u, -1 )
    
    function add( ) returns boolean
        SetUnitUserData( GetFilterUnit( ), new Unitindex( ) castTo int )
        return true
    
    function groupAdd( )
        SetUnitUserData( GetEnumUnit( ), new Unitindex( ) castTo int  )

    init
        trigger t = CreateTrigger()
        region  r = CreateRegion()
        group   g = CreateGroup()
        
        //Use a filterfunc so units are indexed immediately
        RegionAddRect( r, bj_mapInitialPlayableArea )
        TriggerRegisterEnterRegion( t, r, And( Condition( function unitFilter ), Condition( function add ) ) )
        
        //Loop and group per player to grab all units, including those with locust
        for int i = 0 to 14
            GroupEnumUnitsOfPlayer( g, Player( i ), Condition( function unitFilter ) )
            ForGroup( g, function groupAdd )
        
        //Set up the on-death trigger to clear custom values
        t = CreateTrigger( )
        TriggerAddAction( t, function clear )
        TriggerAddCondition( t, Condition( function check ) )
        TriggerRegisterAnyUnitEventBJ( t, EVENT_PLAYER_UNIT_DEATH )
        
        DestroyGroup( g )
    
endpackage //===========================================================================
// Trigger: AbortSpell
//===========================================================================
//TESH.scrollpos=2
//TESH.alwaysfold=0
package AbortSpell
    
    import LastOrder
    import SimError
    //******************************************************************************
    //* BY: Rising_Dusk
    //* 
    //* The AbortSpell function in this library works just like the normal 
    //* SimError, except that it gives options for reissuing the unit's last order
    //* and forcing a UI key for its owner to fully simulate a WC3 error message as
    //* close as humanly possible.
    //* 
    //* AbortSpell is valuable when used in the ISSUED_ORDER trigger event 
    //* callbacks. It is specifically designed to be used as a means for preventing
    //* a unit from casting a spell and still continuing with whatever their last
    //* order was. It also works on the SPELL_CAST event callback, but using it on
    //* the order callbacks prevents the caster from turning/walking towards the
    //* target point/unit/etc.
    //* 
    //* Sample Function Usage:
    //*     call AbortSpell(MyUnit, "Error Message", "G")
    //*
    
    public function abortSpell( unit u, string msg, string keyToPress ) returns boolean
        if abortOrder( u )
            simError(GetOwningPlayer( u ), msg )
            if GetLocalPlayer( ) == GetOwningPlayer( u ) and StringLength( keyToPress ) == 1 and keyToPress != " "
                ForceUIKey( keyToPress )
            return issueSecondLastOrder( u )
        return FALSE
endpackage //===========================================================================
function InitCustomTriggers takes nothing returns nothing
    call InitTrig_GlobalInit(  )
    call InitTrig_Constants(  )
    call InitTrig_PlayerData(  )
    call InitTrig_Board(  )
    call InitTrig_Quests(  )
    call InitTrig_QueenLevelUp(  )
    call InitTrig_PlayerCommands(  )
    call InitTrig_ModeChoosing(  )
    call InitTrig_HeroChoosing(  )
    call InitTrig_HeroRevive(  )
    call InitTrig_RecipeData(  )
    call InitTrig_Items(  )
    call InitTrig_WarriorSet(  )
    call InitTrig_SpawnSystem(  )
    call InitTrig_BossKill(  )
    call InitTrig_TowerSystem(  )
    call InitTrig_Gold(  )
    call InitTrig_FallenSoldier(  )
    call InitTrig_Deathstop(  )
    call InitTrig_Deadlife(  )
    call InitTrig_Death_Aura(  )
    call InitTrig_AquaBurst(  )
    call InitTrig_TermalEruption(  )
    call InitTrig_autofly(  )
    call InitTrig_SimError(  )
    call InitTrig_LastOrder(  )
    call InitTrig_UnitUserData(  )
    call InitTrig_AbortSpell(  )
endfunction

//***************************************************************************
//*
//*  Players
//*
//***************************************************************************

function InitCustomPlayerSlots takes nothing returns nothing

    // Player 0
    call SetPlayerStartLocation( Player(0), 0 )
    call ForcePlayerStartLocation( Player(0), 0 )
    call SetPlayerColor( Player(0), ConvertPlayerColor(0) )
    call SetPlayerRacePreference( Player(0), RACE_PREF_NIGHTELF )
    call SetPlayerRaceSelectable( Player(0), false )
    call SetPlayerController( Player(0), MAP_CONTROL_COMPUTER )

    // Player 1
    call SetPlayerStartLocation( Player(1), 1 )
    call ForcePlayerStartLocation( Player(1), 1 )
    call SetPlayerColor( Player(1), ConvertPlayerColor(1) )
    call SetPlayerRacePreference( Player(1), RACE_PREF_NIGHTELF )
    call SetPlayerRaceSelectable( Player(1), false )
    call SetPlayerController( Player(1), MAP_CONTROL_USER )

    // Player 2
    call SetPlayerStartLocation( Player(2), 2 )
    call ForcePlayerStartLocation( Player(2), 2 )
    call SetPlayerColor( Player(2), ConvertPlayerColor(2) )
    call SetPlayerRacePreference( Player(2), RACE_PREF_NIGHTELF )
    call SetPlayerRaceSelectable( Player(2), false )
    call SetPlayerController( Player(2), MAP_CONTROL_USER )

    // Player 3
    call SetPlayerStartLocation( Player(3), 3 )
    call ForcePlayerStartLocation( Player(3), 3 )
    call SetPlayerColor( Player(3), ConvertPlayerColor(3) )
    call SetPlayerRacePreference( Player(3), RACE_PREF_NIGHTELF )
    call SetPlayerRaceSelectable( Player(3), false )
    call SetPlayerController( Player(3), MAP_CONTROL_USER )

    // Player 4
    call SetPlayerStartLocation( Player(4), 4 )
    call ForcePlayerStartLocation( Player(4), 4 )
    call SetPlayerColor( Player(4), ConvertPlayerColor(4) )
    call SetPlayerRacePreference( Player(4), RACE_PREF_NIGHTELF )
    call SetPlayerRaceSelectable( Player(4), false )
    call SetPlayerController( Player(4), MAP_CONTROL_USER )

    // Player 5
    call SetPlayerStartLocation( Player(5), 5 )
    call ForcePlayerStartLocation( Player(5), 5 )
    call SetPlayerColor( Player(5), ConvertPlayerColor(5) )
    call SetPlayerRacePreference( Player(5), RACE_PREF_NIGHTELF )
    call SetPlayerRaceSelectable( Player(5), false )
    call SetPlayerController( Player(5), MAP_CONTROL_USER )

    // Player 11
    call SetPlayerStartLocation( Player(11), 6 )
    call ForcePlayerStartLocation( Player(11), 6 )
    call SetPlayerColor( Player(11), ConvertPlayerColor(11) )
    call SetPlayerRacePreference( Player(11), RACE_PREF_UNDEAD )
    call SetPlayerRaceSelectable( Player(11), false )
    call SetPlayerController( Player(11), MAP_CONTROL_COMPUTER )

endfunction

function InitCustomTeams takes nothing returns nothing
    // Force: TRIGSTR_013
    call SetPlayerTeam( Player(0), 0 )
    call SetPlayerState( Player(0), PLAYER_STATE_ALLIED_VICTORY, 1 )
    call SetPlayerTeam( Player(1), 0 )
    call SetPlayerState( Player(1), PLAYER_STATE_ALLIED_VICTORY, 1 )
    call SetPlayerTeam( Player(2), 0 )
    call SetPlayerState( Player(2), PLAYER_STATE_ALLIED_VICTORY, 1 )
    call SetPlayerTeam( Player(3), 0 )
    call SetPlayerState( Player(3), PLAYER_STATE_ALLIED_VICTORY, 1 )
    call SetPlayerTeam( Player(4), 0 )
    call SetPlayerState( Player(4), PLAYER_STATE_ALLIED_VICTORY, 1 )
    call SetPlayerTeam( Player(5), 0 )
    call SetPlayerState( Player(5), PLAYER_STATE_ALLIED_VICTORY, 1 )

    //   Allied
    call SetPlayerAllianceStateAllyBJ( Player(0), Player(1), true )
    call SetPlayerAllianceStateAllyBJ( Player(0), Player(2), true )
    call SetPlayerAllianceStateAllyBJ( Player(0), Player(3), true )
    call SetPlayerAllianceStateAllyBJ( Player(0), Player(4), true )
    call SetPlayerAllianceStateAllyBJ( Player(0), Player(5), true )
    call SetPlayerAllianceStateAllyBJ( Player(1), Player(0), true )
    call SetPlayerAllianceStateAllyBJ( Player(1), Player(2), true )
    call SetPlayerAllianceStateAllyBJ( Player(1), Player(3), true )
    call SetPlayerAllianceStateAllyBJ( Player(1), Player(4), true )
    call SetPlayerAllianceStateAllyBJ( Player(1), Player(5), true )
    call SetPlayerAllianceStateAllyBJ( Player(2), Player(0), true )
    call SetPlayerAllianceStateAllyBJ( Player(2), Player(1), true )
    call SetPlayerAllianceStateAllyBJ( Player(2), Player(3), true )
    call SetPlayerAllianceStateAllyBJ( Player(2), Player(4), true )
    call SetPlayerAllianceStateAllyBJ( Player(2), Player(5), true )
    call SetPlayerAllianceStateAllyBJ( Player(3), Player(0), true )
    call SetPlayerAllianceStateAllyBJ( Player(3), Player(1), true )
    call SetPlayerAllianceStateAllyBJ( Player(3), Player(2), true )
    call SetPlayerAllianceStateAllyBJ( Player(3), Player(4), true )
    call SetPlayerAllianceStateAllyBJ( Player(3), Player(5), true )
    call SetPlayerAllianceStateAllyBJ( Player(4), Player(0), true )
    call SetPlayerAllianceStateAllyBJ( Player(4), Player(1), true )
    call SetPlayerAllianceStateAllyBJ( Player(4), Player(2), true )
    call SetPlayerAllianceStateAllyBJ( Player(4), Player(3), true )
    call SetPlayerAllianceStateAllyBJ( Player(4), Player(5), true )
    call SetPlayerAllianceStateAllyBJ( Player(5), Player(0), true )
    call SetPlayerAllianceStateAllyBJ( Player(5), Player(1), true )
    call SetPlayerAllianceStateAllyBJ( Player(5), Player(2), true )
    call SetPlayerAllianceStateAllyBJ( Player(5), Player(3), true )
    call SetPlayerAllianceStateAllyBJ( Player(5), Player(4), true )

    //   Shared Vision
    call SetPlayerAllianceStateVisionBJ( Player(0), Player(1), true )
    call SetPlayerAllianceStateVisionBJ( Player(0), Player(2), true )
    call SetPlayerAllianceStateVisionBJ( Player(0), Player(3), true )
    call SetPlayerAllianceStateVisionBJ( Player(0), Player(4), true )
    call SetPlayerAllianceStateVisionBJ( Player(0), Player(5), true )
    call SetPlayerAllianceStateVisionBJ( Player(1), Player(0), true )
    call SetPlayerAllianceStateVisionBJ( Player(1), Player(2), true )
    call SetPlayerAllianceStateVisionBJ( Player(1), Player(3), true )
    call SetPlayerAllianceStateVisionBJ( Player(1), Player(4), true )
    call SetPlayerAllianceStateVisionBJ( Player(1), Player(5), true )
    call SetPlayerAllianceStateVisionBJ( Player(2), Player(0), true )
    call SetPlayerAllianceStateVisionBJ( Player(2), Player(1), true )
    call SetPlayerAllianceStateVisionBJ( Player(2), Player(3), true )
    call SetPlayerAllianceStateVisionBJ( Player(2), Player(4), true )
    call SetPlayerAllianceStateVisionBJ( Player(2), Player(5), true )
    call SetPlayerAllianceStateVisionBJ( Player(3), Player(0), true )
    call SetPlayerAllianceStateVisionBJ( Player(3), Player(1), true )
    call SetPlayerAllianceStateVisionBJ( Player(3), Player(2), true )
    call SetPlayerAllianceStateVisionBJ( Player(3), Player(4), true )
    call SetPlayerAllianceStateVisionBJ( Player(3), Player(5), true )
    call SetPlayerAllianceStateVisionBJ( Player(4), Player(0), true )
    call SetPlayerAllianceStateVisionBJ( Player(4), Player(1), true )
    call SetPlayerAllianceStateVisionBJ( Player(4), Player(2), true )
    call SetPlayerAllianceStateVisionBJ( Player(4), Player(3), true )
    call SetPlayerAllianceStateVisionBJ( Player(4), Player(5), true )
    call SetPlayerAllianceStateVisionBJ( Player(5), Player(0), true )
    call SetPlayerAllianceStateVisionBJ( Player(5), Player(1), true )
    call SetPlayerAllianceStateVisionBJ( Player(5), Player(2), true )
    call SetPlayerAllianceStateVisionBJ( Player(5), Player(3), true )
    call SetPlayerAllianceStateVisionBJ( Player(5), Player(4), true )

    // Force: TRIGSTR_012
    call SetPlayerTeam( Player(11), 1 )
    call SetPlayerState( Player(11), PLAYER_STATE_ALLIED_VICTORY, 1 )

endfunction

function InitAllyPriorities takes nothing returns nothing

    call SetStartLocPrioCount( 1, 4 )
    call SetStartLocPrio( 1, 0, 2, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 1, 1, 3, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 1, 2, 4, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 1, 3, 5, MAP_LOC_PRIO_HIGH )

    call SetStartLocPrioCount( 2, 4 )
    call SetStartLocPrio( 2, 0, 1, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 2, 1, 3, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 2, 2, 4, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 2, 3, 5, MAP_LOC_PRIO_HIGH )

    call SetStartLocPrioCount( 3, 4 )
    call SetStartLocPrio( 3, 0, 1, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 3, 1, 2, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 3, 2, 4, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 3, 3, 5, MAP_LOC_PRIO_HIGH )

    call SetStartLocPrioCount( 4, 4 )
    call SetStartLocPrio( 4, 0, 1, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 4, 1, 2, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 4, 2, 3, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 4, 3, 5, MAP_LOC_PRIO_HIGH )

    call SetStartLocPrioCount( 5, 4 )
    call SetStartLocPrio( 5, 0, 1, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 5, 1, 2, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 5, 2, 3, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 5, 3, 4, MAP_LOC_PRIO_HIGH )
endfunction

//***************************************************************************
//*
//*  Main Initialization
//*
//***************************************************************************

//===========================================================================
function main takes nothing returns nothing
    call SetCameraBounds( -3328.0 + GetCameraMargin(CAMERA_MARGIN_LEFT), -3584.0 + GetCameraMargin(CAMERA_MARGIN_BOTTOM), 3328.0 - GetCameraMargin(CAMERA_MARGIN_RIGHT), 3072.0 - GetCameraMargin(CAMERA_MARGIN_TOP), -3328.0 + GetCameraMargin(CAMERA_MARGIN_LEFT), 3072.0 - GetCameraMargin(CAMERA_MARGIN_TOP), 3328.0 - GetCameraMargin(CAMERA_MARGIN_RIGHT), -3584.0 + GetCameraMargin(CAMERA_MARGIN_BOTTOM) )
    call SetDayNightModels( "Environment\\DNC\\DNCLordaeron\\DNCLordaeronTerrain\\DNCLordaeronTerrain.mdl", "Environment\\DNC\\DNCLordaeron\\DNCLordaeronUnit\\DNCLordaeronUnit.mdl" )
    call SetTerrainFogEx( 0, 1500.0, 5000.0, 0.300, 0.490, 0.490, 0.000 )
    call SetWaterBaseColor( 80, 80, 120, 255 )
    call NewSoundEnvironment( "lake" )
    call SetAmbientDaySound( "SunkenRuinsDay" )
    call SetAmbientNightSound( "SunkenRuinsNight" )
    call SetMapMusic( "Music", true, 0 )
    call InitSounds(  )
    call CreateRegions(  )
    call CreateAllUnits(  )
    call InitBlizzard(  )
    call InitGlobals(  )
    call InitCustomTriggers(  )

endfunction

//***************************************************************************
//*
//*  Map Configuration
//*
//***************************************************************************

function config takes nothing returns nothing
    call SetMapName( "TRIGSTR_001" )
    call SetMapDescription( "TRIGSTR_003" )
    call SetPlayers( 7 )
    call SetTeams( 7 )
    call SetGamePlacement( MAP_PLACEMENT_TEAMS_TOGETHER )

    call DefineStartLocation( 0, 960.0, 896.0 )
    call DefineStartLocation( 1, 2752.0, 2432.0 )
    call DefineStartLocation( 2, 2752.0, 2432.0 )
    call DefineStartLocation( 3, 2752.0, 2432.0 )
    call DefineStartLocation( 4, 2752.0, 2432.0 )
    call DefineStartLocation( 5, 2752.0, 2432.0 )
    call DefineStartLocation( 6, -3200.0, -3456.0 )

    // Player setup
    call InitCustomPlayerSlots(  )
    call InitCustomTeams(  )
    call InitAllyPriorities(  )
endfunction

